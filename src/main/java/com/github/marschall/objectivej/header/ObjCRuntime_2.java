// Generated by jextract

package com.github.marschall.objectivej.header;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class ObjCRuntime_2 {

    ObjCRuntime_2() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("objc"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int __has_safe_buffers = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_safe_buffers 0
     * }
     */
    public static int __has_safe_buffers() {
        return __has_safe_buffers;
    }
    private static final int __DARWIN_ONLY_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_ONLY_64_BIT_INO_T() {
        return __DARWIN_ONLY_64_BIT_INO_T;
    }
    private static final int __DARWIN_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int __DARWIN_ONLY_UNIX_CONFORMANCE() {
        return __DARWIN_ONLY_UNIX_CONFORMANCE;
    }
    private static final int __DARWIN_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_VERS_1050 1
     * }
     */
    public static int __DARWIN_ONLY_VERS_1050() {
        return __DARWIN_ONLY_VERS_1050;
    }
    private static final int __DARWIN_UNIX03 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_UNIX03 1
     * }
     */
    public static int __DARWIN_UNIX03() {
        return __DARWIN_UNIX03;
    }
    private static final int __DARWIN_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_64_BIT_INO_T() {
        return __DARWIN_64_BIT_INO_T;
    }
    private static final int __DARWIN_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_VERS_1050 1
     * }
     */
    public static int __DARWIN_VERS_1050() {
        return __DARWIN_VERS_1050;
    }
    private static final int __DARWIN_NON_CANCELABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NON_CANCELABLE 0
     * }
     */
    public static int __DARWIN_NON_CANCELABLE() {
        return __DARWIN_NON_CANCELABLE;
    }
    private static final int __STDC_WANT_LIB_EXT1__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_LIB_EXT1__ 1
     * }
     */
    public static int __STDC_WANT_LIB_EXT1__() {
        return __STDC_WANT_LIB_EXT1__;
    }
    private static final int __DARWIN_NO_LONG_LONG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NO_LONG_LONG 0
     * }
     */
    public static int __DARWIN_NO_LONG_LONG() {
        return __DARWIN_NO_LONG_LONG;
    }
    private static final int _DARWIN_FEATURE_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_64_BIT_INODE() {
        return _DARWIN_FEATURE_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_64_BIT_INODE() {
        return _DARWIN_FEATURE_ONLY_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_VERS_1050 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_VERS_1050() {
        return _DARWIN_FEATURE_ONLY_VERS_1050;
    }
    private static final int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE;
    }
    private static final int _DARWIN_FEATURE_UNIX_CONFORMANCE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_UNIX_CONFORMANCE 3
     * }
     */
    public static int _DARWIN_FEATURE_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_UNIX_CONFORMANCE;
    }
    private static final int __has_ptrcheck = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_ptrcheck 0
     * }
     */
    public static int __has_ptrcheck() {
        return __has_ptrcheck;
    }
    private static final int USE_CLANG_TYPES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define USE_CLANG_TYPES 0
     * }
     */
    public static int USE_CLANG_TYPES() {
        return USE_CLANG_TYPES;
    }
    private static final int __PTHREAD_SIZE__ = (int)8176L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_SIZE__ 8176
     * }
     */
    public static int __PTHREAD_SIZE__() {
        return __PTHREAD_SIZE__;
    }
    private static final int __PTHREAD_ATTR_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ATTR_SIZE__ 56
     * }
     */
    public static int __PTHREAD_ATTR_SIZE__() {
        return __PTHREAD_ATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEXATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEXATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_MUTEXATTR_SIZE__() {
        return __PTHREAD_MUTEXATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEX_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_SIZE__ 56
     * }
     */
    public static int __PTHREAD_MUTEX_SIZE__() {
        return __PTHREAD_MUTEX_SIZE__;
    }
    private static final int __PTHREAD_CONDATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_CONDATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_CONDATTR_SIZE__() {
        return __PTHREAD_CONDATTR_SIZE__;
    }
    private static final int __PTHREAD_COND_SIZE__ = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_COND_SIZE__ 40
     * }
     */
    public static int __PTHREAD_COND_SIZE__() {
        return __PTHREAD_COND_SIZE__;
    }
    private static final int __PTHREAD_ONCE_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ONCE_SIZE__ 8
     * }
     */
    public static int __PTHREAD_ONCE_SIZE__() {
        return __PTHREAD_ONCE_SIZE__;
    }
    private static final int __PTHREAD_RWLOCK_SIZE__ = (int)192L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_SIZE__ 192
     * }
     */
    public static int __PTHREAD_RWLOCK_SIZE__() {
        return __PTHREAD_RWLOCK_SIZE__;
    }
    private static final int __PTHREAD_RWLOCKATTR_SIZE__ = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCKATTR_SIZE__ 16
     * }
     */
    public static int __PTHREAD_RWLOCKATTR_SIZE__() {
        return __PTHREAD_RWLOCKATTR_SIZE__;
    }
    private static final int __DARWIN_NSIG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NSIG 32
     * }
     */
    public static int __DARWIN_NSIG() {
        return __DARWIN_NSIG;
    }
    private static final int SIGHUP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIGHUP 1
     * }
     */
    public static int SIGHUP() {
        return SIGHUP;
    }
    private static final int SIGINT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIGINT 2
     * }
     */
    public static int SIGINT() {
        return SIGINT;
    }
    private static final int SIGQUIT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIGQUIT 3
     * }
     */
    public static int SIGQUIT() {
        return SIGQUIT;
    }
    private static final int SIGILL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIGILL 4
     * }
     */
    public static int SIGILL() {
        return SIGILL;
    }
    private static final int SIGTRAP = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SIGTRAP 5
     * }
     */
    public static int SIGTRAP() {
        return SIGTRAP;
    }
    private static final int SIGABRT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGABRT 6
     * }
     */
    public static int SIGABRT() {
        return SIGABRT;
    }
    private static final int SIGEMT = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SIGEMT 7
     * }
     */
    public static int SIGEMT() {
        return SIGEMT;
    }
    private static final int SIGFPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIGFPE 8
     * }
     */
    public static int SIGFPE() {
        return SIGFPE;
    }
    private static final int SIGKILL = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SIGKILL 9
     * }
     */
    public static int SIGKILL() {
        return SIGKILL;
    }
    private static final int SIGBUS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define SIGBUS 10
     * }
     */
    public static int SIGBUS() {
        return SIGBUS;
    }
    private static final int SIGSEGV = (int)11L;
    /**
     * {@snippet lang=c :
     * #define SIGSEGV 11
     * }
     */
    public static int SIGSEGV() {
        return SIGSEGV;
    }
    private static final int SIGSYS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define SIGSYS 12
     * }
     */
    public static int SIGSYS() {
        return SIGSYS;
    }
    private static final int SIGPIPE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define SIGPIPE 13
     * }
     */
    public static int SIGPIPE() {
        return SIGPIPE;
    }
    private static final int SIGALRM = (int)14L;
    /**
     * {@snippet lang=c :
     * #define SIGALRM 14
     * }
     */
    public static int SIGALRM() {
        return SIGALRM;
    }
    private static final int SIGTERM = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SIGTERM 15
     * }
     */
    public static int SIGTERM() {
        return SIGTERM;
    }
    private static final int SIGURG = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SIGURG 16
     * }
     */
    public static int SIGURG() {
        return SIGURG;
    }
    private static final int SIGSTOP = (int)17L;
    /**
     * {@snippet lang=c :
     * #define SIGSTOP 17
     * }
     */
    public static int SIGSTOP() {
        return SIGSTOP;
    }
    private static final int SIGTSTP = (int)18L;
    /**
     * {@snippet lang=c :
     * #define SIGTSTP 18
     * }
     */
    public static int SIGTSTP() {
        return SIGTSTP;
    }
    private static final int SIGCONT = (int)19L;
    /**
     * {@snippet lang=c :
     * #define SIGCONT 19
     * }
     */
    public static int SIGCONT() {
        return SIGCONT;
    }
    private static final int SIGCHLD = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SIGCHLD 20
     * }
     */
    public static int SIGCHLD() {
        return SIGCHLD;
    }
    private static final int SIGTTIN = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SIGTTIN 21
     * }
     */
    public static int SIGTTIN() {
        return SIGTTIN;
    }
    private static final int SIGTTOU = (int)22L;
    /**
     * {@snippet lang=c :
     * #define SIGTTOU 22
     * }
     */
    public static int SIGTTOU() {
        return SIGTTOU;
    }
    private static final int SIGIO = (int)23L;
    /**
     * {@snippet lang=c :
     * #define SIGIO 23
     * }
     */
    public static int SIGIO() {
        return SIGIO;
    }
    private static final int SIGXCPU = (int)24L;
    /**
     * {@snippet lang=c :
     * #define SIGXCPU 24
     * }
     */
    public static int SIGXCPU() {
        return SIGXCPU;
    }
    private static final int SIGXFSZ = (int)25L;
    /**
     * {@snippet lang=c :
     * #define SIGXFSZ 25
     * }
     */
    public static int SIGXFSZ() {
        return SIGXFSZ;
    }
    private static final int SIGVTALRM = (int)26L;
    /**
     * {@snippet lang=c :
     * #define SIGVTALRM 26
     * }
     */
    public static int SIGVTALRM() {
        return SIGVTALRM;
    }
    private static final int SIGPROF = (int)27L;
    /**
     * {@snippet lang=c :
     * #define SIGPROF 27
     * }
     */
    public static int SIGPROF() {
        return SIGPROF;
    }
    private static final int SIGWINCH = (int)28L;
    /**
     * {@snippet lang=c :
     * #define SIGWINCH 28
     * }
     */
    public static int SIGWINCH() {
        return SIGWINCH;
    }
    private static final int SIGINFO = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SIGINFO 29
     * }
     */
    public static int SIGINFO() {
        return SIGINFO;
    }
    private static final int SIGUSR1 = (int)30L;
    /**
     * {@snippet lang=c :
     * #define SIGUSR1 30
     * }
     */
    public static int SIGUSR1() {
        return SIGUSR1;
    }
    private static final int SIGUSR2 = (int)31L;
    /**
     * {@snippet lang=c :
     * #define SIGUSR2 31
     * }
     */
    public static int SIGUSR2() {
        return SIGUSR2;
    }
    private static final int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_OPAQUE_ARM_THREAD_STATE64 0
     * }
     */
    public static int __DARWIN_OPAQUE_ARM_THREAD_STATE64() {
        return __DARWIN_OPAQUE_ARM_THREAD_STATE64;
    }
    private static final int USE_CLANG_STDDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define USE_CLANG_STDDEF 0
     * }
     */
    public static int USE_CLANG_STDDEF() {
        return USE_CLANG_STDDEF;
    }
    private static final int SIGEV_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_NONE 0
     * }
     */
    public static int SIGEV_NONE() {
        return SIGEV_NONE;
    }
    private static final int SIGEV_SIGNAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_SIGNAL 1
     * }
     */
    public static int SIGEV_SIGNAL() {
        return SIGEV_SIGNAL;
    }
    private static final int SIGEV_THREAD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_THREAD 3
     * }
     */
    public static int SIGEV_THREAD() {
        return SIGEV_THREAD;
    }
    private static final int ILL_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define ILL_NOOP 0
     * }
     */
    public static int ILL_NOOP() {
        return ILL_NOOP;
    }
    private static final int ILL_ILLOPC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLOPC 1
     * }
     */
    public static int ILL_ILLOPC() {
        return ILL_ILLOPC;
    }
    private static final int ILL_ILLTRP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLTRP 2
     * }
     */
    public static int ILL_ILLTRP() {
        return ILL_ILLTRP;
    }
    private static final int ILL_PRVOPC = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ILL_PRVOPC 3
     * }
     */
    public static int ILL_PRVOPC() {
        return ILL_PRVOPC;
    }
    private static final int ILL_ILLOPN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLOPN 4
     * }
     */
    public static int ILL_ILLOPN() {
        return ILL_ILLOPN;
    }
    private static final int ILL_ILLADR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLADR 5
     * }
     */
    public static int ILL_ILLADR() {
        return ILL_ILLADR;
    }
    private static final int ILL_PRVREG = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ILL_PRVREG 6
     * }
     */
    public static int ILL_PRVREG() {
        return ILL_PRVREG;
    }
    private static final int ILL_COPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * #define ILL_COPROC 7
     * }
     */
    public static int ILL_COPROC() {
        return ILL_COPROC;
    }
    private static final int ILL_BADSTK = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ILL_BADSTK 8
     * }
     */
    public static int ILL_BADSTK() {
        return ILL_BADSTK;
    }
    private static final int FPE_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FPE_NOOP 0
     * }
     */
    public static int FPE_NOOP() {
        return FPE_NOOP;
    }
    private static final int FPE_FLTDIV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTDIV 1
     * }
     */
    public static int FPE_FLTDIV() {
        return FPE_FLTDIV;
    }
    private static final int FPE_FLTOVF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTOVF 2
     * }
     */
    public static int FPE_FLTOVF() {
        return FPE_FLTOVF;
    }
    private static final int FPE_FLTUND = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTUND 3
     * }
     */
    public static int FPE_FLTUND() {
        return FPE_FLTUND;
    }
    private static final int FPE_FLTRES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTRES 4
     * }
     */
    public static int FPE_FLTRES() {
        return FPE_FLTRES;
    }
    private static final int FPE_FLTINV = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTINV 5
     * }
     */
    public static int FPE_FLTINV() {
        return FPE_FLTINV;
    }
    private static final int FPE_FLTSUB = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTSUB 6
     * }
     */
    public static int FPE_FLTSUB() {
        return FPE_FLTSUB;
    }
    private static final int FPE_INTDIV = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FPE_INTDIV 7
     * }
     */
    public static int FPE_INTDIV() {
        return FPE_INTDIV;
    }
    private static final int FPE_INTOVF = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FPE_INTOVF 8
     * }
     */
    public static int FPE_INTOVF() {
        return FPE_INTOVF;
    }
    private static final int SEGV_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEGV_NOOP 0
     * }
     */
    public static int SEGV_NOOP() {
        return SEGV_NOOP;
    }
    private static final int SEGV_MAPERR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEGV_MAPERR 1
     * }
     */
    public static int SEGV_MAPERR() {
        return SEGV_MAPERR;
    }
    private static final int SEGV_ACCERR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEGV_ACCERR 2
     * }
     */
    public static int SEGV_ACCERR() {
        return SEGV_ACCERR;
    }
    private static final int BUS_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define BUS_NOOP 0
     * }
     */
    public static int BUS_NOOP() {
        return BUS_NOOP;
    }
    private static final int BUS_ADRALN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define BUS_ADRALN 1
     * }
     */
    public static int BUS_ADRALN() {
        return BUS_ADRALN;
    }
    private static final int BUS_ADRERR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define BUS_ADRERR 2
     * }
     */
    public static int BUS_ADRERR() {
        return BUS_ADRERR;
    }
    private static final int BUS_OBJERR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define BUS_OBJERR 3
     * }
     */
    public static int BUS_OBJERR() {
        return BUS_OBJERR;
    }
    private static final int TRAP_BRKPT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TRAP_BRKPT 1
     * }
     */
    public static int TRAP_BRKPT() {
        return TRAP_BRKPT;
    }
    private static final int TRAP_TRACE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TRAP_TRACE 2
     * }
     */
    public static int TRAP_TRACE() {
        return TRAP_TRACE;
    }
    private static final int CLD_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CLD_NOOP 0
     * }
     */
    public static int CLD_NOOP() {
        return CLD_NOOP;
    }
    private static final int CLD_EXITED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLD_EXITED 1
     * }
     */
    public static int CLD_EXITED() {
        return CLD_EXITED;
    }
    private static final int CLD_KILLED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CLD_KILLED 2
     * }
     */
    public static int CLD_KILLED() {
        return CLD_KILLED;
    }
    private static final int CLD_DUMPED = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLD_DUMPED 3
     * }
     */
    public static int CLD_DUMPED() {
        return CLD_DUMPED;
    }
    private static final int CLD_TRAPPED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLD_TRAPPED 4
     * }
     */
    public static int CLD_TRAPPED() {
        return CLD_TRAPPED;
    }
    private static final int CLD_STOPPED = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLD_STOPPED 5
     * }
     */
    public static int CLD_STOPPED() {
        return CLD_STOPPED;
    }
    private static final int CLD_CONTINUED = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CLD_CONTINUED 6
     * }
     */
    public static int CLD_CONTINUED() {
        return CLD_CONTINUED;
    }
    private static final int POLL_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLL_IN 1
     * }
     */
    public static int POLL_IN() {
        return POLL_IN;
    }
    private static final int POLL_OUT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define POLL_OUT 2
     * }
     */
    public static int POLL_OUT() {
        return POLL_OUT;
    }
    private static final int POLL_MSG = (int)3L;
    /**
     * {@snippet lang=c :
     * #define POLL_MSG 3
     * }
     */
    public static int POLL_MSG() {
        return POLL_MSG;
    }
    private static final int POLL_ERR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define POLL_ERR 4
     * }
     */
    public static int POLL_ERR() {
        return POLL_ERR;
    }
    private static final int POLL_PRI = (int)5L;
    /**
     * {@snippet lang=c :
     * #define POLL_PRI 5
     * }
     */
    public static int POLL_PRI() {
        return POLL_PRI;
    }
    private static final int POLL_HUP = (int)6L;
    /**
     * {@snippet lang=c :
     * #define POLL_HUP 6
     * }
     */
    public static int POLL_HUP() {
        return POLL_HUP;
    }
    private static final int SA_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SA_ONSTACK 1
     * }
     */
    public static int SA_ONSTACK() {
        return SA_ONSTACK;
    }
    private static final int SA_RESTART = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SA_RESTART 2
     * }
     */
    public static int SA_RESTART() {
        return SA_RESTART;
    }
    private static final int SA_RESETHAND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SA_RESETHAND 4
     * }
     */
    public static int SA_RESETHAND() {
        return SA_RESETHAND;
    }
    private static final int SA_NOCLDSTOP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SA_NOCLDSTOP 8
     * }
     */
    public static int SA_NOCLDSTOP() {
        return SA_NOCLDSTOP;
    }
    private static final int SA_NODEFER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SA_NODEFER 16
     * }
     */
    public static int SA_NODEFER() {
        return SA_NODEFER;
    }
    private static final int SA_NOCLDWAIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SA_NOCLDWAIT 32
     * }
     */
    public static int SA_NOCLDWAIT() {
        return SA_NOCLDWAIT;
    }
    private static final int SA_SIGINFO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SA_SIGINFO 64
     * }
     */
    public static int SA_SIGINFO() {
        return SA_SIGINFO;
    }
    private static final int SA_USERTRAMP = (int)256L;
    /**
     * {@snippet lang=c :
     * #define SA_USERTRAMP 256
     * }
     */
    public static int SA_USERTRAMP() {
        return SA_USERTRAMP;
    }
    private static final int SA_64REGSET = (int)512L;
    /**
     * {@snippet lang=c :
     * #define SA_64REGSET 512
     * }
     */
    public static int SA_64REGSET() {
        return SA_64REGSET;
    }
    private static final int SIG_BLOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIG_BLOCK 1
     * }
     */
    public static int SIG_BLOCK() {
        return SIG_BLOCK;
    }
    private static final int SIG_UNBLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIG_UNBLOCK 2
     * }
     */
    public static int SIG_UNBLOCK() {
        return SIG_UNBLOCK;
    }
    private static final int SIG_SETMASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIG_SETMASK 3
     * }
     */
    public static int SIG_SETMASK() {
        return SIG_SETMASK;
    }
    private static final int SI_USER = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define SI_USER 65537
     * }
     */
    public static int SI_USER() {
        return SI_USER;
    }
    private static final int SI_QUEUE = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define SI_QUEUE 65538
     * }
     */
    public static int SI_QUEUE() {
        return SI_QUEUE;
    }
    private static final int SI_TIMER = (int)65539L;
    /**
     * {@snippet lang=c :
     * #define SI_TIMER 65539
     * }
     */
    public static int SI_TIMER() {
        return SI_TIMER;
    }
    private static final int SI_ASYNCIO = (int)65540L;
    /**
     * {@snippet lang=c :
     * #define SI_ASYNCIO 65540
     * }
     */
    public static int SI_ASYNCIO() {
        return SI_ASYNCIO;
    }
    private static final int SI_MESGQ = (int)65541L;
    /**
     * {@snippet lang=c :
     * #define SI_MESGQ 65541
     * }
     */
    public static int SI_MESGQ() {
        return SI_MESGQ;
    }
    private static final int SS_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SS_ONSTACK 1
     * }
     */
    public static int SS_ONSTACK() {
        return SS_ONSTACK;
    }
    private static final int SS_DISABLE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SS_DISABLE 4
     * }
     */
    public static int SS_DISABLE() {
        return SS_DISABLE;
    }
    private static final int MINSIGSTKSZ = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MINSIGSTKSZ 32768
     * }
     */
    public static int MINSIGSTKSZ() {
        return MINSIGSTKSZ;
    }
    private static final int SIGSTKSZ = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define SIGSTKSZ 131072
     * }
     */
    public static int SIGSTKSZ() {
        return SIGSTKSZ;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int PRIO_PROCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PRIO_PROCESS 0
     * }
     */
    public static int PRIO_PROCESS() {
        return PRIO_PROCESS;
    }
    private static final int PRIO_PGRP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PRIO_PGRP 1
     * }
     */
    public static int PRIO_PGRP() {
        return PRIO_PGRP;
    }
    private static final int PRIO_USER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PRIO_USER 2
     * }
     */
    public static int PRIO_USER() {
        return PRIO_USER;
    }
    private static final int PRIO_DARWIN_THREAD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_THREAD 3
     * }
     */
    public static int PRIO_DARWIN_THREAD() {
        return PRIO_DARWIN_THREAD;
    }
    private static final int PRIO_DARWIN_PROCESS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_PROCESS 4
     * }
     */
    public static int PRIO_DARWIN_PROCESS() {
        return PRIO_DARWIN_PROCESS;
    }
    private static final int PRIO_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define PRIO_MAX 20
     * }
     */
    public static int PRIO_MAX() {
        return PRIO_MAX;
    }
    private static final int PRIO_DARWIN_BG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_BG 4096
     * }
     */
    public static int PRIO_DARWIN_BG() {
        return PRIO_DARWIN_BG;
    }
    private static final int PRIO_DARWIN_NONUI = (int)4097L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_NONUI 4097
     * }
     */
    public static int PRIO_DARWIN_NONUI() {
        return PRIO_DARWIN_NONUI;
    }
    private static final int RUSAGE_SELF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_SELF 0
     * }
     */
    public static int RUSAGE_SELF() {
        return RUSAGE_SELF;
    }
    private static final int RUSAGE_INFO_V0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V0 0
     * }
     */
    public static int RUSAGE_INFO_V0() {
        return RUSAGE_INFO_V0;
    }
    private static final int RUSAGE_INFO_V1 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V1 1
     * }
     */
    public static int RUSAGE_INFO_V1() {
        return RUSAGE_INFO_V1;
    }
    private static final int RUSAGE_INFO_V2 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V2 2
     * }
     */
    public static int RUSAGE_INFO_V2() {
        return RUSAGE_INFO_V2;
    }
    private static final int RUSAGE_INFO_V3 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V3 3
     * }
     */
    public static int RUSAGE_INFO_V3() {
        return RUSAGE_INFO_V3;
    }
    private static final int RUSAGE_INFO_V4 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V4 4
     * }
     */
    public static int RUSAGE_INFO_V4() {
        return RUSAGE_INFO_V4;
    }
    private static final int RUSAGE_INFO_V5 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V5 5
     * }
     */
    public static int RUSAGE_INFO_V5() {
        return RUSAGE_INFO_V5;
    }
    private static final int RUSAGE_INFO_V6 = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V6 6
     * }
     */
    public static int RUSAGE_INFO_V6() {
        return RUSAGE_INFO_V6;
    }
    private static final int RU_PROC_RUNS_RESLIDE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RU_PROC_RUNS_RESLIDE 1
     * }
     */
    public static int RU_PROC_RUNS_RESLIDE() {
        return RU_PROC_RUNS_RESLIDE;
    }
    private static final int RLIMIT_CPU = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CPU 0
     * }
     */
    public static int RLIMIT_CPU() {
        return RLIMIT_CPU;
    }
    private static final int RLIMIT_FSIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_FSIZE 1
     * }
     */
    public static int RLIMIT_FSIZE() {
        return RLIMIT_FSIZE;
    }
    private static final int RLIMIT_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_DATA 2
     * }
     */
    public static int RLIMIT_DATA() {
        return RLIMIT_DATA;
    }
    private static final int RLIMIT_STACK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_STACK 3
     * }
     */
    public static int RLIMIT_STACK() {
        return RLIMIT_STACK;
    }
    private static final int RLIMIT_CORE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CORE 4
     * }
     */
    public static int RLIMIT_CORE() {
        return RLIMIT_CORE;
    }
    private static final int RLIMIT_AS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_AS 5
     * }
     */
    public static int RLIMIT_AS() {
        return RLIMIT_AS;
    }
    private static final int RLIMIT_MEMLOCK = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_MEMLOCK 6
     * }
     */
    public static int RLIMIT_MEMLOCK() {
        return RLIMIT_MEMLOCK;
    }
    private static final int RLIMIT_NPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_NPROC 7
     * }
     */
    public static int RLIMIT_NPROC() {
        return RLIMIT_NPROC;
    }
    private static final int RLIMIT_NOFILE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_NOFILE 8
     * }
     */
    public static int RLIMIT_NOFILE() {
        return RLIMIT_NOFILE;
    }
    private static final int RLIM_NLIMITS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define RLIM_NLIMITS 9
     * }
     */
    public static int RLIM_NLIMITS() {
        return RLIM_NLIMITS;
    }
    private static final int _RLIMIT_POSIX_FLAG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _RLIMIT_POSIX_FLAG 4096
     * }
     */
    public static int _RLIMIT_POSIX_FLAG() {
        return _RLIMIT_POSIX_FLAG;
    }
    private static final int RLIMIT_WAKEUPS_MONITOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_WAKEUPS_MONITOR 1
     * }
     */
    public static int RLIMIT_WAKEUPS_MONITOR() {
        return RLIMIT_WAKEUPS_MONITOR;
    }
    private static final int RLIMIT_CPU_USAGE_MONITOR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CPU_USAGE_MONITOR 2
     * }
     */
    public static int RLIMIT_CPU_USAGE_MONITOR() {
        return RLIMIT_CPU_USAGE_MONITOR;
    }
    private static final int RLIMIT_THREAD_CPULIMITS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_THREAD_CPULIMITS 3
     * }
     */
    public static int RLIMIT_THREAD_CPULIMITS() {
        return RLIMIT_THREAD_CPULIMITS;
    }
    private static final int RLIMIT_FOOTPRINT_INTERVAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_FOOTPRINT_INTERVAL 4
     * }
     */
    public static int RLIMIT_FOOTPRINT_INTERVAL() {
        return RLIMIT_FOOTPRINT_INTERVAL;
    }
    private static final int WAKEMON_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_ENABLE 1
     * }
     */
    public static int WAKEMON_ENABLE() {
        return WAKEMON_ENABLE;
    }
    private static final int WAKEMON_DISABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_DISABLE 2
     * }
     */
    public static int WAKEMON_DISABLE() {
        return WAKEMON_DISABLE;
    }
    private static final int WAKEMON_GET_PARAMS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_GET_PARAMS 4
     * }
     */
    public static int WAKEMON_GET_PARAMS() {
        return WAKEMON_GET_PARAMS;
    }
    private static final int WAKEMON_SET_DEFAULTS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_SET_DEFAULTS 8
     * }
     */
    public static int WAKEMON_SET_DEFAULTS() {
        return WAKEMON_SET_DEFAULTS;
    }
    private static final int WAKEMON_MAKE_FATAL = (int)16L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_MAKE_FATAL 16
     * }
     */
    public static int WAKEMON_MAKE_FATAL() {
        return WAKEMON_MAKE_FATAL;
    }
    private static final int CPUMON_MAKE_FATAL = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define CPUMON_MAKE_FATAL 4096
     * }
     */
    public static int CPUMON_MAKE_FATAL() {
        return CPUMON_MAKE_FATAL;
    }
    private static final int FOOTPRINT_INTERVAL_RESET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FOOTPRINT_INTERVAL_RESET 1
     * }
     */
    public static int FOOTPRINT_INTERVAL_RESET() {
        return FOOTPRINT_INTERVAL_RESET;
    }
    private static final int IOPOL_TYPE_DISK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_DISK 0
     * }
     */
    public static int IOPOL_TYPE_DISK() {
        return IOPOL_TYPE_DISK;
    }
    private static final int IOPOL_TYPE_VFS_ATIME_UPDATES = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_ATIME_UPDATES 2
     * }
     */
    public static int IOPOL_TYPE_VFS_ATIME_UPDATES() {
        return IOPOL_TYPE_VFS_ATIME_UPDATES;
    }
    private static final int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES 3
     * }
     */
    public static int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES() {
        return IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES;
    }
    private static final int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME 4
     * }
     */
    public static int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME() {
        return IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME;
    }
    private static final int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_TRIGGER_RESOLVE 5
     * }
     */
    public static int IOPOL_TYPE_VFS_TRIGGER_RESOLVE() {
        return IOPOL_TYPE_VFS_TRIGGER_RESOLVE;
    }
    private static final int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION 6
     * }
     */
    public static int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION() {
        return IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION;
    }
    private static final int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_IGNORE_PERMISSIONS 7
     * }
     */
    public static int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS() {
        return IOPOL_TYPE_VFS_IGNORE_PERMISSIONS;
    }
    private static final int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE 8
     * }
     */
    public static int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE() {
        return IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE;
    }
    private static final int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = (int)9L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES 9
     * }
     */
    public static int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES() {
        return IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES;
    }
    private static final int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = (int)10L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY 10
     * }
     */
    public static int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY() {
        return IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY;
    }
    private static final int IOPOL_SCOPE_PROCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_PROCESS 0
     * }
     */
    public static int IOPOL_SCOPE_PROCESS() {
        return IOPOL_SCOPE_PROCESS;
    }
    private static final int IOPOL_SCOPE_THREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_THREAD 1
     * }
     */
    public static int IOPOL_SCOPE_THREAD() {
        return IOPOL_SCOPE_THREAD;
    }
    private static final int IOPOL_SCOPE_DARWIN_BG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_DARWIN_BG 2
     * }
     */
    public static int IOPOL_SCOPE_DARWIN_BG() {
        return IOPOL_SCOPE_DARWIN_BG;
    }
    private static final int IOPOL_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_DEFAULT 0
     * }
     */
    public static int IOPOL_DEFAULT() {
        return IOPOL_DEFAULT;
    }
    private static final int IOPOL_IMPORTANT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_IMPORTANT 1
     * }
     */
    public static int IOPOL_IMPORTANT() {
        return IOPOL_IMPORTANT;
    }
    private static final int IOPOL_PASSIVE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_PASSIVE 2
     * }
     */
    public static int IOPOL_PASSIVE() {
        return IOPOL_PASSIVE;
    }
    private static final int IOPOL_THROTTLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_THROTTLE 3
     * }
     */
    public static int IOPOL_THROTTLE() {
        return IOPOL_THROTTLE;
    }
    private static final int IOPOL_UTILITY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_UTILITY 4
     * }
     */
    public static int IOPOL_UTILITY() {
        return IOPOL_UTILITY;
    }
    private static final int IOPOL_STANDARD = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_STANDARD 5
     * }
     */
    public static int IOPOL_STANDARD() {
        return IOPOL_STANDARD;
    }
    private static final int IOPOL_ATIME_UPDATES_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_ATIME_UPDATES_DEFAULT 0
     * }
     */
    public static int IOPOL_ATIME_UPDATES_DEFAULT() {
        return IOPOL_ATIME_UPDATES_DEFAULT;
    }
    private static final int IOPOL_ATIME_UPDATES_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_ATIME_UPDATES_OFF 1
     * }
     */
    public static int IOPOL_ATIME_UPDATES_OFF() {
        return IOPOL_ATIME_UPDATES_OFF;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT 0
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_OFF 1
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_OFF() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_OFF;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_ON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_ON 2
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_ON() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_ON;
    }
    private static final int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT() {
        return IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT;
    }
    private static final int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME 1
     * }
     */
    public static int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME() {
        return IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME;
    }
    private static final int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT() {
        return IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT;
    }
    private static final int IOPOL_VFS_TRIGGER_RESOLVE_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_TRIGGER_RESOLVE_OFF 1
     * }
     */
    public static int IOPOL_VFS_TRIGGER_RESOLVE_OFF() {
        return IOPOL_VFS_TRIGGER_RESOLVE_OFF;
    }
    private static final int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_CONTENT_PROTECTION_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT() {
        return IOPOL_VFS_CONTENT_PROTECTION_DEFAULT;
    }
    private static final int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_CONTENT_PROTECTION_IGNORE 1
     * }
     */
    public static int IOPOL_VFS_CONTENT_PROTECTION_IGNORE() {
        return IOPOL_VFS_CONTENT_PROTECTION_IGNORE;
    }
    private static final int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_IGNORE_PERMISSIONS_OFF 0
     * }
     */
    public static int IOPOL_VFS_IGNORE_PERMISSIONS_OFF() {
        return IOPOL_VFS_IGNORE_PERMISSIONS_OFF;
    }
    private static final int IOPOL_VFS_IGNORE_PERMISSIONS_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_IGNORE_PERMISSIONS_ON 1
     * }
     */
    public static int IOPOL_VFS_IGNORE_PERMISSIONS_ON() {
        return IOPOL_VFS_IGNORE_PERMISSIONS_ON;
    }
    private static final int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_SKIP_MTIME_UPDATE_OFF 0
     * }
     */
    public static int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF() {
        return IOPOL_VFS_SKIP_MTIME_UPDATE_OFF;
    }
    private static final int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_SKIP_MTIME_UPDATE_ON 1
     * }
     */
    public static int IOPOL_VFS_SKIP_MTIME_UPDATE_ON() {
        return IOPOL_VFS_SKIP_MTIME_UPDATE_ON;
    }
    private static final int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF 0
     * }
     */
    public static int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF() {
        return IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF;
    }
    private static final int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON 1
     * }
     */
    public static int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON() {
        return IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON;
    }
    private static final int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT() {
        return IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT;
    }
    private static final int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON 1
     * }
     */
    public static int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON() {
        return IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON;
    }
    private static final int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT() {
        return IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT;
    }
    private static final int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON 1
     * }
     */
    public static int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON() {
        return IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define WCOREFLAG 128
     * }
     */
    public static int WCOREFLAG() {
        return WCOREFLAG;
    }
    private static final int _WSTOPPED = (int)127L;
    /**
     * {@snippet lang=c :
     * #define _WSTOPPED 127
     * }
     */
    public static int _WSTOPPED() {
        return _WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WSTOPPED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 8
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WCONTINUED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 16
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 32
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int WAIT_MYPGRP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WAIT_MYPGRP 0
     * }
     */
    public static int WAIT_MYPGRP() {
        return WAIT_MYPGRP;
    }
    private static final int _QUAD_HIGHWORD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _QUAD_HIGHWORD 1
     * }
     */
    public static int _QUAD_HIGHWORD() {
        return _QUAD_HIGHWORD;
    }
    private static final int _QUAD_LOWWORD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _QUAD_LOWWORD 0
     * }
     */
    public static int _QUAD_LOWWORD() {
        return _QUAD_LOWWORD;
    }
    private static final int __DARWIN_LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_LITTLE_ENDIAN 1234
     * }
     */
    public static int __DARWIN_LITTLE_ENDIAN() {
        return __DARWIN_LITTLE_ENDIAN;
    }
    private static final int __DARWIN_BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BIG_ENDIAN 4321
     * }
     */
    public static int __DARWIN_BIG_ENDIAN() {
        return __DARWIN_BIG_ENDIAN;
    }
    private static final int __DARWIN_PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_PDP_ENDIAN 3412
     * }
     */
    public static int __DARWIN_PDP_ENDIAN() {
        return __DARWIN_PDP_ENDIAN;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int __DARWIN_FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_FD_SETSIZE 1024
     * }
     */
    public static int __DARWIN_FD_SETSIZE() {
        return __DARWIN_FD_SETSIZE;
    }
    private static final int __DARWIN_NBBY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NBBY 8
     * }
     */
    public static int __DARWIN_NBBY() {
        return __DARWIN_NBBY;
    }
    private static final int OBJC_API_VERSION = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OBJC_API_VERSION 0
     * }
     */
    public static int OBJC_API_VERSION() {
        return OBJC_API_VERSION;
    }
    private static final int OBJC_NO_GC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_NO_GC 1
     * }
     */
    public static int OBJC_NO_GC() {
        return OBJC_NO_GC;
    }
    private static final int OBJC_NO_GC_API = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_NO_GC_API 1
     * }
     */
    public static int OBJC_NO_GC_API() {
        return OBJC_NO_GC_API;
    }
    private static final int NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER 1
     * }
     */
    public static int NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER() {
        return NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER;
    }
    private static final int OBJC_OLD_DISPATCH_PROTOTYPES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OBJC_OLD_DISPATCH_PROTOTYPES 0
     * }
     */
    public static int OBJC_OLD_DISPATCH_PROTOTYPES() {
        return OBJC_OLD_DISPATCH_PROTOTYPES;
    }
    private static final int true_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define true 1
     * }
     */
    public static int true_() {
        return true_;
    }
    private static final int false_ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define false 0
     * }
     */
    public static int false_() {
        return false_;
    }
    private static final int __bool_true_false_are_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __bool_true_false_are_defined 1
     * }
     */
    public static int __bool_true_false_are_defined() {
        return __bool_true_false_are_defined;
    }
    private static final int OBJC_BOOL_IS_BOOL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_BOOL_IS_BOOL 1
     * }
     */
    public static int OBJC_BOOL_IS_BOOL() {
        return OBJC_BOOL_IS_BOOL;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int OBJC_GETCLASSHOOK_DEFINED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_GETCLASSHOOK_DEFINED 1
     * }
     */
    public static int OBJC_GETCLASSHOOK_DEFINED() {
        return OBJC_GETCLASSHOOK_DEFINED;
    }
    private static final int OBJC_ADDLOADIMAGEFUNC_DEFINED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_ADDLOADIMAGEFUNC_DEFINED 1
     * }
     */
    public static int OBJC_ADDLOADIMAGEFUNC_DEFINED() {
        return OBJC_ADDLOADIMAGEFUNC_DEFINED;
    }
    private static final int OBJC_SETHOOK_LAZYCLASSNAMER_DEFINED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_SETHOOK_LAZYCLASSNAMER_DEFINED 1
     * }
     */
    public static int OBJC_SETHOOK_LAZYCLASSNAMER_DEFINED() {
        return OBJC_SETHOOK_LAZYCLASSNAMER_DEFINED;
    }
    private static final int OBJC_REALIZECLASSFROMSWIFT_DEFINED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_REALIZECLASSFROMSWIFT_DEFINED 1
     * }
     */
    public static int OBJC_REALIZECLASSFROMSWIFT_DEFINED() {
        return OBJC_REALIZECLASSFROMSWIFT_DEFINED;
    }
    private static final int _USE_FORTIFY_LEVEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _USE_FORTIFY_LEVEL 2
     * }
     */
    public static int _USE_FORTIFY_LEVEL() {
        return _USE_FORTIFY_LEVEL;
    }
    private static final int __HAS_FIXED_CHK_PROTOTYPES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAS_FIXED_CHK_PROTOTYPES 1
     * }
     */
    public static int __HAS_FIXED_CHK_PROTOTYPES() {
        return __HAS_FIXED_CHK_PROTOTYPES;
    }
    private static final int OSATOMIC_DEPRECATED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OSATOMIC_DEPRECATED 1
     * }
     */
    public static int OSATOMIC_DEPRECATED() {
        return OSATOMIC_DEPRECATED;
    }
    private static final int OSSPINLOCK_DEPRECATED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OSSPINLOCK_DEPRECATED 1
     * }
     */
    public static int OSSPINLOCK_DEPRECATED() {
        return OSSPINLOCK_DEPRECATED;
    }
    private static final int OS_SPINLOCK_INIT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OS_SPINLOCK_INIT 0
     * }
     */
    public static int OS_SPINLOCK_INIT() {
        return OS_SPINLOCK_INIT;
    }
    private static final int TRUE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TRUE 1
     * }
     */
    public static int TRUE() {
        return TRUE;
    }
    private static final int FALSE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FALSE 0
     * }
     */
    public static int FALSE() {
        return FALSE;
    }
    private static final int MACH_PORT_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_NULL 0
     * }
     */
    public static int MACH_PORT_NULL() {
        return MACH_PORT_NULL;
    }
    private static final int MACH_PORT_TYPE_SPREQUEST = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SPREQUEST 1073741824
     * }
     */
    public static int MACH_PORT_TYPE_SPREQUEST() {
        return MACH_PORT_TYPE_SPREQUEST;
    }
    private static final int MACH_PORT_TYPE_SPREQUEST_DELAYED = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SPREQUEST_DELAYED 536870912
     * }
     */
    public static int MACH_PORT_TYPE_SPREQUEST_DELAYED() {
        return MACH_PORT_TYPE_SPREQUEST_DELAYED;
    }
    private static final int MACH_PORT_SRIGHTS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_SRIGHTS_NONE 0
     * }
     */
    public static int MACH_PORT_SRIGHTS_NONE() {
        return MACH_PORT_SRIGHTS_NONE;
    }
    private static final int MACH_PORT_SRIGHTS_PRESENT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_SRIGHTS_PRESENT 1
     * }
     */
    public static int MACH_PORT_SRIGHTS_PRESENT() {
        return MACH_PORT_SRIGHTS_PRESENT;
    }
    private static final int MACH_PORT_STATUS_FLAG_TEMPOWNER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_TEMPOWNER 1
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_TEMPOWNER() {
        return MACH_PORT_STATUS_FLAG_TEMPOWNER;
    }
    private static final int MACH_PORT_STATUS_FLAG_GUARDED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_GUARDED 2
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_GUARDED() {
        return MACH_PORT_STATUS_FLAG_GUARDED;
    }
    private static final int MACH_PORT_STATUS_FLAG_STRICT_GUARD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_STRICT_GUARD 4
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_STRICT_GUARD() {
        return MACH_PORT_STATUS_FLAG_STRICT_GUARD;
    }
    private static final int MACH_PORT_STATUS_FLAG_IMP_DONATION = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_IMP_DONATION 8
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_IMP_DONATION() {
        return MACH_PORT_STATUS_FLAG_IMP_DONATION;
    }
    private static final int MACH_PORT_STATUS_FLAG_REVIVE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_REVIVE 16
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_REVIVE() {
        return MACH_PORT_STATUS_FLAG_REVIVE;
    }
    private static final int MACH_PORT_STATUS_FLAG_TASKPTR = (int)32L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_TASKPTR 32
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_TASKPTR() {
        return MACH_PORT_STATUS_FLAG_TASKPTR;
    }
    private static final int MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE 64
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE() {
        return MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE;
    }
    private static final int MACH_PORT_STATUS_FLAG_NO_GRANT = (int)128L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_NO_GRANT 128
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_NO_GRANT() {
        return MACH_PORT_STATUS_FLAG_NO_GRANT;
    }
    private static final int MACH_PORT_LIMITS_INFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_LIMITS_INFO 1
     * }
     */
    public static int MACH_PORT_LIMITS_INFO() {
        return MACH_PORT_LIMITS_INFO;
    }
    private static final int MACH_PORT_RECEIVE_STATUS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RECEIVE_STATUS 2
     * }
     */
    public static int MACH_PORT_RECEIVE_STATUS() {
        return MACH_PORT_RECEIVE_STATUS;
    }
    private static final int MACH_PORT_DNREQUESTS_SIZE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_DNREQUESTS_SIZE 3
     * }
     */
    public static int MACH_PORT_DNREQUESTS_SIZE() {
        return MACH_PORT_DNREQUESTS_SIZE;
    }
    private static final int MACH_PORT_TEMPOWNER = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TEMPOWNER 4
     * }
     */
    public static int MACH_PORT_TEMPOWNER() {
        return MACH_PORT_TEMPOWNER;
    }
    private static final int MACH_PORT_IMPORTANCE_RECEIVER = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_IMPORTANCE_RECEIVER 5
     * }
     */
    public static int MACH_PORT_IMPORTANCE_RECEIVER() {
        return MACH_PORT_IMPORTANCE_RECEIVER;
    }
    private static final int MACH_PORT_DENAP_RECEIVER = (int)6L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_DENAP_RECEIVER 6
     * }
     */
    public static int MACH_PORT_DENAP_RECEIVER() {
        return MACH_PORT_DENAP_RECEIVER;
    }
    private static final int MACH_PORT_INFO_EXT = (int)7L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_INFO_EXT 7
     * }
     */
    public static int MACH_PORT_INFO_EXT() {
        return MACH_PORT_INFO_EXT;
    }
    private static final int MACH_PORT_GUARD_INFO = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_GUARD_INFO 8
     * }
     */
    public static int MACH_PORT_GUARD_INFO() {
        return MACH_PORT_GUARD_INFO;
    }
    private static final int MACH_PORT_SERVICE_THROTTLED = (int)9L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_SERVICE_THROTTLED 9
     * }
     */
    public static int MACH_PORT_SERVICE_THROTTLED() {
        return MACH_PORT_SERVICE_THROTTLED;
    }
    private static final int MACH_PORT_DNREQUESTS_SIZE_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_DNREQUESTS_SIZE_COUNT 1
     * }
     */
    public static int MACH_PORT_DNREQUESTS_SIZE_COUNT() {
        return MACH_PORT_DNREQUESTS_SIZE_COUNT;
    }
    private static final int MACH_PORT_SERVICE_THROTTLED_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_SERVICE_THROTTLED_COUNT 1
     * }
     */
    public static int MACH_PORT_SERVICE_THROTTLED_COUNT() {
        return MACH_PORT_SERVICE_THROTTLED_COUNT;
    }
    private static final int MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN 255
     * }
     */
    public static int MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN() {
        return MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN;
    }
    private static final int MPO_CONTEXT_AS_GUARD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MPO_CONTEXT_AS_GUARD 1
     * }
     */
    public static int MPO_CONTEXT_AS_GUARD() {
        return MPO_CONTEXT_AS_GUARD;
    }
    private static final int MPO_QLIMIT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MPO_QLIMIT 2
     * }
     */
    public static int MPO_QLIMIT() {
        return MPO_QLIMIT;
    }
    private static final int MPO_TEMPOWNER = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MPO_TEMPOWNER 4
     * }
     */
    public static int MPO_TEMPOWNER() {
        return MPO_TEMPOWNER;
    }
    private static final int MPO_IMPORTANCE_RECEIVER = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MPO_IMPORTANCE_RECEIVER 8
     * }
     */
    public static int MPO_IMPORTANCE_RECEIVER() {
        return MPO_IMPORTANCE_RECEIVER;
    }
    private static final int MPO_INSERT_SEND_RIGHT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MPO_INSERT_SEND_RIGHT 16
     * }
     */
    public static int MPO_INSERT_SEND_RIGHT() {
        return MPO_INSERT_SEND_RIGHT;
    }
    private static final int MPO_STRICT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define MPO_STRICT 32
     * }
     */
    public static int MPO_STRICT() {
        return MPO_STRICT;
    }
    private static final int MPO_DENAP_RECEIVER = (int)64L;
    /**
     * {@snippet lang=c :
     * #define MPO_DENAP_RECEIVER 64
     * }
     */
    public static int MPO_DENAP_RECEIVER() {
        return MPO_DENAP_RECEIVER;
    }
    private static final int MPO_IMMOVABLE_RECEIVE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define MPO_IMMOVABLE_RECEIVE 128
     * }
     */
    public static int MPO_IMMOVABLE_RECEIVE() {
        return MPO_IMMOVABLE_RECEIVE;
    }
    private static final int MPO_FILTER_MSG = (int)256L;
    /**
     * {@snippet lang=c :
     * #define MPO_FILTER_MSG 256
     * }
     */
    public static int MPO_FILTER_MSG() {
        return MPO_FILTER_MSG;
    }
    private static final int MPO_TG_BLOCK_TRACKING = (int)512L;
    /**
     * {@snippet lang=c :
     * #define MPO_TG_BLOCK_TRACKING 512
     * }
     */
    public static int MPO_TG_BLOCK_TRACKING() {
        return MPO_TG_BLOCK_TRACKING;
    }
    private static final int MPO_SERVICE_PORT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MPO_SERVICE_PORT 1024
     * }
     */
    public static int MPO_SERVICE_PORT() {
        return MPO_SERVICE_PORT;
    }
    private static final int MPO_CONNECTION_PORT = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define MPO_CONNECTION_PORT 2048
     * }
     */
    public static int MPO_CONNECTION_PORT() {
        return MPO_CONNECTION_PORT;
    }
    private static final int MPO_REPLY_PORT = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define MPO_REPLY_PORT 4096
     * }
     */
    public static int MPO_REPLY_PORT() {
        return MPO_REPLY_PORT;
    }
    private static final int MPO_ENFORCE_REPLY_PORT_SEMANTICS = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define MPO_ENFORCE_REPLY_PORT_SEMANTICS 8192
     * }
     */
    public static int MPO_ENFORCE_REPLY_PORT_SEMANTICS() {
        return MPO_ENFORCE_REPLY_PORT_SEMANTICS;
    }
    private static final int MPO_PROVISIONAL_REPLY_PORT = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define MPO_PROVISIONAL_REPLY_PORT 16384
     * }
     */
    public static int MPO_PROVISIONAL_REPLY_PORT() {
        return MPO_PROVISIONAL_REPLY_PORT;
    }
    private static final int MPO_EXCEPTION_PORT = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MPO_EXCEPTION_PORT 32768
     * }
     */
    public static int MPO_EXCEPTION_PORT() {
        return MPO_EXCEPTION_PORT;
    }
    private static final int GUARD_TYPE_MACH_PORT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GUARD_TYPE_MACH_PORT 1
     * }
     */
    public static int GUARD_TYPE_MACH_PORT() {
        return GUARD_TYPE_MACH_PORT;
    }
    private static final int MPG_STRICT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MPG_STRICT 1
     * }
     */
    public static int MPG_STRICT() {
        return MPG_STRICT;
    }
    private static final int MPG_IMMOVABLE_RECEIVE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MPG_IMMOVABLE_RECEIVE 2
     * }
     */
    public static int MPG_IMMOVABLE_RECEIVE() {
        return MPG_IMMOVABLE_RECEIVE;
    }
    private static final int __DARWIN_CLK_TCK = (int)100L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_CLK_TCK 100
     * }
     */
    public static int __DARWIN_CLK_TCK() {
        return __DARWIN_CLK_TCK;
    }
    private static final int MACH_MSGH_BITS_ZERO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_ZERO 0
     * }
     */
    public static int MACH_MSGH_BITS_ZERO() {
        return MACH_MSGH_BITS_ZERO;
    }
    private static final int MACH_MSGH_BITS_REMOTE_MASK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_REMOTE_MASK 31
     * }
     */
    public static int MACH_MSGH_BITS_REMOTE_MASK() {
        return MACH_MSGH_BITS_REMOTE_MASK;
    }
    private static final int MACH_MSGH_BITS_LOCAL_MASK = (int)7936L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_LOCAL_MASK 7936
     * }
     */
    public static int MACH_MSGH_BITS_LOCAL_MASK() {
        return MACH_MSGH_BITS_LOCAL_MASK;
    }
    private static final int MACH_MSGH_BITS_VOUCHER_MASK = (int)2031616L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_VOUCHER_MASK 2031616
     * }
     */
    public static int MACH_MSGH_BITS_VOUCHER_MASK() {
        return MACH_MSGH_BITS_VOUCHER_MASK;
    }
    private static final int MACH_MSG_TYPE_MOVE_RECEIVE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_MOVE_RECEIVE 16
     * }
     */
    public static int MACH_MSG_TYPE_MOVE_RECEIVE() {
        return MACH_MSG_TYPE_MOVE_RECEIVE;
    }
    private static final int MACH_MSG_TYPE_MOVE_SEND = (int)17L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_MOVE_SEND 17
     * }
     */
    public static int MACH_MSG_TYPE_MOVE_SEND() {
        return MACH_MSG_TYPE_MOVE_SEND;
    }
    private static final int MACH_MSG_TYPE_MOVE_SEND_ONCE = (int)18L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_MOVE_SEND_ONCE 18
     * }
     */
    public static int MACH_MSG_TYPE_MOVE_SEND_ONCE() {
        return MACH_MSG_TYPE_MOVE_SEND_ONCE;
    }
    private static final int MACH_MSG_TYPE_COPY_SEND = (int)19L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_COPY_SEND 19
     * }
     */
    public static int MACH_MSG_TYPE_COPY_SEND() {
        return MACH_MSG_TYPE_COPY_SEND;
    }
    private static final int MACH_MSG_TYPE_MAKE_SEND = (int)20L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_MAKE_SEND 20
     * }
     */
    public static int MACH_MSG_TYPE_MAKE_SEND() {
        return MACH_MSG_TYPE_MAKE_SEND;
    }
    private static final int MACH_MSG_TYPE_MAKE_SEND_ONCE = (int)21L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_MAKE_SEND_ONCE 21
     * }
     */
    public static int MACH_MSG_TYPE_MAKE_SEND_ONCE() {
        return MACH_MSG_TYPE_MAKE_SEND_ONCE;
    }
    private static final int MACH_MSG_TYPE_COPY_RECEIVE = (int)22L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_COPY_RECEIVE 22
     * }
     */
    public static int MACH_MSG_TYPE_COPY_RECEIVE() {
        return MACH_MSG_TYPE_COPY_RECEIVE;
    }
    private static final int MACH_MSG_TYPE_DISPOSE_RECEIVE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_DISPOSE_RECEIVE 24
     * }
     */
    public static int MACH_MSG_TYPE_DISPOSE_RECEIVE() {
        return MACH_MSG_TYPE_DISPOSE_RECEIVE;
    }
    private static final int MACH_MSG_TYPE_DISPOSE_SEND = (int)25L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_DISPOSE_SEND 25
     * }
     */
    public static int MACH_MSG_TYPE_DISPOSE_SEND() {
        return MACH_MSG_TYPE_DISPOSE_SEND;
    }
    private static final int MACH_MSG_TYPE_DISPOSE_SEND_ONCE = (int)26L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_DISPOSE_SEND_ONCE 26
     * }
     */
    public static int MACH_MSG_TYPE_DISPOSE_SEND_ONCE() {
        return MACH_MSG_TYPE_DISPOSE_SEND_ONCE;
    }
    private static final int MACH_MSG_PHYSICAL_COPY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_PHYSICAL_COPY 0
     * }
     */
    public static int MACH_MSG_PHYSICAL_COPY() {
        return MACH_MSG_PHYSICAL_COPY;
    }
    private static final int MACH_MSG_VIRTUAL_COPY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_VIRTUAL_COPY 1
     * }
     */
    public static int MACH_MSG_VIRTUAL_COPY() {
        return MACH_MSG_VIRTUAL_COPY;
    }
    private static final int MACH_MSG_ALLOCATE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_ALLOCATE 2
     * }
     */
    public static int MACH_MSG_ALLOCATE() {
        return MACH_MSG_ALLOCATE;
    }
    private static final int MACH_MSG_OVERWRITE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_OVERWRITE 3
     * }
     */
    public static int MACH_MSG_OVERWRITE() {
        return MACH_MSG_OVERWRITE;
    }
    private static final int MACH_MSG_GUARD_FLAGS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_GUARD_FLAGS_NONE 0
     * }
     */
    public static int MACH_MSG_GUARD_FLAGS_NONE() {
        return MACH_MSG_GUARD_FLAGS_NONE;
    }
    private static final int MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE 1
     * }
     */
    public static int MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE() {
        return MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE;
    }
    private static final int MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND 2
     * }
     */
    public static int MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND() {
        return MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND;
    }
    private static final int MACH_MSG_GUARD_FLAGS_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_GUARD_FLAGS_MASK 3
     * }
     */
    public static int MACH_MSG_GUARD_FLAGS_MASK() {
        return MACH_MSG_GUARD_FLAGS_MASK;
    }
    private static final int MACH_MSG_PORT_DESCRIPTOR = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_PORT_DESCRIPTOR 0
     * }
     */
    public static int MACH_MSG_PORT_DESCRIPTOR() {
        return MACH_MSG_PORT_DESCRIPTOR;
    }
    private static final int MACH_MSG_OOL_DESCRIPTOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_OOL_DESCRIPTOR 1
     * }
     */
    public static int MACH_MSG_OOL_DESCRIPTOR() {
        return MACH_MSG_OOL_DESCRIPTOR;
    }
    private static final int MACH_MSG_OOL_PORTS_DESCRIPTOR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_OOL_PORTS_DESCRIPTOR 2
     * }
     */
    public static int MACH_MSG_OOL_PORTS_DESCRIPTOR() {
        return MACH_MSG_OOL_PORTS_DESCRIPTOR;
    }
    private static final int MACH_MSG_OOL_VOLATILE_DESCRIPTOR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_OOL_VOLATILE_DESCRIPTOR 3
     * }
     */
    public static int MACH_MSG_OOL_VOLATILE_DESCRIPTOR() {
        return MACH_MSG_OOL_VOLATILE_DESCRIPTOR;
    }
    private static final int MACH_MSG_GUARDED_PORT_DESCRIPTOR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_GUARDED_PORT_DESCRIPTOR 4
     * }
     */
    public static int MACH_MSG_GUARDED_PORT_DESCRIPTOR() {
        return MACH_MSG_GUARDED_PORT_DESCRIPTOR;
    }
    private static final int MACH_MSG_TRAILER_FORMAT_0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TRAILER_FORMAT_0 0
     * }
     */
    public static int MACH_MSG_TRAILER_FORMAT_0() {
        return MACH_MSG_TRAILER_FORMAT_0;
    }
    private static final int MACH_MSGH_KIND_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_KIND_NORMAL 0
     * }
     */
    public static int MACH_MSGH_KIND_NORMAL() {
        return MACH_MSGH_KIND_NORMAL;
    }
    private static final int MACH_MSGH_KIND_NOTIFICATION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_KIND_NOTIFICATION 1
     * }
     */
    public static int MACH_MSGH_KIND_NOTIFICATION() {
        return MACH_MSGH_KIND_NOTIFICATION;
    }
    private static final int MACH_MSG_TYPE_PORT_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_PORT_NONE 0
     * }
     */
    public static int MACH_MSG_TYPE_PORT_NONE() {
        return MACH_MSG_TYPE_PORT_NONE;
    }
    private static final int MACH_MSG_TYPE_PORT_NAME = (int)15L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_PORT_NAME 15
     * }
     */
    public static int MACH_MSG_TYPE_PORT_NAME() {
        return MACH_MSG_TYPE_PORT_NAME;
    }
    private static final int MACH_MSG_TYPE_LAST = (int)22L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_LAST 22
     * }
     */
    public static int MACH_MSG_TYPE_LAST() {
        return MACH_MSG_TYPE_LAST;
    }
    private static final int MACH_MSG_OPTION_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_OPTION_NONE 0
     * }
     */
    public static int MACH_MSG_OPTION_NONE() {
        return MACH_MSG_OPTION_NONE;
    }
    private static final int MACH_SEND_MSG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_MSG 1
     * }
     */
    public static int MACH_SEND_MSG() {
        return MACH_SEND_MSG;
    }
    private static final int MACH_RCV_MSG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_MSG 2
     * }
     */
    public static int MACH_RCV_MSG() {
        return MACH_RCV_MSG;
    }
    private static final int MACH_RCV_LARGE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_LARGE 4
     * }
     */
    public static int MACH_RCV_LARGE() {
        return MACH_RCV_LARGE;
    }
    private static final int MACH_RCV_LARGE_IDENTITY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_LARGE_IDENTITY 8
     * }
     */
    public static int MACH_RCV_LARGE_IDENTITY() {
        return MACH_RCV_LARGE_IDENTITY;
    }
    private static final int MACH_SEND_TIMEOUT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_TIMEOUT 16
     * }
     */
    public static int MACH_SEND_TIMEOUT() {
        return MACH_SEND_TIMEOUT;
    }
    private static final int MACH_SEND_OVERRIDE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_OVERRIDE 32
     * }
     */
    public static int MACH_SEND_OVERRIDE() {
        return MACH_SEND_OVERRIDE;
    }
    private static final int MACH_SEND_INTERRUPT = (int)64L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INTERRUPT 64
     * }
     */
    public static int MACH_SEND_INTERRUPT() {
        return MACH_SEND_INTERRUPT;
    }
    private static final int MACH_SEND_NOTIFY = (int)128L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_NOTIFY 128
     * }
     */
    public static int MACH_SEND_NOTIFY() {
        return MACH_SEND_NOTIFY;
    }
    private static final int MACH_SEND_ALWAYS = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_ALWAYS 65536
     * }
     */
    public static int MACH_SEND_ALWAYS() {
        return MACH_SEND_ALWAYS;
    }
    private static final int MACH_SEND_FILTER_NONFATAL = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_FILTER_NONFATAL 65536
     * }
     */
    public static int MACH_SEND_FILTER_NONFATAL() {
        return MACH_SEND_FILTER_NONFATAL;
    }
    private static final int MACH_SEND_TRAILER = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_TRAILER 131072
     * }
     */
    public static int MACH_SEND_TRAILER() {
        return MACH_SEND_TRAILER;
    }
    private static final int MACH_SEND_NOIMPORTANCE = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_NOIMPORTANCE 262144
     * }
     */
    public static int MACH_SEND_NOIMPORTANCE() {
        return MACH_SEND_NOIMPORTANCE;
    }
    private static final int MACH_SEND_IMPORTANCE = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_IMPORTANCE 524288
     * }
     */
    public static int MACH_SEND_IMPORTANCE() {
        return MACH_SEND_IMPORTANCE;
    }
    private static final int MACH_SEND_SYNC_OVERRIDE = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_SYNC_OVERRIDE 1048576
     * }
     */
    public static int MACH_SEND_SYNC_OVERRIDE() {
        return MACH_SEND_SYNC_OVERRIDE;
    }
    private static final int MACH_SEND_PROPAGATE_QOS = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_PROPAGATE_QOS 2097152
     * }
     */
    public static int MACH_SEND_PROPAGATE_QOS() {
        return MACH_SEND_PROPAGATE_QOS;
    }
    private static final int MACH_SEND_KERNEL = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_KERNEL 4194304
     * }
     */
    public static int MACH_SEND_KERNEL() {
        return MACH_SEND_KERNEL;
    }
    private static final int MACH_SEND_SYNC_BOOTSTRAP_CHECKIN = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_SYNC_BOOTSTRAP_CHECKIN 8388608
     * }
     */
    public static int MACH_SEND_SYNC_BOOTSTRAP_CHECKIN() {
        return MACH_SEND_SYNC_BOOTSTRAP_CHECKIN;
    }
    private static final int MACH_RCV_TIMEOUT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TIMEOUT 256
     * }
     */
    public static int MACH_RCV_TIMEOUT() {
        return MACH_RCV_TIMEOUT;
    }
    private static final int MACH_RCV_NOTIFY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_NOTIFY 0
     * }
     */
    public static int MACH_RCV_NOTIFY() {
        return MACH_RCV_NOTIFY;
    }
    private static final int MACH_RCV_INTERRUPT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INTERRUPT 1024
     * }
     */
    public static int MACH_RCV_INTERRUPT() {
        return MACH_RCV_INTERRUPT;
    }
    private static final int MACH_RCV_VOUCHER = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_VOUCHER 2048
     * }
     */
    public static int MACH_RCV_VOUCHER() {
        return MACH_RCV_VOUCHER;
    }
    private static final int MACH_RCV_OVERWRITE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_OVERWRITE 0
     * }
     */
    public static int MACH_RCV_OVERWRITE() {
        return MACH_RCV_OVERWRITE;
    }
    private static final int MACH_RCV_GUARDED_DESC = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_GUARDED_DESC 4096
     * }
     */
    public static int MACH_RCV_GUARDED_DESC() {
        return MACH_RCV_GUARDED_DESC;
    }
    private static final int MACH_RCV_SYNC_WAIT = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_SYNC_WAIT 16384
     * }
     */
    public static int MACH_RCV_SYNC_WAIT() {
        return MACH_RCV_SYNC_WAIT;
    }
    private static final int MACH_RCV_SYNC_PEEK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_SYNC_PEEK 32768
     * }
     */
    public static int MACH_RCV_SYNC_PEEK() {
        return MACH_RCV_SYNC_PEEK;
    }
    private static final int MACH_MSG_STRICT_REPLY = (int)512L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_STRICT_REPLY 512
     * }
     */
    public static int MACH_MSG_STRICT_REPLY() {
        return MACH_MSG_STRICT_REPLY;
    }
    private static final int MACH_RCV_TRAILER_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_NULL 0
     * }
     */
    public static int MACH_RCV_TRAILER_NULL() {
        return MACH_RCV_TRAILER_NULL;
    }
    private static final int MACH_RCV_TRAILER_SEQNO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_SEQNO 1
     * }
     */
    public static int MACH_RCV_TRAILER_SEQNO() {
        return MACH_RCV_TRAILER_SEQNO;
    }
    private static final int MACH_RCV_TRAILER_SENDER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_SENDER 2
     * }
     */
    public static int MACH_RCV_TRAILER_SENDER() {
        return MACH_RCV_TRAILER_SENDER;
    }
    private static final int MACH_RCV_TRAILER_AUDIT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_AUDIT 3
     * }
     */
    public static int MACH_RCV_TRAILER_AUDIT() {
        return MACH_RCV_TRAILER_AUDIT;
    }
    private static final int MACH_RCV_TRAILER_CTX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_CTX 4
     * }
     */
    public static int MACH_RCV_TRAILER_CTX() {
        return MACH_RCV_TRAILER_CTX;
    }
    private static final int MACH_RCV_TRAILER_AV = (int)7L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_AV 7
     * }
     */
    public static int MACH_RCV_TRAILER_AV() {
        return MACH_RCV_TRAILER_AV;
    }
    private static final int MACH_RCV_TRAILER_LABELS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_LABELS 8
     * }
     */
    public static int MACH_RCV_TRAILER_LABELS() {
        return MACH_RCV_TRAILER_LABELS;
    }
    private static final int MACH_MSG_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_SUCCESS 0
     * }
     */
    public static int MACH_MSG_SUCCESS() {
        return MACH_MSG_SUCCESS;
    }
    private static final int MACH_MSG_MASK = (int)15872L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_MASK 15872
     * }
     */
    public static int MACH_MSG_MASK() {
        return MACH_MSG_MASK;
    }
    private static final int MACH_MSG_IPC_SPACE = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_IPC_SPACE 8192
     * }
     */
    public static int MACH_MSG_IPC_SPACE() {
        return MACH_MSG_IPC_SPACE;
    }
    private static final int MACH_MSG_VM_SPACE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_VM_SPACE 4096
     * }
     */
    public static int MACH_MSG_VM_SPACE() {
        return MACH_MSG_VM_SPACE;
    }
    private static final int MACH_MSG_IPC_KERNEL = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_IPC_KERNEL 2048
     * }
     */
    public static int MACH_MSG_IPC_KERNEL() {
        return MACH_MSG_IPC_KERNEL;
    }
    private static final int MACH_MSG_VM_KERNEL = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_VM_KERNEL 1024
     * }
     */
    public static int MACH_MSG_VM_KERNEL() {
        return MACH_MSG_VM_KERNEL;
    }
    private static final int MACH_SEND_IN_PROGRESS = (int)268435457L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_IN_PROGRESS 268435457
     * }
     */
    public static int MACH_SEND_IN_PROGRESS() {
        return MACH_SEND_IN_PROGRESS;
    }
    private static final int MACH_SEND_INVALID_DATA = (int)268435458L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_DATA 268435458
     * }
     */
    public static int MACH_SEND_INVALID_DATA() {
        return MACH_SEND_INVALID_DATA;
    }
    private static final int MACH_SEND_INVALID_DEST = (int)268435459L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_DEST 268435459
     * }
     */
    public static int MACH_SEND_INVALID_DEST() {
        return MACH_SEND_INVALID_DEST;
    }
    private static final int MACH_SEND_TIMED_OUT = (int)268435460L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_TIMED_OUT 268435460
     * }
     */
    public static int MACH_SEND_TIMED_OUT() {
        return MACH_SEND_TIMED_OUT;
    }
    private static final int MACH_SEND_INVALID_VOUCHER = (int)268435461L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_VOUCHER 268435461
     * }
     */
    public static int MACH_SEND_INVALID_VOUCHER() {
        return MACH_SEND_INVALID_VOUCHER;
    }
    private static final int MACH_SEND_INTERRUPTED = (int)268435463L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INTERRUPTED 268435463
     * }
     */
    public static int MACH_SEND_INTERRUPTED() {
        return MACH_SEND_INTERRUPTED;
    }
    private static final int MACH_SEND_MSG_TOO_SMALL = (int)268435464L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_MSG_TOO_SMALL 268435464
     * }
     */
    public static int MACH_SEND_MSG_TOO_SMALL() {
        return MACH_SEND_MSG_TOO_SMALL;
    }
    private static final int MACH_SEND_INVALID_REPLY = (int)268435465L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_REPLY 268435465
     * }
     */
    public static int MACH_SEND_INVALID_REPLY() {
        return MACH_SEND_INVALID_REPLY;
    }
    private static final int MACH_SEND_INVALID_RIGHT = (int)268435466L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_RIGHT 268435466
     * }
     */
    public static int MACH_SEND_INVALID_RIGHT() {
        return MACH_SEND_INVALID_RIGHT;
    }
    private static final int MACH_SEND_INVALID_NOTIFY = (int)268435467L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_NOTIFY 268435467
     * }
     */
    public static int MACH_SEND_INVALID_NOTIFY() {
        return MACH_SEND_INVALID_NOTIFY;
    }
    private static final int MACH_SEND_INVALID_MEMORY = (int)268435468L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_MEMORY 268435468
     * }
     */
    public static int MACH_SEND_INVALID_MEMORY() {
        return MACH_SEND_INVALID_MEMORY;
    }
    private static final int MACH_SEND_NO_BUFFER = (int)268435469L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_NO_BUFFER 268435469
     * }
     */
    public static int MACH_SEND_NO_BUFFER() {
        return MACH_SEND_NO_BUFFER;
    }
    private static final int MACH_SEND_TOO_LARGE = (int)268435470L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_TOO_LARGE 268435470
     * }
     */
    public static int MACH_SEND_TOO_LARGE() {
        return MACH_SEND_TOO_LARGE;
    }
    private static final int MACH_SEND_INVALID_TYPE = (int)268435471L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_TYPE 268435471
     * }
     */
    public static int MACH_SEND_INVALID_TYPE() {
        return MACH_SEND_INVALID_TYPE;
    }
    private static final int MACH_SEND_INVALID_HEADER = (int)268435472L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_HEADER 268435472
     * }
     */
    public static int MACH_SEND_INVALID_HEADER() {
        return MACH_SEND_INVALID_HEADER;
    }
    private static final int MACH_SEND_INVALID_TRAILER = (int)268435473L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_TRAILER 268435473
     * }
     */
    public static int MACH_SEND_INVALID_TRAILER() {
        return MACH_SEND_INVALID_TRAILER;
    }
    private static final int MACH_SEND_INVALID_CONTEXT = (int)268435474L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_CONTEXT 268435474
     * }
     */
    public static int MACH_SEND_INVALID_CONTEXT() {
        return MACH_SEND_INVALID_CONTEXT;
    }
    private static final int MACH_SEND_INVALID_OPTIONS = (int)268435475L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_OPTIONS 268435475
     * }
     */
    public static int MACH_SEND_INVALID_OPTIONS() {
        return MACH_SEND_INVALID_OPTIONS;
    }
    private static final int MACH_SEND_INVALID_RT_OOL_SIZE = (int)268435477L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_RT_OOL_SIZE 268435477
     * }
     */
    public static int MACH_SEND_INVALID_RT_OOL_SIZE() {
        return MACH_SEND_INVALID_RT_OOL_SIZE;
    }
    private static final int MACH_SEND_NO_GRANT_DEST = (int)268435478L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_NO_GRANT_DEST 268435478
     * }
     */
    public static int MACH_SEND_NO_GRANT_DEST() {
        return MACH_SEND_NO_GRANT_DEST;
    }
    private static final int MACH_SEND_MSG_FILTERED = (int)268435479L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_MSG_FILTERED 268435479
     * }
     */
    public static int MACH_SEND_MSG_FILTERED() {
        return MACH_SEND_MSG_FILTERED;
    }
    private static final int MACH_SEND_AUX_TOO_SMALL = (int)268435480L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_AUX_TOO_SMALL 268435480
     * }
     */
    public static int MACH_SEND_AUX_TOO_SMALL() {
        return MACH_SEND_AUX_TOO_SMALL;
    }
    private static final int MACH_SEND_AUX_TOO_LARGE = (int)268435481L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_AUX_TOO_LARGE 268435481
     * }
     */
    public static int MACH_SEND_AUX_TOO_LARGE() {
        return MACH_SEND_AUX_TOO_LARGE;
    }
    private static final int MACH_RCV_IN_PROGRESS = (int)268451841L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_IN_PROGRESS 268451841
     * }
     */
    public static int MACH_RCV_IN_PROGRESS() {
        return MACH_RCV_IN_PROGRESS;
    }
    private static final int MACH_RCV_INVALID_NAME = (int)268451842L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_NAME 268451842
     * }
     */
    public static int MACH_RCV_INVALID_NAME() {
        return MACH_RCV_INVALID_NAME;
    }
    private static final int MACH_RCV_TIMED_OUT = (int)268451843L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TIMED_OUT 268451843
     * }
     */
    public static int MACH_RCV_TIMED_OUT() {
        return MACH_RCV_TIMED_OUT;
    }
    private static final int MACH_RCV_TOO_LARGE = (int)268451844L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TOO_LARGE 268451844
     * }
     */
    public static int MACH_RCV_TOO_LARGE() {
        return MACH_RCV_TOO_LARGE;
    }
    private static final int MACH_RCV_INTERRUPTED = (int)268451845L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INTERRUPTED 268451845
     * }
     */
    public static int MACH_RCV_INTERRUPTED() {
        return MACH_RCV_INTERRUPTED;
    }
    private static final int MACH_RCV_PORT_CHANGED = (int)268451846L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_PORT_CHANGED 268451846
     * }
     */
    public static int MACH_RCV_PORT_CHANGED() {
        return MACH_RCV_PORT_CHANGED;
    }
    private static final int MACH_RCV_INVALID_NOTIFY = (int)268451847L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_NOTIFY 268451847
     * }
     */
    public static int MACH_RCV_INVALID_NOTIFY() {
        return MACH_RCV_INVALID_NOTIFY;
    }
    private static final int MACH_RCV_INVALID_DATA = (int)268451848L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_DATA 268451848
     * }
     */
    public static int MACH_RCV_INVALID_DATA() {
        return MACH_RCV_INVALID_DATA;
    }
    private static final int MACH_RCV_PORT_DIED = (int)268451849L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_PORT_DIED 268451849
     * }
     */
    public static int MACH_RCV_PORT_DIED() {
        return MACH_RCV_PORT_DIED;
    }
    private static final int MACH_RCV_IN_SET = (int)268451850L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_IN_SET 268451850
     * }
     */
    public static int MACH_RCV_IN_SET() {
        return MACH_RCV_IN_SET;
    }
    private static final int MACH_RCV_HEADER_ERROR = (int)268451851L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_HEADER_ERROR 268451851
     * }
     */
    public static int MACH_RCV_HEADER_ERROR() {
        return MACH_RCV_HEADER_ERROR;
    }
    private static final int MACH_RCV_BODY_ERROR = (int)268451852L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_BODY_ERROR 268451852
     * }
     */
    public static int MACH_RCV_BODY_ERROR() {
        return MACH_RCV_BODY_ERROR;
    }
    private static final int MACH_RCV_INVALID_TYPE = (int)268451853L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_TYPE 268451853
     * }
     */
    public static int MACH_RCV_INVALID_TYPE() {
        return MACH_RCV_INVALID_TYPE;
    }
    private static final int MACH_RCV_SCATTER_SMALL = (int)268451854L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_SCATTER_SMALL 268451854
     * }
     */
    public static int MACH_RCV_SCATTER_SMALL() {
        return MACH_RCV_SCATTER_SMALL;
    }
    private static final int MACH_RCV_INVALID_TRAILER = (int)268451855L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_TRAILER 268451855
     * }
     */
    public static int MACH_RCV_INVALID_TRAILER() {
        return MACH_RCV_INVALID_TRAILER;
    }
    private static final int MACH_RCV_IN_PROGRESS_TIMED = (int)268451857L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_IN_PROGRESS_TIMED 268451857
     * }
     */
    public static int MACH_RCV_IN_PROGRESS_TIMED() {
        return MACH_RCV_IN_PROGRESS_TIMED;
    }
    private static final int MACH_RCV_INVALID_REPLY = (int)268451858L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_REPLY 268451858
     * }
     */
    public static int MACH_RCV_INVALID_REPLY() {
        return MACH_RCV_INVALID_REPLY;
    }
    private static final int MACH_RCV_INVALID_ARGUMENTS = (int)268451859L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_ARGUMENTS 268451859
     * }
     */
    public static int MACH_RCV_INVALID_ARGUMENTS() {
        return MACH_RCV_INVALID_ARGUMENTS;
    }
    private static final int VM_PAGE_QUERY_PAGE_PRESENT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_PRESENT 1
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_PRESENT() {
        return VM_PAGE_QUERY_PAGE_PRESENT;
    }
    private static final int VM_PAGE_QUERY_PAGE_FICTITIOUS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_FICTITIOUS 2
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_FICTITIOUS() {
        return VM_PAGE_QUERY_PAGE_FICTITIOUS;
    }
    private static final int VM_PAGE_QUERY_PAGE_REF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_REF 4
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_REF() {
        return VM_PAGE_QUERY_PAGE_REF;
    }
    private static final int VM_PAGE_QUERY_PAGE_DIRTY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_DIRTY 8
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_DIRTY() {
        return VM_PAGE_QUERY_PAGE_DIRTY;
    }
    private static final int VM_PAGE_QUERY_PAGE_PAGED_OUT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_PAGED_OUT 16
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_PAGED_OUT() {
        return VM_PAGE_QUERY_PAGE_PAGED_OUT;
    }
    private static final int VM_PAGE_QUERY_PAGE_COPIED = (int)32L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_COPIED 32
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_COPIED() {
        return VM_PAGE_QUERY_PAGE_COPIED;
    }
    private static final int VM_PAGE_QUERY_PAGE_SPECULATIVE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_SPECULATIVE 64
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_SPECULATIVE() {
        return VM_PAGE_QUERY_PAGE_SPECULATIVE;
    }
    private static final int VM_PAGE_QUERY_PAGE_EXTERNAL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_EXTERNAL 128
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_EXTERNAL() {
        return VM_PAGE_QUERY_PAGE_EXTERNAL;
    }
    private static final int VM_PAGE_QUERY_PAGE_CS_VALIDATED = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_CS_VALIDATED 256
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_CS_VALIDATED() {
        return VM_PAGE_QUERY_PAGE_CS_VALIDATED;
    }
    private static final int VM_PAGE_QUERY_PAGE_CS_TAINTED = (int)512L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_CS_TAINTED 512
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_CS_TAINTED() {
        return VM_PAGE_QUERY_PAGE_CS_TAINTED;
    }
    private static final int VM_PAGE_QUERY_PAGE_CS_NX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_CS_NX 1024
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_CS_NX() {
        return VM_PAGE_QUERY_PAGE_CS_NX;
    }
    private static final int VM_PAGE_QUERY_PAGE_REUSABLE = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_QUERY_PAGE_REUSABLE 2048
     * }
     */
    public static int VM_PAGE_QUERY_PAGE_REUSABLE() {
        return VM_PAGE_QUERY_PAGE_REUSABLE;
    }
    private static final int VM_FLAGS_FIXED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_FIXED 0
     * }
     */
    public static int VM_FLAGS_FIXED() {
        return VM_FLAGS_FIXED;
    }
    private static final int VM_FLAGS_ANYWHERE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_ANYWHERE 1
     * }
     */
    public static int VM_FLAGS_ANYWHERE() {
        return VM_FLAGS_ANYWHERE;
    }
    private static final int VM_FLAGS_PURGABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_PURGABLE 2
     * }
     */
    public static int VM_FLAGS_PURGABLE() {
        return VM_FLAGS_PURGABLE;
    }
    private static final int VM_FLAGS_4GB_CHUNK = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_4GB_CHUNK 4
     * }
     */
    public static int VM_FLAGS_4GB_CHUNK() {
        return VM_FLAGS_4GB_CHUNK;
    }
    private static final int VM_FLAGS_RANDOM_ADDR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_RANDOM_ADDR 8
     * }
     */
    public static int VM_FLAGS_RANDOM_ADDR() {
        return VM_FLAGS_RANDOM_ADDR;
    }
    private static final int VM_FLAGS_NO_CACHE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_NO_CACHE 16
     * }
     */
    public static int VM_FLAGS_NO_CACHE() {
        return VM_FLAGS_NO_CACHE;
    }
    private static final int VM_FLAGS_RESILIENT_CODESIGN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_RESILIENT_CODESIGN 32
     * }
     */
    public static int VM_FLAGS_RESILIENT_CODESIGN() {
        return VM_FLAGS_RESILIENT_CODESIGN;
    }
    private static final int VM_FLAGS_RESILIENT_MEDIA = (int)64L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_RESILIENT_MEDIA 64
     * }
     */
    public static int VM_FLAGS_RESILIENT_MEDIA() {
        return VM_FLAGS_RESILIENT_MEDIA;
    }
    private static final int VM_FLAGS_PERMANENT = (int)128L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_PERMANENT 128
     * }
     */
    public static int VM_FLAGS_PERMANENT() {
        return VM_FLAGS_PERMANENT;
    }
    private static final int VM_FLAGS_TPRO = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_TPRO 4096
     * }
     */
    public static int VM_FLAGS_TPRO() {
        return VM_FLAGS_TPRO;
    }
    private static final int VM_FLAGS_OVERWRITE = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_OVERWRITE 16384
     * }
     */
    public static int VM_FLAGS_OVERWRITE() {
        return VM_FLAGS_OVERWRITE;
    }
    private static final int VM_FLAGS_SUPERPAGE_MASK = (int)458752L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_SUPERPAGE_MASK 458752
     * }
     */
    public static int VM_FLAGS_SUPERPAGE_MASK() {
        return VM_FLAGS_SUPERPAGE_MASK;
    }
    private static final int VM_FLAGS_RETURN_DATA_ADDR = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_RETURN_DATA_ADDR 1048576
     * }
     */
    public static int VM_FLAGS_RETURN_DATA_ADDR() {
        return VM_FLAGS_RETURN_DATA_ADDR;
    }
    private static final int VM_FLAGS_RETURN_4K_DATA_ADDR = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_RETURN_4K_DATA_ADDR 8388608
     * }
     */
    public static int VM_FLAGS_RETURN_4K_DATA_ADDR() {
        return VM_FLAGS_RETURN_4K_DATA_ADDR;
    }
    private static final int VM_FLAGS_SUPERPAGE_SHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_SUPERPAGE_SHIFT 16
     * }
     */
    public static int VM_FLAGS_SUPERPAGE_SHIFT() {
        return VM_FLAGS_SUPERPAGE_SHIFT;
    }
    private static final int SUPERPAGE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SUPERPAGE_NONE 0
     * }
     */
    public static int SUPERPAGE_NONE() {
        return SUPERPAGE_NONE;
    }
    private static final int SUPERPAGE_SIZE_ANY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SUPERPAGE_SIZE_ANY 1
     * }
     */
    public static int SUPERPAGE_SIZE_ANY() {
        return SUPERPAGE_SIZE_ANY;
    }
    private static final int SUPERPAGE_SIZE_2MB = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SUPERPAGE_SIZE_2MB 2
     * }
     */
    public static int SUPERPAGE_SIZE_2MB() {
        return SUPERPAGE_SIZE_2MB;
    }
    private static final int GUARD_TYPE_VIRT_MEMORY = (int)5L;
    /**
     * {@snippet lang=c :
     * #define GUARD_TYPE_VIRT_MEMORY 5
     * }
     */
    public static int GUARD_TYPE_VIRT_MEMORY() {
        return GUARD_TYPE_VIRT_MEMORY;
    }
    private static final int __VM_LEDGER_ACCOUNTING_POSTMARK = (int)2019032600L;
    /**
     * {@snippet lang=c :
     * #define __VM_LEDGER_ACCOUNTING_POSTMARK 2019032600
     * }
     */
    public static int __VM_LEDGER_ACCOUNTING_POSTMARK() {
        return __VM_LEDGER_ACCOUNTING_POSTMARK;
    }
    private static final int VM_LEDGER_TAG_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_TAG_NONE 0
     * }
     */
    public static int VM_LEDGER_TAG_NONE() {
        return VM_LEDGER_TAG_NONE;
    }
    private static final int VM_LEDGER_TAG_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_TAG_DEFAULT 1
     * }
     */
    public static int VM_LEDGER_TAG_DEFAULT() {
        return VM_LEDGER_TAG_DEFAULT;
    }
    private static final int VM_LEDGER_TAG_NETWORK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_TAG_NETWORK 2
     * }
     */
    public static int VM_LEDGER_TAG_NETWORK() {
        return VM_LEDGER_TAG_NETWORK;
    }
    private static final int VM_LEDGER_TAG_MEDIA = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_TAG_MEDIA 3
     * }
     */
    public static int VM_LEDGER_TAG_MEDIA() {
        return VM_LEDGER_TAG_MEDIA;
    }
    private static final int VM_LEDGER_TAG_GRAPHICS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_TAG_GRAPHICS 4
     * }
     */
    public static int VM_LEDGER_TAG_GRAPHICS() {
        return VM_LEDGER_TAG_GRAPHICS;
    }
    private static final int VM_LEDGER_TAG_NEURAL = (int)5L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_TAG_NEURAL 5
     * }
     */
    public static int VM_LEDGER_TAG_NEURAL() {
        return VM_LEDGER_TAG_NEURAL;
    }
    private static final int VM_LEDGER_TAG_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_TAG_MAX 5
     * }
     */
    public static int VM_LEDGER_TAG_MAX() {
        return VM_LEDGER_TAG_MAX;
    }
    private static final int VM_MEMORY_MALLOC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_MALLOC 1
     * }
     */
    public static int VM_MEMORY_MALLOC() {
        return VM_MEMORY_MALLOC;
    }
    private static final int VM_MEMORY_MALLOC_SMALL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_MALLOC_SMALL 2
     * }
     */
    public static int VM_MEMORY_MALLOC_SMALL() {
        return VM_MEMORY_MALLOC_SMALL;
    }
    private static final int VM_MEMORY_MALLOC_LARGE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_MALLOC_LARGE 3
     * }
     */
    public static int VM_MEMORY_MALLOC_LARGE() {
        return VM_MEMORY_MALLOC_LARGE;
    }
    private static final int VM_MEMORY_MALLOC_HUGE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_MALLOC_HUGE 4
     * }
     */
    public static int VM_MEMORY_MALLOC_HUGE() {
        return VM_MEMORY_MALLOC_HUGE;
    }
    private static final int VM_MEMORY_SBRK = (int)5L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_SBRK 5
     * }
     */
    public static int VM_MEMORY_SBRK() {
        return VM_MEMORY_SBRK;
    }
    private static final int VM_MEMORY_REALLOC = (int)6L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_REALLOC 6
     * }
     */
    public static int VM_MEMORY_REALLOC() {
        return VM_MEMORY_REALLOC;
    }
    private static final int VM_MEMORY_MALLOC_TINY = (int)7L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_MALLOC_TINY 7
     * }
     */
    public static int VM_MEMORY_MALLOC_TINY() {
        return VM_MEMORY_MALLOC_TINY;
    }
    private static final int VM_MEMORY_MALLOC_LARGE_REUSABLE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_MALLOC_LARGE_REUSABLE 8
     * }
     */
    public static int VM_MEMORY_MALLOC_LARGE_REUSABLE() {
        return VM_MEMORY_MALLOC_LARGE_REUSABLE;
    }
    private static final int VM_MEMORY_MALLOC_LARGE_REUSED = (int)9L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_MALLOC_LARGE_REUSED 9
     * }
     */
    public static int VM_MEMORY_MALLOC_LARGE_REUSED() {
        return VM_MEMORY_MALLOC_LARGE_REUSED;
    }
    private static final int VM_MEMORY_ANALYSIS_TOOL = (int)10L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ANALYSIS_TOOL 10
     * }
     */
    public static int VM_MEMORY_ANALYSIS_TOOL() {
        return VM_MEMORY_ANALYSIS_TOOL;
    }
    private static final int VM_MEMORY_MALLOC_NANO = (int)11L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_MALLOC_NANO 11
     * }
     */
    public static int VM_MEMORY_MALLOC_NANO() {
        return VM_MEMORY_MALLOC_NANO;
    }
    private static final int VM_MEMORY_MALLOC_MEDIUM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_MALLOC_MEDIUM 12
     * }
     */
    public static int VM_MEMORY_MALLOC_MEDIUM() {
        return VM_MEMORY_MALLOC_MEDIUM;
    }
    private static final int VM_MEMORY_MALLOC_PROB_GUARD = (int)13L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_MALLOC_PROB_GUARD 13
     * }
     */
    public static int VM_MEMORY_MALLOC_PROB_GUARD() {
        return VM_MEMORY_MALLOC_PROB_GUARD;
    }
    private static final int VM_MEMORY_MACH_MSG = (int)20L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_MACH_MSG 20
     * }
     */
    public static int VM_MEMORY_MACH_MSG() {
        return VM_MEMORY_MACH_MSG;
    }
    private static final int VM_MEMORY_IOKIT = (int)21L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_IOKIT 21
     * }
     */
    public static int VM_MEMORY_IOKIT() {
        return VM_MEMORY_IOKIT;
    }
    private static final int VM_MEMORY_STACK = (int)30L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_STACK 30
     * }
     */
    public static int VM_MEMORY_STACK() {
        return VM_MEMORY_STACK;
    }
    private static final int VM_MEMORY_GUARD = (int)31L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_GUARD 31
     * }
     */
    public static int VM_MEMORY_GUARD() {
        return VM_MEMORY_GUARD;
    }
    private static final int VM_MEMORY_SHARED_PMAP = (int)32L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_SHARED_PMAP 32
     * }
     */
    public static int VM_MEMORY_SHARED_PMAP() {
        return VM_MEMORY_SHARED_PMAP;
    }
    private static final int VM_MEMORY_DYLIB = (int)33L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_DYLIB 33
     * }
     */
    public static int VM_MEMORY_DYLIB() {
        return VM_MEMORY_DYLIB;
    }
    private static final int VM_MEMORY_OBJC_DISPATCHERS = (int)34L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_OBJC_DISPATCHERS 34
     * }
     */
    public static int VM_MEMORY_OBJC_DISPATCHERS() {
        return VM_MEMORY_OBJC_DISPATCHERS;
    }
    private static final int VM_MEMORY_UNSHARED_PMAP = (int)35L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_UNSHARED_PMAP 35
     * }
     */
    public static int VM_MEMORY_UNSHARED_PMAP() {
        return VM_MEMORY_UNSHARED_PMAP;
    }
    private static final int VM_MEMORY_APPKIT = (int)40L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_APPKIT 40
     * }
     */
    public static int VM_MEMORY_APPKIT() {
        return VM_MEMORY_APPKIT;
    }
    private static final int VM_MEMORY_FOUNDATION = (int)41L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_FOUNDATION 41
     * }
     */
    public static int VM_MEMORY_FOUNDATION() {
        return VM_MEMORY_FOUNDATION;
    }
    private static final int VM_MEMORY_COREGRAPHICS = (int)42L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREGRAPHICS 42
     * }
     */
    public static int VM_MEMORY_COREGRAPHICS() {
        return VM_MEMORY_COREGRAPHICS;
    }
    private static final int VM_MEMORY_CORESERVICES = (int)43L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_CORESERVICES 43
     * }
     */
    public static int VM_MEMORY_CORESERVICES() {
        return VM_MEMORY_CORESERVICES;
    }
    private static final int VM_MEMORY_JAVA = (int)44L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_JAVA 44
     * }
     */
    public static int VM_MEMORY_JAVA() {
        return VM_MEMORY_JAVA;
    }
    private static final int VM_MEMORY_COREDATA = (int)45L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREDATA 45
     * }
     */
    public static int VM_MEMORY_COREDATA() {
        return VM_MEMORY_COREDATA;
    }
    private static final int VM_MEMORY_COREDATA_OBJECTIDS = (int)46L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREDATA_OBJECTIDS 46
     * }
     */
    public static int VM_MEMORY_COREDATA_OBJECTIDS() {
        return VM_MEMORY_COREDATA_OBJECTIDS;
    }
    private static final int VM_MEMORY_ATS = (int)50L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ATS 50
     * }
     */
    public static int VM_MEMORY_ATS() {
        return VM_MEMORY_ATS;
    }
    private static final int VM_MEMORY_LAYERKIT = (int)51L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_LAYERKIT 51
     * }
     */
    public static int VM_MEMORY_LAYERKIT() {
        return VM_MEMORY_LAYERKIT;
    }
    private static final int VM_MEMORY_CGIMAGE = (int)52L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_CGIMAGE 52
     * }
     */
    public static int VM_MEMORY_CGIMAGE() {
        return VM_MEMORY_CGIMAGE;
    }
    private static final int VM_MEMORY_TCMALLOC = (int)53L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_TCMALLOC 53
     * }
     */
    public static int VM_MEMORY_TCMALLOC() {
        return VM_MEMORY_TCMALLOC;
    }
    private static final int VM_MEMORY_COREGRAPHICS_DATA = (int)54L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREGRAPHICS_DATA 54
     * }
     */
    public static int VM_MEMORY_COREGRAPHICS_DATA() {
        return VM_MEMORY_COREGRAPHICS_DATA;
    }
    private static final int VM_MEMORY_COREGRAPHICS_SHARED = (int)55L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREGRAPHICS_SHARED 55
     * }
     */
    public static int VM_MEMORY_COREGRAPHICS_SHARED() {
        return VM_MEMORY_COREGRAPHICS_SHARED;
    }
    private static final int VM_MEMORY_COREGRAPHICS_FRAMEBUFFERS = (int)56L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREGRAPHICS_FRAMEBUFFERS 56
     * }
     */
    public static int VM_MEMORY_COREGRAPHICS_FRAMEBUFFERS() {
        return VM_MEMORY_COREGRAPHICS_FRAMEBUFFERS;
    }
    private static final int VM_MEMORY_COREGRAPHICS_BACKINGSTORES = (int)57L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREGRAPHICS_BACKINGSTORES 57
     * }
     */
    public static int VM_MEMORY_COREGRAPHICS_BACKINGSTORES() {
        return VM_MEMORY_COREGRAPHICS_BACKINGSTORES;
    }
    private static final int VM_MEMORY_COREGRAPHICS_XALLOC = (int)58L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREGRAPHICS_XALLOC 58
     * }
     */
    public static int VM_MEMORY_COREGRAPHICS_XALLOC() {
        return VM_MEMORY_COREGRAPHICS_XALLOC;
    }
    private static final int VM_MEMORY_DYLD = (int)60L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_DYLD 60
     * }
     */
    public static int VM_MEMORY_DYLD() {
        return VM_MEMORY_DYLD;
    }
    private static final int VM_MEMORY_DYLD_MALLOC = (int)61L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_DYLD_MALLOC 61
     * }
     */
    public static int VM_MEMORY_DYLD_MALLOC() {
        return VM_MEMORY_DYLD_MALLOC;
    }
    private static final int VM_MEMORY_SQLITE = (int)62L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_SQLITE 62
     * }
     */
    public static int VM_MEMORY_SQLITE() {
        return VM_MEMORY_SQLITE;
    }
    private static final int VM_MEMORY_JAVASCRIPT_CORE = (int)63L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_JAVASCRIPT_CORE 63
     * }
     */
    public static int VM_MEMORY_JAVASCRIPT_CORE() {
        return VM_MEMORY_JAVASCRIPT_CORE;
    }
    private static final int VM_MEMORY_JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR = (int)64L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR 64
     * }
     */
    public static int VM_MEMORY_JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR() {
        return VM_MEMORY_JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR;
    }
    private static final int VM_MEMORY_JAVASCRIPT_JIT_REGISTER_FILE = (int)65L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_JAVASCRIPT_JIT_REGISTER_FILE 65
     * }
     */
    public static int VM_MEMORY_JAVASCRIPT_JIT_REGISTER_FILE() {
        return VM_MEMORY_JAVASCRIPT_JIT_REGISTER_FILE;
    }
    private static final int VM_MEMORY_GLSL = (int)66L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_GLSL 66
     * }
     */
    public static int VM_MEMORY_GLSL() {
        return VM_MEMORY_GLSL;
    }
    private static final int VM_MEMORY_OPENCL = (int)67L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_OPENCL 67
     * }
     */
    public static int VM_MEMORY_OPENCL() {
        return VM_MEMORY_OPENCL;
    }
    private static final int VM_MEMORY_COREIMAGE = (int)68L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREIMAGE 68
     * }
     */
    public static int VM_MEMORY_COREIMAGE() {
        return VM_MEMORY_COREIMAGE;
    }
    private static final int VM_MEMORY_WEBCORE_PURGEABLE_BUFFERS = (int)69L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_WEBCORE_PURGEABLE_BUFFERS 69
     * }
     */
    public static int VM_MEMORY_WEBCORE_PURGEABLE_BUFFERS() {
        return VM_MEMORY_WEBCORE_PURGEABLE_BUFFERS;
    }
    private static final int VM_MEMORY_IMAGEIO = (int)70L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_IMAGEIO 70
     * }
     */
    public static int VM_MEMORY_IMAGEIO() {
        return VM_MEMORY_IMAGEIO;
    }
    private static final int VM_MEMORY_COREPROFILE = (int)71L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREPROFILE 71
     * }
     */
    public static int VM_MEMORY_COREPROFILE() {
        return VM_MEMORY_COREPROFILE;
    }
    private static final int VM_MEMORY_ASSETSD = (int)72L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ASSETSD 72
     * }
     */
    public static int VM_MEMORY_ASSETSD() {
        return VM_MEMORY_ASSETSD;
    }
    private static final int VM_MEMORY_OS_ALLOC_ONCE = (int)73L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_OS_ALLOC_ONCE 73
     * }
     */
    public static int VM_MEMORY_OS_ALLOC_ONCE() {
        return VM_MEMORY_OS_ALLOC_ONCE;
    }
    private static final int VM_MEMORY_LIBDISPATCH = (int)74L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_LIBDISPATCH 74
     * }
     */
    public static int VM_MEMORY_LIBDISPATCH() {
        return VM_MEMORY_LIBDISPATCH;
    }
    private static final int VM_MEMORY_ACCELERATE = (int)75L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ACCELERATE 75
     * }
     */
    public static int VM_MEMORY_ACCELERATE() {
        return VM_MEMORY_ACCELERATE;
    }
    private static final int VM_MEMORY_COREUI = (int)76L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREUI 76
     * }
     */
    public static int VM_MEMORY_COREUI() {
        return VM_MEMORY_COREUI;
    }
    private static final int VM_MEMORY_COREUIFILE = (int)77L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREUIFILE 77
     * }
     */
    public static int VM_MEMORY_COREUIFILE() {
        return VM_MEMORY_COREUIFILE;
    }
    private static final int VM_MEMORY_GENEALOGY = (int)78L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_GENEALOGY 78
     * }
     */
    public static int VM_MEMORY_GENEALOGY() {
        return VM_MEMORY_GENEALOGY;
    }
    private static final int VM_MEMORY_RAWCAMERA = (int)79L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_RAWCAMERA 79
     * }
     */
    public static int VM_MEMORY_RAWCAMERA() {
        return VM_MEMORY_RAWCAMERA;
    }
    private static final int VM_MEMORY_CORPSEINFO = (int)80L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_CORPSEINFO 80
     * }
     */
    public static int VM_MEMORY_CORPSEINFO() {
        return VM_MEMORY_CORPSEINFO;
    }
    private static final int VM_MEMORY_ASL = (int)81L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ASL 81
     * }
     */
    public static int VM_MEMORY_ASL() {
        return VM_MEMORY_ASL;
    }
    private static final int VM_MEMORY_SWIFT_RUNTIME = (int)82L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_SWIFT_RUNTIME 82
     * }
     */
    public static int VM_MEMORY_SWIFT_RUNTIME() {
        return VM_MEMORY_SWIFT_RUNTIME;
    }
    private static final int VM_MEMORY_SWIFT_METADATA = (int)83L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_SWIFT_METADATA 83
     * }
     */
    public static int VM_MEMORY_SWIFT_METADATA() {
        return VM_MEMORY_SWIFT_METADATA;
    }
    private static final int VM_MEMORY_DHMM = (int)84L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_DHMM 84
     * }
     */
    public static int VM_MEMORY_DHMM() {
        return VM_MEMORY_DHMM;
    }
    private static final int VM_MEMORY_SCENEKIT = (int)86L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_SCENEKIT 86
     * }
     */
    public static int VM_MEMORY_SCENEKIT() {
        return VM_MEMORY_SCENEKIT;
    }
    private static final int VM_MEMORY_SKYWALK = (int)87L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_SKYWALK 87
     * }
     */
    public static int VM_MEMORY_SKYWALK() {
        return VM_MEMORY_SKYWALK;
    }
    private static final int VM_MEMORY_IOSURFACE = (int)88L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_IOSURFACE 88
     * }
     */
    public static int VM_MEMORY_IOSURFACE() {
        return VM_MEMORY_IOSURFACE;
    }
    private static final int VM_MEMORY_LIBNETWORK = (int)89L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_LIBNETWORK 89
     * }
     */
    public static int VM_MEMORY_LIBNETWORK() {
        return VM_MEMORY_LIBNETWORK;
    }
    private static final int VM_MEMORY_AUDIO = (int)90L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_AUDIO 90
     * }
     */
    public static int VM_MEMORY_AUDIO() {
        return VM_MEMORY_AUDIO;
    }
    private static final int VM_MEMORY_VIDEOBITSTREAM = (int)91L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_VIDEOBITSTREAM 91
     * }
     */
    public static int VM_MEMORY_VIDEOBITSTREAM() {
        return VM_MEMORY_VIDEOBITSTREAM;
    }
    private static final int VM_MEMORY_CM_XPC = (int)92L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_CM_XPC 92
     * }
     */
    public static int VM_MEMORY_CM_XPC() {
        return VM_MEMORY_CM_XPC;
    }
    private static final int VM_MEMORY_CM_RPC = (int)93L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_CM_RPC 93
     * }
     */
    public static int VM_MEMORY_CM_RPC() {
        return VM_MEMORY_CM_RPC;
    }
    private static final int VM_MEMORY_CM_MEMORYPOOL = (int)94L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_CM_MEMORYPOOL 94
     * }
     */
    public static int VM_MEMORY_CM_MEMORYPOOL() {
        return VM_MEMORY_CM_MEMORYPOOL;
    }
    private static final int VM_MEMORY_CM_READCACHE = (int)95L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_CM_READCACHE 95
     * }
     */
    public static int VM_MEMORY_CM_READCACHE() {
        return VM_MEMORY_CM_READCACHE;
    }
    private static final int VM_MEMORY_CM_CRABS = (int)96L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_CM_CRABS 96
     * }
     */
    public static int VM_MEMORY_CM_CRABS() {
        return VM_MEMORY_CM_CRABS;
    }
    private static final int VM_MEMORY_QUICKLOOK_THUMBNAILS = (int)97L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_QUICKLOOK_THUMBNAILS 97
     * }
     */
    public static int VM_MEMORY_QUICKLOOK_THUMBNAILS() {
        return VM_MEMORY_QUICKLOOK_THUMBNAILS;
    }
    private static final int VM_MEMORY_ACCOUNTS = (int)98L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ACCOUNTS 98
     * }
     */
    public static int VM_MEMORY_ACCOUNTS() {
        return VM_MEMORY_ACCOUNTS;
    }
    private static final int VM_MEMORY_SANITIZER = (int)99L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_SANITIZER 99
     * }
     */
    public static int VM_MEMORY_SANITIZER() {
        return VM_MEMORY_SANITIZER;
    }
    private static final int VM_MEMORY_IOACCELERATOR = (int)100L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_IOACCELERATOR 100
     * }
     */
    public static int VM_MEMORY_IOACCELERATOR() {
        return VM_MEMORY_IOACCELERATOR;
    }
    private static final int VM_MEMORY_CM_REGWARP = (int)101L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_CM_REGWARP 101
     * }
     */
    public static int VM_MEMORY_CM_REGWARP() {
        return VM_MEMORY_CM_REGWARP;
    }
    private static final int VM_MEMORY_EAR_DECODER = (int)102L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_EAR_DECODER 102
     * }
     */
    public static int VM_MEMORY_EAR_DECODER() {
        return VM_MEMORY_EAR_DECODER;
    }
    private static final int VM_MEMORY_COREUI_CACHED_IMAGE_DATA = (int)103L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREUI_CACHED_IMAGE_DATA 103
     * }
     */
    public static int VM_MEMORY_COREUI_CACHED_IMAGE_DATA() {
        return VM_MEMORY_COREUI_CACHED_IMAGE_DATA;
    }
    private static final int VM_MEMORY_COLORSYNC = (int)104L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COLORSYNC 104
     * }
     */
    public static int VM_MEMORY_COLORSYNC() {
        return VM_MEMORY_COLORSYNC;
    }
    private static final int VM_MEMORY_BTINFO = (int)105L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_BTINFO 105
     * }
     */
    public static int VM_MEMORY_BTINFO() {
        return VM_MEMORY_BTINFO;
    }
    private static final int VM_MEMORY_CM_HLS = (int)106L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_CM_HLS 106
     * }
     */
    public static int VM_MEMORY_CM_HLS() {
        return VM_MEMORY_CM_HLS;
    }
    private static final int VM_MEMORY_ROSETTA = (int)230L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ROSETTA 230
     * }
     */
    public static int VM_MEMORY_ROSETTA() {
        return VM_MEMORY_ROSETTA;
    }
    private static final int VM_MEMORY_ROSETTA_THREAD_CONTEXT = (int)231L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ROSETTA_THREAD_CONTEXT 231
     * }
     */
    public static int VM_MEMORY_ROSETTA_THREAD_CONTEXT() {
        return VM_MEMORY_ROSETTA_THREAD_CONTEXT;
    }
    private static final int VM_MEMORY_ROSETTA_INDIRECT_BRANCH_MAP = (int)232L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ROSETTA_INDIRECT_BRANCH_MAP 232
     * }
     */
    public static int VM_MEMORY_ROSETTA_INDIRECT_BRANCH_MAP() {
        return VM_MEMORY_ROSETTA_INDIRECT_BRANCH_MAP;
    }
    private static final int VM_MEMORY_ROSETTA_RETURN_STACK = (int)233L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ROSETTA_RETURN_STACK 233
     * }
     */
    public static int VM_MEMORY_ROSETTA_RETURN_STACK() {
        return VM_MEMORY_ROSETTA_RETURN_STACK;
    }
    private static final int VM_MEMORY_ROSETTA_EXECUTABLE_HEAP = (int)234L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ROSETTA_EXECUTABLE_HEAP 234
     * }
     */
    public static int VM_MEMORY_ROSETTA_EXECUTABLE_HEAP() {
        return VM_MEMORY_ROSETTA_EXECUTABLE_HEAP;
    }
    private static final int VM_MEMORY_ROSETTA_USER_LDT = (int)235L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ROSETTA_USER_LDT 235
     * }
     */
    public static int VM_MEMORY_ROSETTA_USER_LDT() {
        return VM_MEMORY_ROSETTA_USER_LDT;
    }
    private static final int VM_MEMORY_ROSETTA_ARENA = (int)236L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ROSETTA_ARENA 236
     * }
     */
    public static int VM_MEMORY_ROSETTA_ARENA() {
        return VM_MEMORY_ROSETTA_ARENA;
    }
    private static final int VM_MEMORY_ROSETTA_10 = (int)239L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_ROSETTA_10 239
     * }
     */
    public static int VM_MEMORY_ROSETTA_10() {
        return VM_MEMORY_ROSETTA_10;
    }
    private static final int VM_MEMORY_APPLICATION_SPECIFIC_1 = (int)240L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_APPLICATION_SPECIFIC_1 240
     * }
     */
    public static int VM_MEMORY_APPLICATION_SPECIFIC_1() {
        return VM_MEMORY_APPLICATION_SPECIFIC_1;
    }
    private static final int VM_MEMORY_APPLICATION_SPECIFIC_16 = (int)255L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_APPLICATION_SPECIFIC_16 255
     * }
     */
    public static int VM_MEMORY_APPLICATION_SPECIFIC_16() {
        return VM_MEMORY_APPLICATION_SPECIFIC_16;
    }
    private static final int VM_MEMORY_COUNT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COUNT 256
     * }
     */
    public static int VM_MEMORY_COUNT() {
        return VM_MEMORY_COUNT;
    }
    private static final int MEMORY_OBJECT_COPY_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_COPY_NONE 0
     * }
     */
    public static int MEMORY_OBJECT_COPY_NONE() {
        return MEMORY_OBJECT_COPY_NONE;
    }
    private static final int MEMORY_OBJECT_COPY_CALL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_COPY_CALL 1
     * }
     */
    public static int MEMORY_OBJECT_COPY_CALL() {
        return MEMORY_OBJECT_COPY_CALL;
    }
    private static final int MEMORY_OBJECT_COPY_DELAY = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_COPY_DELAY 2
     * }
     */
    public static int MEMORY_OBJECT_COPY_DELAY() {
        return MEMORY_OBJECT_COPY_DELAY;
    }
    private static final int MEMORY_OBJECT_COPY_TEMPORARY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_COPY_TEMPORARY 3
     * }
     */
    public static int MEMORY_OBJECT_COPY_TEMPORARY() {
        return MEMORY_OBJECT_COPY_TEMPORARY;
    }
    private static final int MEMORY_OBJECT_COPY_SYMMETRIC = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_COPY_SYMMETRIC 4
     * }
     */
    public static int MEMORY_OBJECT_COPY_SYMMETRIC() {
        return MEMORY_OBJECT_COPY_SYMMETRIC;
    }
    private static final int MEMORY_OBJECT_COPY_INVALID = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_COPY_INVALID 5
     * }
     */
    public static int MEMORY_OBJECT_COPY_INVALID() {
        return MEMORY_OBJECT_COPY_INVALID;
    }
    private static final int MEMORY_OBJECT_COPY_DELAY_FORK = (int)6L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_COPY_DELAY_FORK 6
     * }
     */
    public static int MEMORY_OBJECT_COPY_DELAY_FORK() {
        return MEMORY_OBJECT_COPY_DELAY_FORK;
    }
    private static final int MEMORY_OBJECT_RETURN_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_RETURN_NONE 0
     * }
     */
    public static int MEMORY_OBJECT_RETURN_NONE() {
        return MEMORY_OBJECT_RETURN_NONE;
    }
    private static final int MEMORY_OBJECT_RETURN_DIRTY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_RETURN_DIRTY 1
     * }
     */
    public static int MEMORY_OBJECT_RETURN_DIRTY() {
        return MEMORY_OBJECT_RETURN_DIRTY;
    }
    private static final int MEMORY_OBJECT_RETURN_ALL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_RETURN_ALL 2
     * }
     */
    public static int MEMORY_OBJECT_RETURN_ALL() {
        return MEMORY_OBJECT_RETURN_ALL;
    }
    private static final int MEMORY_OBJECT_RETURN_ANYTHING = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_RETURN_ANYTHING 3
     * }
     */
    public static int MEMORY_OBJECT_RETURN_ANYTHING() {
        return MEMORY_OBJECT_RETURN_ANYTHING;
    }
    private static final int MEMORY_OBJECT_DATA_FLUSH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_DATA_FLUSH 1
     * }
     */
    public static int MEMORY_OBJECT_DATA_FLUSH() {
        return MEMORY_OBJECT_DATA_FLUSH;
    }
    private static final int MEMORY_OBJECT_DATA_NO_CHANGE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_DATA_NO_CHANGE 2
     * }
     */
    public static int MEMORY_OBJECT_DATA_NO_CHANGE() {
        return MEMORY_OBJECT_DATA_NO_CHANGE;
    }
    private static final int MEMORY_OBJECT_DATA_PURGE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_DATA_PURGE 4
     * }
     */
    public static int MEMORY_OBJECT_DATA_PURGE() {
        return MEMORY_OBJECT_DATA_PURGE;
    }
    private static final int MEMORY_OBJECT_COPY_SYNC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_COPY_SYNC 8
     * }
     */
    public static int MEMORY_OBJECT_COPY_SYNC() {
        return MEMORY_OBJECT_COPY_SYNC;
    }
    private static final int MEMORY_OBJECT_DATA_SYNC = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_DATA_SYNC 16
     * }
     */
    public static int MEMORY_OBJECT_DATA_SYNC() {
        return MEMORY_OBJECT_DATA_SYNC;
    }
    private static final int MEMORY_OBJECT_IO_SYNC = (int)32L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_IO_SYNC 32
     * }
     */
    public static int MEMORY_OBJECT_IO_SYNC() {
        return MEMORY_OBJECT_IO_SYNC;
    }
    private static final int MEMORY_OBJECT_DATA_FLUSH_ALL = (int)64L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_DATA_FLUSH_ALL 64
     * }
     */
    public static int MEMORY_OBJECT_DATA_FLUSH_ALL() {
        return MEMORY_OBJECT_DATA_FLUSH_ALL;
    }
    private static final int MEMORY_OBJECT_PERFORMANCE_INFO = (int)11L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_PERFORMANCE_INFO 11
     * }
     */
    public static int MEMORY_OBJECT_PERFORMANCE_INFO() {
        return MEMORY_OBJECT_PERFORMANCE_INFO;
    }
    private static final int MEMORY_OBJECT_ATTRIBUTE_INFO = (int)14L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_ATTRIBUTE_INFO 14
     * }
     */
    public static int MEMORY_OBJECT_ATTRIBUTE_INFO() {
        return MEMORY_OBJECT_ATTRIBUTE_INFO;
    }
    private static final int MEMORY_OBJECT_BEHAVIOR_INFO = (int)15L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_BEHAVIOR_INFO 15
     * }
     */
    public static int MEMORY_OBJECT_BEHAVIOR_INFO() {
        return MEMORY_OBJECT_BEHAVIOR_INFO;
    }
    private static final int MEMORY_OBJECT_TERMINATE_IDLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_TERMINATE_IDLE 1
     * }
     */
    public static int MEMORY_OBJECT_TERMINATE_IDLE() {
        return MEMORY_OBJECT_TERMINATE_IDLE;
    }
    private static final int MEMORY_OBJECT_RESPECT_CACHE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_RESPECT_CACHE 2
     * }
     */
    public static int MEMORY_OBJECT_RESPECT_CACHE() {
        return MEMORY_OBJECT_RESPECT_CACHE;
    }
    private static final int MEMORY_OBJECT_RELEASE_NO_OP = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_RELEASE_NO_OP 4
     * }
     */
    public static int MEMORY_OBJECT_RELEASE_NO_OP() {
        return MEMORY_OBJECT_RELEASE_NO_OP;
    }
    private static final int MAP_MEM_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_NOOP 0
     * }
     */
    public static int MAP_MEM_NOOP() {
        return MAP_MEM_NOOP;
    }
    private static final int MAP_MEM_COPYBACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_COPYBACK 1
     * }
     */
    public static int MAP_MEM_COPYBACK() {
        return MAP_MEM_COPYBACK;
    }
    private static final int MAP_MEM_IO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_IO 2
     * }
     */
    public static int MAP_MEM_IO() {
        return MAP_MEM_IO;
    }
    private static final int MAP_MEM_WTHRU = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_WTHRU 3
     * }
     */
    public static int MAP_MEM_WTHRU() {
        return MAP_MEM_WTHRU;
    }
    private static final int MAP_MEM_WCOMB = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_WCOMB 4
     * }
     */
    public static int MAP_MEM_WCOMB() {
        return MAP_MEM_WCOMB;
    }
    private static final int MAP_MEM_INNERWBACK = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_INNERWBACK 5
     * }
     */
    public static int MAP_MEM_INNERWBACK() {
        return MAP_MEM_INNERWBACK;
    }
    private static final int MAP_MEM_POSTED = (int)6L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_POSTED 6
     * }
     */
    public static int MAP_MEM_POSTED() {
        return MAP_MEM_POSTED;
    }
    private static final int MAP_MEM_RT = (int)7L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_RT 7
     * }
     */
    public static int MAP_MEM_RT() {
        return MAP_MEM_RT;
    }
    private static final int MAP_MEM_POSTED_REORDERED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_POSTED_REORDERED 8
     * }
     */
    public static int MAP_MEM_POSTED_REORDERED() {
        return MAP_MEM_POSTED_REORDERED;
    }
    private static final int MAP_MEM_POSTED_COMBINED_REORDERED = (int)9L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_POSTED_COMBINED_REORDERED 9
     * }
     */
    public static int MAP_MEM_POSTED_COMBINED_REORDERED() {
        return MAP_MEM_POSTED_COMBINED_REORDERED;
    }
    private static final int MAP_MEM_PROT_MASK = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_PROT_MASK 255
     * }
     */
    public static int MAP_MEM_PROT_MASK() {
        return MAP_MEM_PROT_MASK;
    }
    private static final int MAP_MEM_LEDGER_TAGGED = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_LEDGER_TAGGED 8192
     * }
     */
    public static int MAP_MEM_LEDGER_TAGGED() {
        return MAP_MEM_LEDGER_TAGGED;
    }
    private static final int MAP_MEM_PURGABLE_KERNEL_ONLY = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_PURGABLE_KERNEL_ONLY 16384
     * }
     */
    public static int MAP_MEM_PURGABLE_KERNEL_ONLY() {
        return MAP_MEM_PURGABLE_KERNEL_ONLY;
    }
    private static final int MAP_MEM_GRAB_SECLUDED = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_GRAB_SECLUDED 32768
     * }
     */
    public static int MAP_MEM_GRAB_SECLUDED() {
        return MAP_MEM_GRAB_SECLUDED;
    }
    private static final int MAP_MEM_ONLY = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_ONLY 65536
     * }
     */
    public static int MAP_MEM_ONLY() {
        return MAP_MEM_ONLY;
    }
    private static final int MAP_MEM_NAMED_CREATE = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_NAMED_CREATE 131072
     * }
     */
    public static int MAP_MEM_NAMED_CREATE() {
        return MAP_MEM_NAMED_CREATE;
    }
    private static final int MAP_MEM_PURGABLE = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_PURGABLE 262144
     * }
     */
    public static int MAP_MEM_PURGABLE() {
        return MAP_MEM_PURGABLE;
    }
    private static final int MAP_MEM_NAMED_REUSE = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_NAMED_REUSE 524288
     * }
     */
    public static int MAP_MEM_NAMED_REUSE() {
        return MAP_MEM_NAMED_REUSE;
    }
    private static final int MAP_MEM_USE_DATA_ADDR = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_USE_DATA_ADDR 1048576
     * }
     */
    public static int MAP_MEM_USE_DATA_ADDR() {
        return MAP_MEM_USE_DATA_ADDR;
    }
    private static final int MAP_MEM_VM_COPY = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_VM_COPY 2097152
     * }
     */
    public static int MAP_MEM_VM_COPY() {
        return MAP_MEM_VM_COPY;
    }
    private static final int MAP_MEM_VM_SHARE = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_VM_SHARE 4194304
     * }
     */
    public static int MAP_MEM_VM_SHARE() {
        return MAP_MEM_VM_SHARE;
    }
    private static final int MAP_MEM_4K_DATA_ADDR = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_4K_DATA_ADDR 8388608
     * }
     */
    public static int MAP_MEM_4K_DATA_ADDR() {
        return MAP_MEM_4K_DATA_ADDR;
    }
    private static final int MAP_MEM_FLAGS_MASK = (int)16776960L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_FLAGS_MASK 16776960
     * }
     */
    public static int MAP_MEM_FLAGS_MASK() {
        return MAP_MEM_FLAGS_MASK;
    }
    private static final int EXC_TYPES_COUNT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define EXC_TYPES_COUNT 14
     * }
     */
    public static int EXC_TYPES_COUNT() {
        return EXC_TYPES_COUNT;
    }
    private static final int EXC_MASK_MACHINE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_MACHINE 0
     * }
     */
    public static int EXC_MASK_MACHINE() {
        return EXC_MASK_MACHINE;
    }
    private static final int EXCEPTION_CODE_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EXCEPTION_CODE_MAX 2
     * }
     */
    public static int EXCEPTION_CODE_MAX() {
        return EXCEPTION_CODE_MAX;
    }
    private static final int EXC_ARM_UNDEFINED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_UNDEFINED 1
     * }
     */
    public static int EXC_ARM_UNDEFINED() {
        return EXC_ARM_UNDEFINED;
    }
    private static final int EXC_ARM_SME_DISALLOWED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_SME_DISALLOWED 2
     * }
     */
    public static int EXC_ARM_SME_DISALLOWED() {
        return EXC_ARM_SME_DISALLOWED;
    }
    private static final int EXC_ARM_FP_UNDEFINED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_FP_UNDEFINED 0
     * }
     */
    public static int EXC_ARM_FP_UNDEFINED() {
        return EXC_ARM_FP_UNDEFINED;
    }
    private static final int EXC_ARM_FP_IO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_FP_IO 1
     * }
     */
    public static int EXC_ARM_FP_IO() {
        return EXC_ARM_FP_IO;
    }
    private static final int EXC_ARM_FP_DZ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_FP_DZ 2
     * }
     */
    public static int EXC_ARM_FP_DZ() {
        return EXC_ARM_FP_DZ;
    }
    private static final int EXC_ARM_FP_OF = (int)3L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_FP_OF 3
     * }
     */
    public static int EXC_ARM_FP_OF() {
        return EXC_ARM_FP_OF;
    }
    private static final int EXC_ARM_FP_UF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_FP_UF 4
     * }
     */
    public static int EXC_ARM_FP_UF() {
        return EXC_ARM_FP_UF;
    }
    private static final int EXC_ARM_FP_IX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_FP_IX 5
     * }
     */
    public static int EXC_ARM_FP_IX() {
        return EXC_ARM_FP_IX;
    }
    private static final int EXC_ARM_FP_ID = (int)6L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_FP_ID 6
     * }
     */
    public static int EXC_ARM_FP_ID() {
        return EXC_ARM_FP_ID;
    }
    private static final int EXC_ARM_DA_ALIGN = (int)257L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_DA_ALIGN 257
     * }
     */
    public static int EXC_ARM_DA_ALIGN() {
        return EXC_ARM_DA_ALIGN;
    }
    private static final int EXC_ARM_DA_DEBUG = (int)258L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_DA_DEBUG 258
     * }
     */
    public static int EXC_ARM_DA_DEBUG() {
        return EXC_ARM_DA_DEBUG;
    }
    private static final int EXC_ARM_SP_ALIGN = (int)259L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_SP_ALIGN 259
     * }
     */
    public static int EXC_ARM_SP_ALIGN() {
        return EXC_ARM_SP_ALIGN;
    }
    private static final int EXC_ARM_SWP = (int)260L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_SWP 260
     * }
     */
    public static int EXC_ARM_SWP() {
        return EXC_ARM_SWP;
    }
    private static final int EXC_ARM_PAC_FAIL = (int)261L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_PAC_FAIL 261
     * }
     */
    public static int EXC_ARM_PAC_FAIL() {
        return EXC_ARM_PAC_FAIL;
    }
    private static final int EXC_ARM_BREAKPOINT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARM_BREAKPOINT 1
     * }
     */
    public static int EXC_ARM_BREAKPOINT() {
        return EXC_ARM_BREAKPOINT;
    }
    private static final int EXC_BAD_ACCESS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXC_BAD_ACCESS 1
     * }
     */
    public static int EXC_BAD_ACCESS() {
        return EXC_BAD_ACCESS;
    }
    private static final int EXC_BAD_INSTRUCTION = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EXC_BAD_INSTRUCTION 2
     * }
     */
    public static int EXC_BAD_INSTRUCTION() {
        return EXC_BAD_INSTRUCTION;
    }
    private static final int EXC_ARITHMETIC = (int)3L;
    /**
     * {@snippet lang=c :
     * #define EXC_ARITHMETIC 3
     * }
     */
    public static int EXC_ARITHMETIC() {
        return EXC_ARITHMETIC;
    }
    private static final int EXC_EMULATION = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EXC_EMULATION 4
     * }
     */
    public static int EXC_EMULATION() {
        return EXC_EMULATION;
    }
    private static final int EXC_SOFTWARE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EXC_SOFTWARE 5
     * }
     */
    public static int EXC_SOFTWARE() {
        return EXC_SOFTWARE;
    }
    private static final int EXC_BREAKPOINT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define EXC_BREAKPOINT 6
     * }
     */
    public static int EXC_BREAKPOINT() {
        return EXC_BREAKPOINT;
    }
    private static final int EXC_SYSCALL = (int)7L;
    /**
     * {@snippet lang=c :
     * #define EXC_SYSCALL 7
     * }
     */
    public static int EXC_SYSCALL() {
        return EXC_SYSCALL;
    }
    private static final int EXC_MACH_SYSCALL = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EXC_MACH_SYSCALL 8
     * }
     */
    public static int EXC_MACH_SYSCALL() {
        return EXC_MACH_SYSCALL;
    }
    private static final int EXC_RPC_ALERT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define EXC_RPC_ALERT 9
     * }
     */
    public static int EXC_RPC_ALERT() {
        return EXC_RPC_ALERT;
    }
    private static final int EXC_CRASH = (int)10L;
    /**
     * {@snippet lang=c :
     * #define EXC_CRASH 10
     * }
     */
    public static int EXC_CRASH() {
        return EXC_CRASH;
    }
    private static final int EXC_RESOURCE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EXC_RESOURCE 11
     * }
     */
    public static int EXC_RESOURCE() {
        return EXC_RESOURCE;
    }
    private static final int EXC_GUARD = (int)12L;
    /**
     * {@snippet lang=c :
     * #define EXC_GUARD 12
     * }
     */
    public static int EXC_GUARD() {
        return EXC_GUARD;
    }
    private static final int EXC_CORPSE_NOTIFY = (int)13L;
    /**
     * {@snippet lang=c :
     * #define EXC_CORPSE_NOTIFY 13
     * }
     */
    public static int EXC_CORPSE_NOTIFY() {
        return EXC_CORPSE_NOTIFY;
    }
    private static final int EXCEPTION_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXCEPTION_DEFAULT 1
     * }
     */
    public static int EXCEPTION_DEFAULT() {
        return EXCEPTION_DEFAULT;
    }
    private static final int EXCEPTION_STATE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EXCEPTION_STATE 2
     * }
     */
    public static int EXCEPTION_STATE() {
        return EXCEPTION_STATE;
    }
    private static final int EXCEPTION_STATE_IDENTITY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define EXCEPTION_STATE_IDENTITY 3
     * }
     */
    public static int EXCEPTION_STATE_IDENTITY() {
        return EXCEPTION_STATE_IDENTITY;
    }
    private static final int EXCEPTION_IDENTITY_PROTECTED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EXCEPTION_IDENTITY_PROTECTED 4
     * }
     */
    public static int EXCEPTION_IDENTITY_PROTECTED() {
        return EXCEPTION_IDENTITY_PROTECTED;
    }
    private static final int EXCEPTION_STATE_IDENTITY_PROTECTED = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EXCEPTION_STATE_IDENTITY_PROTECTED 5
     * }
     */
    public static int EXCEPTION_STATE_IDENTITY_PROTECTED() {
        return EXCEPTION_STATE_IDENTITY_PROTECTED;
    }
    private static final int MACH_EXCEPTION_BACKTRACE_PREFERRED = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define MACH_EXCEPTION_BACKTRACE_PREFERRED 536870912
     * }
     */
    public static int MACH_EXCEPTION_BACKTRACE_PREFERRED() {
        return MACH_EXCEPTION_BACKTRACE_PREFERRED;
    }
    private static final int MACH_EXCEPTION_ERRORS = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define MACH_EXCEPTION_ERRORS 1073741824
     * }
     */
    public static int MACH_EXCEPTION_ERRORS() {
        return MACH_EXCEPTION_ERRORS;
    }
    private static final int FIRST_EXCEPTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FIRST_EXCEPTION 1
     * }
     */
    public static int FIRST_EXCEPTION() {
        return FIRST_EXCEPTION;
    }
    private static final int EXC_SOFT_SIGNAL = (int)65539L;
    /**
     * {@snippet lang=c :
     * #define EXC_SOFT_SIGNAL 65539
     * }
     */
    public static int EXC_SOFT_SIGNAL() {
        return EXC_SOFT_SIGNAL;
    }
    private static final int EXC_MACF_MIN = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define EXC_MACF_MIN 131072
     * }
     */
    public static int EXC_MACF_MIN() {
        return EXC_MACF_MIN;
    }
    private static final int EXC_MACF_MAX = (int)196607L;
    /**
     * {@snippet lang=c :
     * #define EXC_MACF_MAX 196607
     * }
     */
    public static int EXC_MACF_MAX() {
        return EXC_MACF_MAX;
    }
    private static final int THREAD_STATE_FLAVOR_LIST = (int)0L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_FLAVOR_LIST 0
     * }
     */
    public static int THREAD_STATE_FLAVOR_LIST() {
        return THREAD_STATE_FLAVOR_LIST;
    }
    private static final int THREAD_STATE_FLAVOR_LIST_NEW = (int)128L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_FLAVOR_LIST_NEW 128
     * }
     */
    public static int THREAD_STATE_FLAVOR_LIST_NEW() {
        return THREAD_STATE_FLAVOR_LIST_NEW;
    }
    private static final int THREAD_STATE_FLAVOR_LIST_10_9 = (int)129L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_FLAVOR_LIST_10_9 129
     * }
     */
    public static int THREAD_STATE_FLAVOR_LIST_10_9() {
        return THREAD_STATE_FLAVOR_LIST_10_9;
    }
    private static final int THREAD_STATE_FLAVOR_LIST_10_13 = (int)130L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_FLAVOR_LIST_10_13 130
     * }
     */
    public static int THREAD_STATE_FLAVOR_LIST_10_13() {
        return THREAD_STATE_FLAVOR_LIST_10_13;
    }
    private static final int THREAD_STATE_FLAVOR_LIST_10_15 = (int)131L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_FLAVOR_LIST_10_15 131
     * }
     */
    public static int THREAD_STATE_FLAVOR_LIST_10_15() {
        return THREAD_STATE_FLAVOR_LIST_10_15;
    }
    private static final int THREAD_CONVERT_THREAD_STATE_TO_SELF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_CONVERT_THREAD_STATE_TO_SELF 1
     * }
     */
    public static int THREAD_CONVERT_THREAD_STATE_TO_SELF() {
        return THREAD_CONVERT_THREAD_STATE_TO_SELF;
    }
    private static final int THREAD_CONVERT_THREAD_STATE_FROM_SELF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define THREAD_CONVERT_THREAD_STATE_FROM_SELF 2
     * }
     */
    public static int THREAD_CONVERT_THREAD_STATE_FROM_SELF() {
        return THREAD_CONVERT_THREAD_STATE_FROM_SELF;
    }
    private static final int PROCESSOR_CPU_STAT = (int)268435459L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_CPU_STAT 268435459
     * }
     */
    public static int PROCESSOR_CPU_STAT() {
        return PROCESSOR_CPU_STAT;
    }
    private static final int PROCESSOR_CPU_STAT64 = (int)268435460L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_CPU_STAT64 268435460
     * }
     */
    public static int PROCESSOR_CPU_STAT64() {
        return PROCESSOR_CPU_STAT64;
    }
    private static final int PROCESSOR_BASIC_INFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_BASIC_INFO 1
     * }
     */
    public static int PROCESSOR_BASIC_INFO() {
        return PROCESSOR_BASIC_INFO;
    }
    private static final int PROCESSOR_CPU_LOAD_INFO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_CPU_LOAD_INFO 2
     * }
     */
    public static int PROCESSOR_CPU_LOAD_INFO() {
        return PROCESSOR_CPU_LOAD_INFO;
    }
    private static final int PROCESSOR_PM_REGS_INFO = (int)268435457L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_PM_REGS_INFO 268435457
     * }
     */
    public static int PROCESSOR_PM_REGS_INFO() {
        return PROCESSOR_PM_REGS_INFO;
    }
    private static final int PROCESSOR_TEMPERATURE = (int)268435458L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_TEMPERATURE 268435458
     * }
     */
    public static int PROCESSOR_TEMPERATURE() {
        return PROCESSOR_TEMPERATURE;
    }
    private static final int LOAD_SCALE = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define LOAD_SCALE 1000
     * }
     */
    public static int LOAD_SCALE() {
        return LOAD_SCALE;
    }
    private static final int PROCESSOR_SET_BASIC_INFO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_SET_BASIC_INFO 5
     * }
     */
    public static int PROCESSOR_SET_BASIC_INFO() {
        return PROCESSOR_SET_BASIC_INFO;
    }
    private static final int PROCESSOR_SET_LOAD_INFO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_SET_LOAD_INFO 4
     * }
     */
    public static int PROCESSOR_SET_LOAD_INFO() {
        return PROCESSOR_SET_LOAD_INFO;
    }
    private static final int POLICY_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define POLICY_NULL 0
     * }
     */
    public static int POLICY_NULL() {
        return POLICY_NULL;
    }
    private static final int POLICY_TIMESHARE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLICY_TIMESHARE 1
     * }
     */
    public static int POLICY_TIMESHARE() {
        return POLICY_TIMESHARE;
    }
    private static final int POLICY_RR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define POLICY_RR 2
     * }
     */
    public static int POLICY_RR() {
        return POLICY_RR;
    }
    private static final int POLICY_FIFO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define POLICY_FIFO 4
     * }
     */
    public static int POLICY_FIFO() {
        return POLICY_FIFO;
    }
    private static final int TASK_BASIC_INFO_32 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC_INFO_32 4
     * }
     */
    public static int TASK_BASIC_INFO_32() {
        return TASK_BASIC_INFO_32;
    }
    private static final int TASK_BASIC2_INFO_32 = (int)6L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC2_INFO_32 6
     * }
     */
    public static int TASK_BASIC2_INFO_32() {
        return TASK_BASIC2_INFO_32;
    }
    private static final int TASK_EVENTS_INFO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TASK_EVENTS_INFO 2
     * }
     */
    public static int TASK_EVENTS_INFO() {
        return TASK_EVENTS_INFO;
    }
    private static final int TASK_THREAD_TIMES_INFO = (int)3L;
    /**
     * {@snippet lang=c :
     * #define TASK_THREAD_TIMES_INFO 3
     * }
     */
    public static int TASK_THREAD_TIMES_INFO() {
        return TASK_THREAD_TIMES_INFO;
    }
    private static final int TASK_ABSOLUTETIME_INFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_ABSOLUTETIME_INFO 1
     * }
     */
    public static int TASK_ABSOLUTETIME_INFO() {
        return TASK_ABSOLUTETIME_INFO;
    }
    private static final int TASK_KERNELMEMORY_INFO = (int)7L;
    /**
     * {@snippet lang=c :
     * #define TASK_KERNELMEMORY_INFO 7
     * }
     */
    public static int TASK_KERNELMEMORY_INFO() {
        return TASK_KERNELMEMORY_INFO;
    }
    private static final int TASK_SECURITY_TOKEN = (int)13L;
    /**
     * {@snippet lang=c :
     * #define TASK_SECURITY_TOKEN 13
     * }
     */
    public static int TASK_SECURITY_TOKEN() {
        return TASK_SECURITY_TOKEN;
    }
    private static final int TASK_AUDIT_TOKEN = (int)15L;
    /**
     * {@snippet lang=c :
     * #define TASK_AUDIT_TOKEN 15
     * }
     */
    public static int TASK_AUDIT_TOKEN() {
        return TASK_AUDIT_TOKEN;
    }
    private static final int TASK_AFFINITY_TAG_INFO = (int)16L;
    /**
     * {@snippet lang=c :
     * #define TASK_AFFINITY_TAG_INFO 16
     * }
     */
    public static int TASK_AFFINITY_TAG_INFO() {
        return TASK_AFFINITY_TAG_INFO;
    }
    private static final int TASK_DYLD_INFO = (int)17L;
    /**
     * {@snippet lang=c :
     * #define TASK_DYLD_INFO 17
     * }
     */
    public static int TASK_DYLD_INFO() {
        return TASK_DYLD_INFO;
    }
    private static final int TASK_DYLD_ALL_IMAGE_INFO_32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define TASK_DYLD_ALL_IMAGE_INFO_32 0
     * }
     */
    public static int TASK_DYLD_ALL_IMAGE_INFO_32() {
        return TASK_DYLD_ALL_IMAGE_INFO_32;
    }
    private static final int TASK_DYLD_ALL_IMAGE_INFO_64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_DYLD_ALL_IMAGE_INFO_64 1
     * }
     */
    public static int TASK_DYLD_ALL_IMAGE_INFO_64() {
        return TASK_DYLD_ALL_IMAGE_INFO_64;
    }
    private static final int TASK_BASIC_INFO_64_2 = (int)18L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC_INFO_64_2 18
     * }
     */
    public static int TASK_BASIC_INFO_64_2() {
        return TASK_BASIC_INFO_64_2;
    }
    private static final int TASK_EXTMOD_INFO = (int)19L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXTMOD_INFO 19
     * }
     */
    public static int TASK_EXTMOD_INFO() {
        return TASK_EXTMOD_INFO;
    }
    private static final int MACH_TASK_BASIC_INFO = (int)20L;
    /**
     * {@snippet lang=c :
     * #define MACH_TASK_BASIC_INFO 20
     * }
     */
    public static int MACH_TASK_BASIC_INFO() {
        return MACH_TASK_BASIC_INFO;
    }
    private static final int TASK_POWER_INFO = (int)21L;
    /**
     * {@snippet lang=c :
     * #define TASK_POWER_INFO 21
     * }
     */
    public static int TASK_POWER_INFO() {
        return TASK_POWER_INFO;
    }
    private static final int TASK_VM_INFO = (int)22L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO 22
     * }
     */
    public static int TASK_VM_INFO() {
        return TASK_VM_INFO;
    }
    private static final int TASK_VM_INFO_PURGEABLE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_PURGEABLE 23
     * }
     */
    public static int TASK_VM_INFO_PURGEABLE() {
        return TASK_VM_INFO_PURGEABLE;
    }
    private static final int TASK_TRACE_MEMORY_INFO = (int)24L;
    /**
     * {@snippet lang=c :
     * #define TASK_TRACE_MEMORY_INFO 24
     * }
     */
    public static int TASK_TRACE_MEMORY_INFO() {
        return TASK_TRACE_MEMORY_INFO;
    }
    private static final int TASK_WAIT_STATE_INFO = (int)25L;
    /**
     * {@snippet lang=c :
     * #define TASK_WAIT_STATE_INFO 25
     * }
     */
    public static int TASK_WAIT_STATE_INFO() {
        return TASK_WAIT_STATE_INFO;
    }
    private static final int TASK_POWER_INFO_V2 = (int)26L;
    /**
     * {@snippet lang=c :
     * #define TASK_POWER_INFO_V2 26
     * }
     */
    public static int TASK_POWER_INFO_V2() {
        return TASK_POWER_INFO_V2;
    }
    private static final int TASK_VM_INFO_PURGEABLE_ACCOUNT = (int)27L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_PURGEABLE_ACCOUNT 27
     * }
     */
    public static int TASK_VM_INFO_PURGEABLE_ACCOUNT() {
        return TASK_VM_INFO_PURGEABLE_ACCOUNT;
    }
    private static final int TASK_FLAGS_INFO = (int)28L;
    /**
     * {@snippet lang=c :
     * #define TASK_FLAGS_INFO 28
     * }
     */
    public static int TASK_FLAGS_INFO() {
        return TASK_FLAGS_INFO;
    }
    private static final int TF_LP64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TF_LP64 1
     * }
     */
    public static int TF_LP64() {
        return TF_LP64;
    }
    private static final int TF_64B_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TF_64B_DATA 2
     * }
     */
    public static int TF_64B_DATA() {
        return TF_64B_DATA;
    }
    private static final int TASK_DEBUG_INFO_INTERNAL = (int)29L;
    /**
     * {@snippet lang=c :
     * #define TASK_DEBUG_INFO_INTERNAL 29
     * }
     */
    public static int TASK_DEBUG_INFO_INTERNAL() {
        return TASK_DEBUG_INFO_INTERNAL;
    }
    private static final int TASK_EXC_GUARD_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_NONE 0
     * }
     */
    public static int TASK_EXC_GUARD_NONE() {
        return TASK_EXC_GUARD_NONE;
    }
    private static final int TASK_EXC_GUARD_VM_DELIVER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_VM_DELIVER 1
     * }
     */
    public static int TASK_EXC_GUARD_VM_DELIVER() {
        return TASK_EXC_GUARD_VM_DELIVER;
    }
    private static final int TASK_EXC_GUARD_VM_ONCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_VM_ONCE 2
     * }
     */
    public static int TASK_EXC_GUARD_VM_ONCE() {
        return TASK_EXC_GUARD_VM_ONCE;
    }
    private static final int TASK_EXC_GUARD_VM_CORPSE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_VM_CORPSE 4
     * }
     */
    public static int TASK_EXC_GUARD_VM_CORPSE() {
        return TASK_EXC_GUARD_VM_CORPSE;
    }
    private static final int TASK_EXC_GUARD_VM_FATAL = (int)8L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_VM_FATAL 8
     * }
     */
    public static int TASK_EXC_GUARD_VM_FATAL() {
        return TASK_EXC_GUARD_VM_FATAL;
    }
    private static final int TASK_EXC_GUARD_VM_ALL = (int)15L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_VM_ALL 15
     * }
     */
    public static int TASK_EXC_GUARD_VM_ALL() {
        return TASK_EXC_GUARD_VM_ALL;
    }
    private static final int TASK_EXC_GUARD_MP_DELIVER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_MP_DELIVER 16
     * }
     */
    public static int TASK_EXC_GUARD_MP_DELIVER() {
        return TASK_EXC_GUARD_MP_DELIVER;
    }
    private static final int TASK_EXC_GUARD_MP_ONCE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_MP_ONCE 32
     * }
     */
    public static int TASK_EXC_GUARD_MP_ONCE() {
        return TASK_EXC_GUARD_MP_ONCE;
    }
    private static final int TASK_EXC_GUARD_MP_CORPSE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_MP_CORPSE 64
     * }
     */
    public static int TASK_EXC_GUARD_MP_CORPSE() {
        return TASK_EXC_GUARD_MP_CORPSE;
    }
    private static final int TASK_EXC_GUARD_MP_FATAL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_MP_FATAL 128
     * }
     */
    public static int TASK_EXC_GUARD_MP_FATAL() {
        return TASK_EXC_GUARD_MP_FATAL;
    }
    private static final int TASK_EXC_GUARD_MP_ALL = (int)240L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_MP_ALL 240
     * }
     */
    public static int TASK_EXC_GUARD_MP_ALL() {
        return TASK_EXC_GUARD_MP_ALL;
    }
    private static final int TASK_EXC_GUARD_ALL = (int)255L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_ALL 255
     * }
     */
    public static int TASK_EXC_GUARD_ALL() {
        return TASK_EXC_GUARD_ALL;
    }
    private static final int TASK_CORPSE_FORKING_DISABLED_MEM_DIAG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_CORPSE_FORKING_DISABLED_MEM_DIAG 1
     * }
     */
    public static int TASK_CORPSE_FORKING_DISABLED_MEM_DIAG() {
        return TASK_CORPSE_FORKING_DISABLED_MEM_DIAG;
    }
    private static final int TASK_SCHED_TIMESHARE_INFO = (int)10L;
    /**
     * {@snippet lang=c :
     * #define TASK_SCHED_TIMESHARE_INFO 10
     * }
     */
    public static int TASK_SCHED_TIMESHARE_INFO() {
        return TASK_SCHED_TIMESHARE_INFO;
    }
    private static final int TASK_SCHED_RR_INFO = (int)11L;
    /**
     * {@snippet lang=c :
     * #define TASK_SCHED_RR_INFO 11
     * }
     */
    public static int TASK_SCHED_RR_INFO() {
        return TASK_SCHED_RR_INFO;
    }
    private static final int TASK_SCHED_FIFO_INFO = (int)12L;
    /**
     * {@snippet lang=c :
     * #define TASK_SCHED_FIFO_INFO 12
     * }
     */
    public static int TASK_SCHED_FIFO_INFO() {
        return TASK_SCHED_FIFO_INFO;
    }
    private static final int TASK_SCHED_INFO = (int)14L;
    /**
     * {@snippet lang=c :
     * #define TASK_SCHED_INFO 14
     * }
     */
    public static int TASK_SCHED_INFO() {
        return TASK_SCHED_INFO;
    }
    private static final int TASK_CATEGORY_POLICY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_CATEGORY_POLICY 1
     * }
     */
    public static int TASK_CATEGORY_POLICY() {
        return TASK_CATEGORY_POLICY;
    }
    private static final int TASK_SUPPRESSION_POLICY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define TASK_SUPPRESSION_POLICY 3
     * }
     */
    public static int TASK_SUPPRESSION_POLICY() {
        return TASK_SUPPRESSION_POLICY;
    }
    private static final int TASK_POLICY_STATE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TASK_POLICY_STATE 4
     * }
     */
    public static int TASK_POLICY_STATE() {
        return TASK_POLICY_STATE;
    }
    private static final int TASK_BASE_QOS_POLICY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASE_QOS_POLICY 8
     * }
     */
    public static int TASK_BASE_QOS_POLICY() {
        return TASK_BASE_QOS_POLICY;
    }
    private static final int TASK_OVERRIDE_QOS_POLICY = (int)9L;
    /**
     * {@snippet lang=c :
     * #define TASK_OVERRIDE_QOS_POLICY 9
     * }
     */
    public static int TASK_OVERRIDE_QOS_POLICY() {
        return TASK_OVERRIDE_QOS_POLICY;
    }
    private static final int TASK_BASE_LATENCY_QOS_POLICY = (int)10L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASE_LATENCY_QOS_POLICY 10
     * }
     */
    public static int TASK_BASE_LATENCY_QOS_POLICY() {
        return TASK_BASE_LATENCY_QOS_POLICY;
    }
    private static final int TASK_BASE_THROUGHPUT_QOS_POLICY = (int)11L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASE_THROUGHPUT_QOS_POLICY 11
     * }
     */
    public static int TASK_BASE_THROUGHPUT_QOS_POLICY() {
        return TASK_BASE_THROUGHPUT_QOS_POLICY;
    }
    private static final int PROC_FLAG_DARWINBG = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_DARWINBG 32768
     * }
     */
    public static int PROC_FLAG_DARWINBG() {
        return PROC_FLAG_DARWINBG;
    }
    private static final int PROC_FLAG_EXT_DARWINBG = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_EXT_DARWINBG 65536
     * }
     */
    public static int PROC_FLAG_EXT_DARWINBG() {
        return PROC_FLAG_EXT_DARWINBG;
    }
    private static final int PROC_FLAG_IOS_APPLEDAEMON = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_IOS_APPLEDAEMON 131072
     * }
     */
    public static int PROC_FLAG_IOS_APPLEDAEMON() {
        return PROC_FLAG_IOS_APPLEDAEMON;
    }
    private static final int PROC_FLAG_IOS_IMPPROMOTION = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_IOS_IMPPROMOTION 524288
     * }
     */
    public static int PROC_FLAG_IOS_IMPPROMOTION() {
        return PROC_FLAG_IOS_IMPPROMOTION;
    }
    private static final int PROC_FLAG_ADAPTIVE = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_ADAPTIVE 1048576
     * }
     */
    public static int PROC_FLAG_ADAPTIVE() {
        return PROC_FLAG_ADAPTIVE;
    }
    private static final int PROC_FLAG_ADAPTIVE_IMPORTANT = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_ADAPTIVE_IMPORTANT 2097152
     * }
     */
    public static int PROC_FLAG_ADAPTIVE_IMPORTANT() {
        return PROC_FLAG_ADAPTIVE_IMPORTANT;
    }
    private static final int PROC_FLAG_IMPORTANCE_DONOR = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_IMPORTANCE_DONOR 4194304
     * }
     */
    public static int PROC_FLAG_IMPORTANCE_DONOR() {
        return PROC_FLAG_IMPORTANCE_DONOR;
    }
    private static final int PROC_FLAG_SUPPRESSED = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_SUPPRESSED 8388608
     * }
     */
    public static int PROC_FLAG_SUPPRESSED() {
        return PROC_FLAG_SUPPRESSED;
    }
    private static final int PROC_FLAG_APPLICATION = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_APPLICATION 16777216
     * }
     */
    public static int PROC_FLAG_APPLICATION() {
        return PROC_FLAG_APPLICATION;
    }
    private static final int TASK_KERNEL_PORT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_KERNEL_PORT 1
     * }
     */
    public static int TASK_KERNEL_PORT() {
        return TASK_KERNEL_PORT;
    }
    private static final int TASK_HOST_PORT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TASK_HOST_PORT 2
     * }
     */
    public static int TASK_HOST_PORT() {
        return TASK_HOST_PORT;
    }
    private static final int TASK_NAME_PORT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define TASK_NAME_PORT 3
     * }
     */
    public static int TASK_NAME_PORT() {
        return TASK_NAME_PORT;
    }
    private static final int TASK_BOOTSTRAP_PORT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TASK_BOOTSTRAP_PORT 4
     * }
     */
    public static int TASK_BOOTSTRAP_PORT() {
        return TASK_BOOTSTRAP_PORT;
    }
    private static final int TASK_INSPECT_PORT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define TASK_INSPECT_PORT 5
     * }
     */
    public static int TASK_INSPECT_PORT() {
        return TASK_INSPECT_PORT;
    }
    private static final int TASK_READ_PORT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define TASK_READ_PORT 6
     * }
     */
    public static int TASK_READ_PORT() {
        return TASK_READ_PORT;
    }
    private static final int TASK_ACCESS_PORT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define TASK_ACCESS_PORT 9
     * }
     */
    public static int TASK_ACCESS_PORT() {
        return TASK_ACCESS_PORT;
    }
    private static final int TASK_DEBUG_CONTROL_PORT = (int)10L;
    /**
     * {@snippet lang=c :
     * #define TASK_DEBUG_CONTROL_PORT 10
     * }
     */
    public static int TASK_DEBUG_CONTROL_PORT() {
        return TASK_DEBUG_CONTROL_PORT;
    }
    private static final int TASK_RESOURCE_NOTIFY_PORT = (int)11L;
    /**
     * {@snippet lang=c :
     * #define TASK_RESOURCE_NOTIFY_PORT 11
     * }
     */
    public static int TASK_RESOURCE_NOTIFY_PORT() {
        return TASK_RESOURCE_NOTIFY_PORT;
    }
    private static final int THREAD_BASIC_INFO = (int)3L;
    /**
     * {@snippet lang=c :
     * #define THREAD_BASIC_INFO 3
     * }
     */
    public static int THREAD_BASIC_INFO() {
        return THREAD_BASIC_INFO;
    }
    private static final int THREAD_IDENTIFIER_INFO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define THREAD_IDENTIFIER_INFO 4
     * }
     */
    public static int THREAD_IDENTIFIER_INFO() {
        return THREAD_IDENTIFIER_INFO;
    }
    private static final int TH_USAGE_SCALE = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define TH_USAGE_SCALE 1000
     * }
     */
    public static int TH_USAGE_SCALE() {
        return TH_USAGE_SCALE;
    }
    private static final int TH_STATE_RUNNING = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_RUNNING 1
     * }
     */
    public static int TH_STATE_RUNNING() {
        return TH_STATE_RUNNING;
    }
    private static final int TH_STATE_STOPPED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_STOPPED 2
     * }
     */
    public static int TH_STATE_STOPPED() {
        return TH_STATE_STOPPED;
    }
    private static final int TH_STATE_WAITING = (int)3L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_WAITING 3
     * }
     */
    public static int TH_STATE_WAITING() {
        return TH_STATE_WAITING;
    }
    private static final int TH_STATE_UNINTERRUPTIBLE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_UNINTERRUPTIBLE 4
     * }
     */
    public static int TH_STATE_UNINTERRUPTIBLE() {
        return TH_STATE_UNINTERRUPTIBLE;
    }
    private static final int TH_STATE_HALTED = (int)5L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_HALTED 5
     * }
     */
    public static int TH_STATE_HALTED() {
        return TH_STATE_HALTED;
    }
    private static final int TH_FLAGS_SWAPPED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TH_FLAGS_SWAPPED 1
     * }
     */
    public static int TH_FLAGS_SWAPPED() {
        return TH_FLAGS_SWAPPED;
    }
    private static final int TH_FLAGS_IDLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TH_FLAGS_IDLE 2
     * }
     */
    public static int TH_FLAGS_IDLE() {
        return TH_FLAGS_IDLE;
    }
    private static final int TH_FLAGS_GLOBAL_FORCED_IDLE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TH_FLAGS_GLOBAL_FORCED_IDLE 4
     * }
     */
    public static int TH_FLAGS_GLOBAL_FORCED_IDLE() {
        return TH_FLAGS_GLOBAL_FORCED_IDLE;
    }
    private static final int THREAD_EXTENDED_INFO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define THREAD_EXTENDED_INFO 5
     * }
     */
    public static int THREAD_EXTENDED_INFO() {
        return THREAD_EXTENDED_INFO;
    }
    private static final int MAXTHREADNAMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define MAXTHREADNAMESIZE 64
     * }
     */
    public static int MAXTHREADNAMESIZE() {
        return MAXTHREADNAMESIZE;
    }
    private static final int THREAD_DEBUG_INFO_INTERNAL = (int)6L;
    /**
     * {@snippet lang=c :
     * #define THREAD_DEBUG_INFO_INTERNAL 6
     * }
     */
    public static int THREAD_DEBUG_INFO_INTERNAL() {
        return THREAD_DEBUG_INFO_INTERNAL;
    }
    private static final int IO_NUM_PRIORITIES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IO_NUM_PRIORITIES 4
     * }
     */
    public static int IO_NUM_PRIORITIES() {
        return IO_NUM_PRIORITIES;
    }
    private static final int THREAD_SCHED_TIMESHARE_INFO = (int)10L;
    /**
     * {@snippet lang=c :
     * #define THREAD_SCHED_TIMESHARE_INFO 10
     * }
     */
    public static int THREAD_SCHED_TIMESHARE_INFO() {
        return THREAD_SCHED_TIMESHARE_INFO;
    }
    private static final int THREAD_SCHED_RR_INFO = (int)11L;
    /**
     * {@snippet lang=c :
     * #define THREAD_SCHED_RR_INFO 11
     * }
     */
    public static int THREAD_SCHED_RR_INFO() {
        return THREAD_SCHED_RR_INFO;
    }
    private static final int THREAD_SCHED_FIFO_INFO = (int)12L;
    /**
     * {@snippet lang=c :
     * #define THREAD_SCHED_FIFO_INFO 12
     * }
     */
    public static int THREAD_SCHED_FIFO_INFO() {
        return THREAD_SCHED_FIFO_INFO;
    }
    private static final int THREAD_STANDARD_POLICY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STANDARD_POLICY 1
     * }
     */
    public static int THREAD_STANDARD_POLICY() {
        return THREAD_STANDARD_POLICY;
    }
    private static final int THREAD_STANDARD_POLICY_COUNT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STANDARD_POLICY_COUNT 0
     * }
     */
    public static int THREAD_STANDARD_POLICY_COUNT() {
        return THREAD_STANDARD_POLICY_COUNT;
    }
    private static final int THREAD_EXTENDED_POLICY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_EXTENDED_POLICY 1
     * }
     */
    public static int THREAD_EXTENDED_POLICY() {
        return THREAD_EXTENDED_POLICY;
    }
    private static final int THREAD_TIME_CONSTRAINT_POLICY = (int)2L;
    /**
     * {@snippet lang=c :
     * #define THREAD_TIME_CONSTRAINT_POLICY 2
     * }
     */
    public static int THREAD_TIME_CONSTRAINT_POLICY() {
        return THREAD_TIME_CONSTRAINT_POLICY;
    }
    private static final int THREAD_PRECEDENCE_POLICY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define THREAD_PRECEDENCE_POLICY 3
     * }
     */
    public static int THREAD_PRECEDENCE_POLICY() {
        return THREAD_PRECEDENCE_POLICY;
    }
    private static final int THREAD_AFFINITY_POLICY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define THREAD_AFFINITY_POLICY 4
     * }
     */
    public static int THREAD_AFFINITY_POLICY() {
        return THREAD_AFFINITY_POLICY;
    }
    private static final int THREAD_AFFINITY_TAG_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define THREAD_AFFINITY_TAG_NULL 0
     * }
     */
    public static int THREAD_AFFINITY_TAG_NULL() {
        return THREAD_AFFINITY_TAG_NULL;
    }
    private static final int THREAD_BACKGROUND_POLICY = (int)5L;
    /**
     * {@snippet lang=c :
     * #define THREAD_BACKGROUND_POLICY 5
     * }
     */
    public static int THREAD_BACKGROUND_POLICY() {
        return THREAD_BACKGROUND_POLICY;
    }
    private static final int THREAD_BACKGROUND_POLICY_DARWIN_BG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define THREAD_BACKGROUND_POLICY_DARWIN_BG 4096
     * }
     */
    public static int THREAD_BACKGROUND_POLICY_DARWIN_BG() {
        return THREAD_BACKGROUND_POLICY_DARWIN_BG;
    }
    private static final int THREAD_LATENCY_QOS_POLICY = (int)7L;
    /**
     * {@snippet lang=c :
     * #define THREAD_LATENCY_QOS_POLICY 7
     * }
     */
    public static int THREAD_LATENCY_QOS_POLICY() {
        return THREAD_LATENCY_QOS_POLICY;
    }
    private static final int THREAD_THROUGHPUT_QOS_POLICY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define THREAD_THROUGHPUT_QOS_POLICY 8
     * }
     */
    public static int THREAD_THROUGHPUT_QOS_POLICY() {
        return THREAD_THROUGHPUT_QOS_POLICY;
    }
    private static final int THREAD_KERNEL_PORT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_KERNEL_PORT 1
     * }
     */
    public static int THREAD_KERNEL_PORT() {
        return THREAD_KERNEL_PORT;
    }
    private static final int THREAD_INSPECT_PORT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define THREAD_INSPECT_PORT 2
     * }
     */
    public static int THREAD_INSPECT_PORT() {
        return THREAD_INSPECT_PORT;
    }
    private static final int THREAD_READ_PORT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define THREAD_READ_PORT 3
     * }
     */
    public static int THREAD_READ_PORT() {
        return THREAD_READ_PORT;
    }
    private static final int MATTR_CACHE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATTR_CACHE 1
     * }
     */
    public static int MATTR_CACHE() {
        return MATTR_CACHE;
    }
    private static final int MATTR_MIGRATE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MATTR_MIGRATE 2
     * }
     */
    public static int MATTR_MIGRATE() {
        return MATTR_MIGRATE;
    }
    private static final int MATTR_REPLICATE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MATTR_REPLICATE 4
     * }
     */
    public static int MATTR_REPLICATE() {
        return MATTR_REPLICATE;
    }
    private static final int MATTR_VAL_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_OFF 0
     * }
     */
    public static int MATTR_VAL_OFF() {
        return MATTR_VAL_OFF;
    }
    private static final int MATTR_VAL_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_ON 1
     * }
     */
    public static int MATTR_VAL_ON() {
        return MATTR_VAL_ON;
    }
    private static final int MATTR_VAL_GET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_GET 2
     * }
     */
    public static int MATTR_VAL_GET() {
        return MATTR_VAL_GET;
    }
    private static final int MATTR_VAL_CACHE_FLUSH = (int)6L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_CACHE_FLUSH 6
     * }
     */
    public static int MATTR_VAL_CACHE_FLUSH() {
        return MATTR_VAL_CACHE_FLUSH;
    }
    private static final int MATTR_VAL_DCACHE_FLUSH = (int)7L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_DCACHE_FLUSH 7
     * }
     */
    public static int MATTR_VAL_DCACHE_FLUSH() {
        return MATTR_VAL_DCACHE_FLUSH;
    }
    private static final int MATTR_VAL_ICACHE_FLUSH = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_ICACHE_FLUSH 8
     * }
     */
    public static int MATTR_VAL_ICACHE_FLUSH() {
        return MATTR_VAL_ICACHE_FLUSH;
    }
    private static final int MATTR_VAL_CACHE_SYNC = (int)9L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_CACHE_SYNC 9
     * }
     */
    public static int MATTR_VAL_CACHE_SYNC() {
        return MATTR_VAL_CACHE_SYNC;
    }
    private static final int MATTR_VAL_GET_INFO = (int)10L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_GET_INFO 10
     * }
     */
    public static int MATTR_VAL_GET_INFO() {
        return MATTR_VAL_GET_INFO;
    }
    private static final int VM_PURGABLE_NO_AGING_SHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_NO_AGING_SHIFT 16
     * }
     */
    public static int VM_PURGABLE_NO_AGING_SHIFT() {
        return VM_PURGABLE_NO_AGING_SHIFT;
    }
    private static final int VM_PURGABLE_DEBUG_SHIFT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_DEBUG_SHIFT 12
     * }
     */
    public static int VM_PURGABLE_DEBUG_SHIFT() {
        return VM_PURGABLE_DEBUG_SHIFT;
    }
    private static final int VM_VOLATILE_GROUP_SHIFT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_SHIFT 8
     * }
     */
    public static int VM_VOLATILE_GROUP_SHIFT() {
        return VM_VOLATILE_GROUP_SHIFT;
    }
    private static final int VM_PURGABLE_BEHAVIOR_SHIFT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_BEHAVIOR_SHIFT 6
     * }
     */
    public static int VM_PURGABLE_BEHAVIOR_SHIFT() {
        return VM_PURGABLE_BEHAVIOR_SHIFT;
    }
    private static final int VM_PURGABLE_ORDERING_SHIFT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_ORDERING_SHIFT 5
     * }
     */
    public static int VM_PURGABLE_ORDERING_SHIFT() {
        return VM_PURGABLE_ORDERING_SHIFT;
    }
    private static final int VM_VOLATILE_ORDER_SHIFT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_ORDER_SHIFT 4
     * }
     */
    public static int VM_VOLATILE_ORDER_SHIFT() {
        return VM_VOLATILE_ORDER_SHIFT;
    }
    private static final int VM_PURGABLE_STATE_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_STATE_MIN 0
     * }
     */
    public static int VM_PURGABLE_STATE_MIN() {
        return VM_PURGABLE_STATE_MIN;
    }
    private static final int VM_PURGABLE_STATE_MAX = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_STATE_MAX 3
     * }
     */
    public static int VM_PURGABLE_STATE_MAX() {
        return VM_PURGABLE_STATE_MAX;
    }
    private static final int VM_PURGABLE_STATE_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_STATE_MASK 3
     * }
     */
    public static int VM_PURGABLE_STATE_MASK() {
        return VM_PURGABLE_STATE_MASK;
    }
    private static final int VM_PURGABLE_NONVOLATILE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_NONVOLATILE 0
     * }
     */
    public static int VM_PURGABLE_NONVOLATILE() {
        return VM_PURGABLE_NONVOLATILE;
    }
    private static final int VM_PURGABLE_VOLATILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_VOLATILE 1
     * }
     */
    public static int VM_PURGABLE_VOLATILE() {
        return VM_PURGABLE_VOLATILE;
    }
    private static final int VM_PURGABLE_EMPTY = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_EMPTY 2
     * }
     */
    public static int VM_PURGABLE_EMPTY() {
        return VM_PURGABLE_EMPTY;
    }
    private static final int VM_PURGABLE_DENY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_DENY 3
     * }
     */
    public static int VM_PURGABLE_DENY() {
        return VM_PURGABLE_DENY;
    }
    private static final int VM_REGION_BASIC_INFO_64 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_BASIC_INFO_64 9
     * }
     */
    public static int VM_REGION_BASIC_INFO_64() {
        return VM_REGION_BASIC_INFO_64;
    }
    private static final int VM_REGION_BASIC_INFO = (int)10L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_BASIC_INFO 10
     * }
     */
    public static int VM_REGION_BASIC_INFO() {
        return VM_REGION_BASIC_INFO;
    }
    private static final int SM_COW = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SM_COW 1
     * }
     */
    public static int SM_COW() {
        return SM_COW;
    }
    private static final int SM_PRIVATE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SM_PRIVATE 2
     * }
     */
    public static int SM_PRIVATE() {
        return SM_PRIVATE;
    }
    private static final int SM_EMPTY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SM_EMPTY 3
     * }
     */
    public static int SM_EMPTY() {
        return SM_EMPTY;
    }
    private static final int SM_SHARED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SM_SHARED 4
     * }
     */
    public static int SM_SHARED() {
        return SM_SHARED;
    }
    private static final int SM_TRUESHARED = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SM_TRUESHARED 5
     * }
     */
    public static int SM_TRUESHARED() {
        return SM_TRUESHARED;
    }
    private static final int SM_PRIVATE_ALIASED = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SM_PRIVATE_ALIASED 6
     * }
     */
    public static int SM_PRIVATE_ALIASED() {
        return SM_PRIVATE_ALIASED;
    }
    private static final int SM_SHARED_ALIASED = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SM_SHARED_ALIASED 7
     * }
     */
    public static int SM_SHARED_ALIASED() {
        return SM_SHARED_ALIASED;
    }
    private static final int SM_LARGE_PAGE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SM_LARGE_PAGE 8
     * }
     */
    public static int SM_LARGE_PAGE() {
        return SM_LARGE_PAGE;
    }
    private static final int VM_REGION_EXTENDED_INFO = (int)13L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_EXTENDED_INFO 13
     * }
     */
    public static int VM_REGION_EXTENDED_INFO() {
        return VM_REGION_EXTENDED_INFO;
    }
    private static final int VM_REGION_TOP_INFO = (int)12L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_TOP_INFO 12
     * }
     */
    public static int VM_REGION_TOP_INFO() {
        return VM_REGION_TOP_INFO;
    }
    private static final int VM_PAGE_INFO_BASIC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_INFO_BASIC 1
     * }
     */
    public static int VM_PAGE_INFO_BASIC() {
        return VM_PAGE_INFO_BASIC;
    }
    private static final int API_TO_BE_DEPRECATED = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED() {
        return API_TO_BE_DEPRECATED;
    }
    private static final int API_TO_BE_DEPRECATED_MACOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_MACOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_MACOS() {
        return API_TO_BE_DEPRECATED_MACOS;
    }
    private static final int API_TO_BE_DEPRECATED_IOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_IOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_IOS() {
        return API_TO_BE_DEPRECATED_IOS;
    }
    private static final int API_TO_BE_DEPRECATED_TVOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_TVOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_TVOS() {
        return API_TO_BE_DEPRECATED_TVOS;
    }
    private static final int API_TO_BE_DEPRECATED_WATCHOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_WATCHOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_WATCHOS() {
        return API_TO_BE_DEPRECATED_WATCHOS;
    }
    private static final int API_TO_BE_DEPRECATED_DRIVERKIT = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_DRIVERKIT 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_DRIVERKIT() {
        return API_TO_BE_DEPRECATED_DRIVERKIT;
    }
    private static final int API_TO_BE_DEPRECATED_VISIONOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_VISIONOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_VISIONOS() {
        return API_TO_BE_DEPRECATED_VISIONOS;
    }
    private static final int MALLOC_PTR_IN_USE_RANGE_TYPE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MALLOC_PTR_IN_USE_RANGE_TYPE 1
     * }
     */
    public static int MALLOC_PTR_IN_USE_RANGE_TYPE() {
        return MALLOC_PTR_IN_USE_RANGE_TYPE;
    }
    private static final int MALLOC_PTR_REGION_RANGE_TYPE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MALLOC_PTR_REGION_RANGE_TYPE 2
     * }
     */
    public static int MALLOC_PTR_REGION_RANGE_TYPE() {
        return MALLOC_PTR_REGION_RANGE_TYPE;
    }
    private static final int MALLOC_ADMIN_REGION_RANGE_TYPE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MALLOC_ADMIN_REGION_RANGE_TYPE 4
     * }
     */
    public static int MALLOC_ADMIN_REGION_RANGE_TYPE() {
        return MALLOC_ADMIN_REGION_RANGE_TYPE;
    }
    private static final int MALLOC_ZONE_SPECIFIC_FLAGS = (int)65280L;
    /**
     * {@snippet lang=c :
     * #define MALLOC_ZONE_SPECIFIC_FLAGS 65280
     * }
     */
    public static int MALLOC_ZONE_SPECIFIC_FLAGS() {
        return MALLOC_ZONE_SPECIFIC_FLAGS;
    }
    private static final int MALLOC_VERBOSE_PRINT_LEVEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MALLOC_VERBOSE_PRINT_LEVEL 2
     * }
     */
    public static int MALLOC_VERBOSE_PRINT_LEVEL() {
        return MALLOC_VERBOSE_PRINT_LEVEL;
    }
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = ObjCRuntime.C_POINTER;
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = ObjCRuntime.C_INT;

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t rlim_t
     * }
     */
    public static final OfLong rlim_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *rusage_info_t
     * }
     */
    public static final AddressLayout rusage_info_t = ObjCRuntime.C_POINTER;

    private static class getpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static FunctionDescriptor getpriority$descriptor() {
        return getpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MethodHandle getpriority$handle() {
        return getpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MemorySegment getpriority$address() {
        return getpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static int getpriority(int x0, int x1) {
        var mh$ = getpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpriority", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static FunctionDescriptor getiopolicy_np$descriptor() {
        return getiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MethodHandle getiopolicy_np$handle() {
        return getiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MemorySegment getiopolicy_np$address() {
        return getiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static int getiopolicy_np(int x0, int x1) {
        var mh$ = getiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getiopolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static FunctionDescriptor getrlimit$descriptor() {
        return getrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MethodHandle getrlimit$handle() {
        return getrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MemorySegment getrlimit$address() {
        return getrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static int getrlimit(int x0, MemorySegment x1) {
        var mh$ = getrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrusage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getrusage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static FunctionDescriptor getrusage$descriptor() {
        return getrusage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MethodHandle getrusage$handle() {
        return getrusage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MemorySegment getrusage$address() {
        return getrusage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static int getrusage(int x0, MemorySegment x1) {
        var mh$ = getrusage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrusage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static FunctionDescriptor setpriority$descriptor() {
        return setpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MethodHandle setpriority$handle() {
        return setpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MemorySegment setpriority$address() {
        return setpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static int setpriority(int x0, int x1, int x2) {
        var mh$ = setpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpriority", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static FunctionDescriptor setiopolicy_np$descriptor() {
        return setiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MethodHandle setiopolicy_np$handle() {
        return setiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MemorySegment setiopolicy_np$address() {
        return setiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static int setiopolicy_np(int x0, int x1, int x2) {
        var mh$ = setiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setiopolicy_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static FunctionDescriptor setrlimit$descriptor() {
        return setrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MethodHandle setrlimit$handle() {
        return setrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MemorySegment setrlimit$address() {
        return setrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static int setrlimit(int x0, MemorySegment x1) {
        var mh$ = setrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static int waitpid(int x0, MemorySegment x1, int x2) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static int waitid(int x0, int x1, MemorySegment x2, int x3) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static int wait3(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static int wait4(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca(long x0) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ct_rune_t ct_rune_t
     * }
     */
    public static final OfInt ct_rune_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_rune_t rune_t
     * }
     */
    public static final OfInt rune_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t wchar_t
     * }
     */
    public static final OfInt wchar_t = ObjCRuntime.C_INT;

    private static class __mb_cur_max$constants {
        public static final OfInt LAYOUT = ObjCRuntime.C_INT;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("__mb_cur_max").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static OfInt __mb_cur_max$layout() {
        return __mb_cur_max$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static MemorySegment __mb_cur_max$segment() {
        return __mb_cur_max$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static int __mb_cur_max() {
        return __mb_cur_max$constants.SEGMENT.get(__mb_cur_max$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static void __mb_cur_max(int varValue) {
        __mb_cur_max$constants.SEGMENT.set(__mb_cur_max$constants.LAYOUT, 0L, varValue);
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __count, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __count, __size);
            }
            return (MemorySegment)mh$.invokeExact(__count, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static void free(MemorySegment x0) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("reallocf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocf$descriptor() {
        return reallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle reallocf$handle() {
        return reallocf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf$address() {
        return reallocf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf(MemorySegment __ptr, long __size) {
        var mh$ = reallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocf", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static int abs(int x0) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment x0) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static double atof(MemorySegment x0) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static int atoi(MemorySegment x0) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static long atol(MemorySegment x0) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static long atoll(MemorySegment x0) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int x0, int x1) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static void exit(int x0) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv(MemorySegment x0) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static long labs(long x0) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static long llabs(long x0) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static long mbstowcs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static int mbtowc(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void qsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static void quick_exit(int x0) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static void srand(int x0) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static double strtod(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_FLOAT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static float strtof(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static int system(MemorySegment x0) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static long wcstombs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static int wctomb(MemorySegment x0, int x1) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static long a64l(MemorySegment x0) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static double erand48(MemorySegment x0) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt(double x0, int x1, MemorySegment x2) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class grantpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("grantpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static FunctionDescriptor grantpt$descriptor() {
        return grantpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MethodHandle grantpt$handle() {
        return grantpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MemorySegment grantpt$address() {
        return grantpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static int grantpt(int x0) {
        var mh$ = grantpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("grantpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate(int x0, MemorySegment x1, long x2) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static long jrand48(MemorySegment x0) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a(long x0) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static void lcong48(MemorySegment x0) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static long nrand48(MemorySegment x0) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_openpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("posix_openpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static FunctionDescriptor posix_openpt$descriptor() {
        return posix_openpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MethodHandle posix_openpt$handle() {
        return posix_openpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MemorySegment posix_openpt$address() {
        return posix_openpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static int posix_openpt(int x0) {
        var mh$ = posix_openpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_openpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ptsname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static FunctionDescriptor ptsname$descriptor() {
        return ptsname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MethodHandle ptsname$handle() {
        return ptsname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname$address() {
        return ptsname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname(int x0) {
        var mh$ = ptsname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ptsname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static FunctionDescriptor ptsname_r$descriptor() {
        return ptsname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MethodHandle ptsname_r$handle() {
        return ptsname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MemorySegment ptsname_r$address() {
        return ptsname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static int ptsname_r(int fildes, MemorySegment buffer, long buflen) {
        var mh$ = ptsname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname_r", fildes, buffer, buflen);
            }
            return (int)mh$.invokeExact(fildes, buffer, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static int putenv(MemorySegment x0) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static int rand_r(MemorySegment x0) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("realpath$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath(MemorySegment x0, MemorySegment x1) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48(MemorySegment x0) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __overwrite) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __overwrite);
            }
            return (int)mh$.invokeExact(__name, __value, __overwrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate(MemorySegment x0) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static void srand48(long x0) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static void srandom(int x0) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlockpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("unlockpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static FunctionDescriptor unlockpt$descriptor() {
        return unlockpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MethodHandle unlockpt$handle() {
        return unlockpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MemorySegment unlockpt$address() {
        return unlockpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static int unlockpt(int x0) {
        var mh$ = unlockpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlockpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static int unsetenv(MemorySegment x0) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = ObjCRuntime.C_SHORT;

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_addrandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_addrandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static FunctionDescriptor arc4random_addrandom$descriptor() {
        return arc4random_addrandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MethodHandle arc4random_addrandom$handle() {
        return arc4random_addrandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MemorySegment arc4random_addrandom$address() {
        return arc4random_addrandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static void arc4random_addrandom(MemorySegment x0, int x1) {
        var mh$ = arc4random_addrandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_addrandom", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __nbytes) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __nbytes);
            }
            mh$.invokeExact(__buf, __nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_stir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_stir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static FunctionDescriptor arc4random_stir$descriptor() {
        return arc4random_stir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MethodHandle arc4random_stir$handle() {
        return arc4random_stir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MemorySegment arc4random_stir$address() {
        return arc4random_stir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static void arc4random_stir() {
        var mh$ = arc4random_stir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_stir");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atexit_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit_b$descriptor() {
        return atexit_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit_b$handle() {
        return atexit_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit_b$address() {
        return atexit_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static int atexit_b(MemorySegment x0) {
        var mh$ = atexit_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit_b", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("bsearch_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch_b$descriptor() {
        return bsearch_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch_b$handle() {
        return bsearch_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b$address() {
        return bsearch_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_b", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetcap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetcap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static FunctionDescriptor cgetcap$descriptor() {
        return cgetcap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MethodHandle cgetcap$handle() {
        return cgetcap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap$address() {
        return cgetcap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = cgetcap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetcap", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static FunctionDescriptor cgetclose$descriptor() {
        return cgetclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MethodHandle cgetclose$handle() {
        return cgetclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MemorySegment cgetclose$address() {
        return cgetclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static int cgetclose() {
        var mh$ = cgetclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetclose");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static FunctionDescriptor cgetent$descriptor() {
        return cgetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MethodHandle cgetent$handle() {
        return cgetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MemorySegment cgetent$address() {
        return cgetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static int cgetent(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetent", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetfirst$descriptor() {
        return cgetfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MethodHandle cgetfirst$handle() {
        return cgetfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MemorySegment cgetfirst$address() {
        return cgetfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static int cgetfirst(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetfirst", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static FunctionDescriptor cgetmatch$descriptor() {
        return cgetmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MethodHandle cgetmatch$handle() {
        return cgetmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MemorySegment cgetmatch$address() {
        return cgetmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static int cgetmatch(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetmatch", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetnext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetnext$descriptor() {
        return cgetnext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MethodHandle cgetnext$handle() {
        return cgetnext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MemorySegment cgetnext$address() {
        return cgetnext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static int cgetnext(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetnext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor cgetnum$descriptor() {
        return cgetnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MethodHandle cgetnum$handle() {
        return cgetnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MemorySegment cgetnum$address() {
        return cgetnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static int cgetnum(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnum", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static FunctionDescriptor cgetset$descriptor() {
        return cgetset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MethodHandle cgetset$handle() {
        return cgetset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MemorySegment cgetset$address() {
        return cgetset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static int cgetset(MemorySegment x0) {
        var mh$ = cgetset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetstr$descriptor() {
        return cgetstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetstr$handle() {
        return cgetstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetstr$address() {
        return cgetstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static int cgetstr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetstr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetustr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetustr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetustr$descriptor() {
        return cgetustr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetustr$handle() {
        return cgetustr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetustr$address() {
        return cgetustr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static int cgetustr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetustr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetustr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static int daemon(int x0, int x1) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_SHORT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("devname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static FunctionDescriptor devname$descriptor() {
        return devname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MethodHandle devname$handle() {
        return devname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname$address() {
        return devname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname(int x0, short x1) {
        var mh$ = devname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_SHORT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("devname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static FunctionDescriptor devname_r$descriptor() {
        return devname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MethodHandle devname_r$handle() {
        return devname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r$address() {
        return devname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r(int x0, short x1, MemorySegment buf, int len) {
        var mh$ = devname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname_r", x0, x1, buf, len);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, buf, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getbsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static FunctionDescriptor getbsize$descriptor() {
        return getbsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MethodHandle getbsize$handle() {
        return getbsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize$address() {
        return getbsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = getbsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbsize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static int getloadavg(MemorySegment x0, int x1) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static FunctionDescriptor getprogname$descriptor() {
        return getprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MethodHandle getprogname$handle() {
        return getprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname$address() {
        return getprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname() {
        var mh$ = getprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprogname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static FunctionDescriptor setprogname$descriptor() {
        return setprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MethodHandle setprogname$handle() {
        return setprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MemorySegment setprogname$address() {
        return setprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static void setprogname(MemorySegment x0) {
        var mh$ = setprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprogname", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("heapsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort$descriptor() {
        return heapsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort$handle() {
        return heapsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort$address() {
        return heapsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int heapsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("heapsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort_b$descriptor() {
        return heapsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort_b$handle() {
        return heapsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort_b$address() {
        return heapsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int heapsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mergesort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort$descriptor() {
        return mergesort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort$handle() {
        return mergesort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort$address() {
        return mergesort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int mergesort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mergesort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort_b$descriptor() {
        return mergesort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort_b$handle() {
        return mergesort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort_b$address() {
        return mergesort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int mergesort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("psort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort$descriptor() {
        return psort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort$handle() {
        return psort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort$address() {
        return psort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void psort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("psort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_b$descriptor() {
        return psort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort_b$handle() {
        return psort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort_b$address() {
        return psort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void psort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("psort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_r$descriptor() {
        return psort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle psort_r$handle() {
        return psort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment psort_r$address() {
        return psort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void psort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = psort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("qsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_b$descriptor() {
        return qsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort_b$handle() {
        return qsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort_b$address() {
        return qsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void qsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("qsort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_r$descriptor() {
        return qsort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle qsort_r$handle() {
        return qsort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment qsort_r$address() {
        return qsort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void qsort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = qsort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class radixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("radixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor radixsort$descriptor() {
        return radixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle radixsort$handle() {
        return radixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment radixsort$address() {
        return radixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int radixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = radixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("radixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static int rpmatch(MemorySegment x0) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sradixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sradixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor sradixsort$descriptor() {
        return sradixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle sradixsort$handle() {
        return sradixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment sradixsort$address() {
        return sradixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int sradixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = sradixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sradixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sranddev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sranddev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static FunctionDescriptor sranddev$descriptor() {
        return sranddev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MethodHandle sranddev$handle() {
        return sranddev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MemorySegment sranddev$address() {
        return sranddev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static void sranddev() {
        var mh$ = sranddev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sranddev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandomdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srandomdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static FunctionDescriptor srandomdev$descriptor() {
        return srandomdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MethodHandle srandomdev$handle() {
        return srandomdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MemorySegment srandomdev$address() {
        return srandomdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static void srandomdev() {
        var mh$ = srandomdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandomdev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtonum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtonum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static FunctionDescriptor strtonum$descriptor() {
        return strtonum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MethodHandle strtonum$handle() {
        return strtonum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MemorySegment strtonum$address() {
        return strtonum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static long strtonum(MemorySegment __numstr, long __minval, long __maxval, MemorySegment __errstrp) {
        var mh$ = strtonum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtonum", __numstr, __minval, __maxval, __errstrp);
            }
            return (long)mh$.invokeExact(__numstr, __minval, __maxval, __errstrp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = ObjCRuntime.C_POINTER;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ptrdiff_t ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_char
     * }
     */
    public static final OfByte u_char = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_short
     * }
     */
    public static final OfShort u_short = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int
     * }
     */
    public static final OfInt u_int = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long u_long
     * }
     */
    public static final OfLong u_long = ObjCRuntime.C_LONG;
}

