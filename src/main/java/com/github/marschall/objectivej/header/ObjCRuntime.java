// Generated by jextract

package com.github.marschall.objectivej.header;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class ObjCRuntime {

    ObjCRuntime() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("objc"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int __has_ptrcheck = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_ptrcheck 0
     * }
     */
    public static int __has_ptrcheck() {
        return __has_ptrcheck;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int __DARWIN_LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_LITTLE_ENDIAN 1234
     * }
     */
    public static int __DARWIN_LITTLE_ENDIAN() {
        return __DARWIN_LITTLE_ENDIAN;
    }
    private static final int __DARWIN_BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BIG_ENDIAN 4321
     * }
     */
    public static int __DARWIN_BIG_ENDIAN() {
        return __DARWIN_BIG_ENDIAN;
    }
    private static final int __DARWIN_PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_PDP_ENDIAN 3412
     * }
     */
    public static int __DARWIN_PDP_ENDIAN() {
        return __DARWIN_PDP_ENDIAN;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int __DARWIN_FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_FD_SETSIZE 1024
     * }
     */
    public static int __DARWIN_FD_SETSIZE() {
        return __DARWIN_FD_SETSIZE;
    }
    private static final int __DARWIN_NBBY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NBBY 8
     * }
     */
    public static int __DARWIN_NBBY() {
        return __DARWIN_NBBY;
    }
    private static final int OBJC_API_VERSION = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OBJC_API_VERSION 0
     * }
     */
    public static int OBJC_API_VERSION() {
        return OBJC_API_VERSION;
    }
    private static final int OBJC_NO_GC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_NO_GC 1
     * }
     */
    public static int OBJC_NO_GC() {
        return OBJC_NO_GC;
    }
    private static final int OBJC_NO_GC_API = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_NO_GC_API 1
     * }
     */
    public static int OBJC_NO_GC_API() {
        return OBJC_NO_GC_API;
    }
    private static final int NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER 1
     * }
     */
    public static int NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER() {
        return NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER;
    }
    private static final int OBJC_OLD_DISPATCH_PROTOTYPES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OBJC_OLD_DISPATCH_PROTOTYPES 0
     * }
     */
    public static int OBJC_OLD_DISPATCH_PROTOTYPES() {
        return OBJC_OLD_DISPATCH_PROTOTYPES;
    }
    private static final int true_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define true 1
     * }
     */
    public static int true_() {
        return true_;
    }
    private static final int false_ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define false 0
     * }
     */
    public static int false_() {
        return false_;
    }
    private static final int __bool_true_false_are_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __bool_true_false_are_defined 1
     * }
     */
    public static int __bool_true_false_are_defined() {
        return __bool_true_false_are_defined;
    }
    private static final int OBJC_BOOL_IS_BOOL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_BOOL_IS_BOOL 1
     * }
     */
    public static int OBJC_BOOL_IS_BOOL() {
        return OBJC_BOOL_IS_BOOL;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int OBJC_GETCLASSHOOK_DEFINED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_GETCLASSHOOK_DEFINED 1
     * }
     */
    public static int OBJC_GETCLASSHOOK_DEFINED() {
        return OBJC_GETCLASSHOOK_DEFINED;
    }
    private static final int OBJC_ADDLOADIMAGEFUNC_DEFINED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_ADDLOADIMAGEFUNC_DEFINED 1
     * }
     */
    public static int OBJC_ADDLOADIMAGEFUNC_DEFINED() {
        return OBJC_ADDLOADIMAGEFUNC_DEFINED;
    }
    private static final int OBJC_SETHOOK_LAZYCLASSNAMER_DEFINED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_SETHOOK_LAZYCLASSNAMER_DEFINED 1
     * }
     */
    public static int OBJC_SETHOOK_LAZYCLASSNAMER_DEFINED() {
        return OBJC_SETHOOK_LAZYCLASSNAMER_DEFINED;
    }
    private static final int OBJC_REALIZECLASSFROMSWIFT_DEFINED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OBJC_REALIZECLASSFROMSWIFT_DEFINED 1
     * }
     */
    public static int OBJC_REALIZECLASSFROMSWIFT_DEFINED() {
        return OBJC_REALIZECLASSFROMSWIFT_DEFINED;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = ObjCRuntime.C_LONG;

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca(long x0) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __mb_cur_max$constants {
        public static final OfInt LAYOUT = ObjCRuntime.C_INT;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("__mb_cur_max").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static OfInt __mb_cur_max$layout() {
        return __mb_cur_max$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static MemorySegment __mb_cur_max$segment() {
        return __mb_cur_max$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static int __mb_cur_max() {
        return __mb_cur_max$constants.SEGMENT.get(__mb_cur_max$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static void __mb_cur_max(int varValue) {
        __mb_cur_max$constants.SEGMENT.set(__mb_cur_max$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long malloc_type_id_t
     * }
     */
    public static final OfLong malloc_type_id_t = ObjCRuntime.C_LONG_LONG;

    private static class malloc_type_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_malloc$descriptor() {
        return malloc_type_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_malloc$handle() {
        return malloc_type_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc$address() {
        return malloc_type_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc(long size, long type_id) {
        var mh$ = malloc_type_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_malloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_calloc$descriptor() {
        return malloc_type_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_calloc$handle() {
        return malloc_type_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc$address() {
        return malloc_type_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc(long count, long size, long type_id) {
        var mh$ = malloc_type_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_calloc", count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_free$descriptor() {
        return malloc_type_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_free$handle() {
        return malloc_type_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_free$address() {
        return malloc_type_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_free(MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_free", ptr, type_id);
            }
            mh$.invokeExact(ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_realloc$descriptor() {
        return malloc_type_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_realloc$handle() {
        return malloc_type_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc$address() {
        return malloc_type_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc(MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_realloc", ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_valloc$descriptor() {
        return malloc_type_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_valloc$handle() {
        return malloc_type_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc$address() {
        return malloc_type_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc(long size, long type_id) {
        var mh$ = malloc_type_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_valloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_aligned_alloc$descriptor() {
        return malloc_type_aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_aligned_alloc$handle() {
        return malloc_type_aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc$address() {
        return malloc_type_aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc(long alignment, long size, long type_id) {
        var mh$ = malloc_type_aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_aligned_alloc", alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_posix_memalign$descriptor() {
        return malloc_type_posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_posix_memalign$handle() {
        return malloc_type_posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_posix_memalign$address() {
        return malloc_type_posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static int malloc_type_posix_memalign(MemorySegment memptr, long alignment, long size, long type_id) {
        var mh$ = malloc_type_posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_posix_memalign", memptr, alignment, size, type_id);
            }
            return (int)mh$.invokeExact(memptr, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_zone_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_malloc$descriptor() {
        return malloc_type_zone_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_malloc$handle() {
        return malloc_type_zone_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc$address() {
        return malloc_type_zone_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_malloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_zone_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_calloc$descriptor() {
        return malloc_type_zone_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_calloc$handle() {
        return malloc_type_zone_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc$address() {
        return malloc_type_zone_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc(MemorySegment zone, long count, long size, long type_id) {
        var mh$ = malloc_type_zone_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_calloc", zone, count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_zone_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_free$descriptor() {
        return malloc_type_zone_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_free$handle() {
        return malloc_type_zone_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_free$address() {
        return malloc_type_zone_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_zone_free(MemorySegment zone, MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_zone_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_free", zone, ptr, type_id);
            }
            mh$.invokeExact(zone, ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_zone_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_realloc$descriptor() {
        return malloc_type_zone_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_realloc$handle() {
        return malloc_type_zone_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc$address() {
        return malloc_type_zone_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc(MemorySegment zone, MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_zone_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_realloc", zone, ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_zone_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_valloc$descriptor() {
        return malloc_type_zone_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_valloc$handle() {
        return malloc_type_zone_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc$address() {
        return malloc_type_zone_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_valloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_type_zone_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_memalign$descriptor() {
        return malloc_type_zone_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_memalign$handle() {
        return malloc_type_zone_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign$address() {
        return malloc_type_zone_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign(MemorySegment zone, long alignment, long size, long type_id) {
        var mh$ = malloc_type_zone_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_memalign", zone, alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __count, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __count, __size);
            }
            return (MemorySegment)mh$.invokeExact(__count, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static void free(MemorySegment x0) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("reallocf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocf$descriptor() {
        return reallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle reallocf$handle() {
        return reallocf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf$address() {
        return reallocf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf(MemorySegment __ptr, long __size) {
        var mh$ = reallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocf", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static int abs(int x0) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment x0) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static double atof(MemorySegment x0) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static int atoi(MemorySegment x0) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static long atol(MemorySegment x0) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static long atoll(MemorySegment x0) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int x0, int x1) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static void exit(int x0) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv(MemorySegment x0) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static long labs(long x0) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static long llabs(long x0) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static long mbstowcs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static int mbtowc(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void qsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static void quick_exit(int x0) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static void srand(int x0) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static double strtod(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_FLOAT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static float strtof(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static int system(MemorySegment x0) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static long wcstombs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static int wctomb(MemorySegment x0, int x1) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static long a64l(MemorySegment x0) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static double erand48(MemorySegment x0) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt(double x0, int x1, MemorySegment x2) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class grantpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("grantpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static FunctionDescriptor grantpt$descriptor() {
        return grantpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MethodHandle grantpt$handle() {
        return grantpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MemorySegment grantpt$address() {
        return grantpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static int grantpt(int x0) {
        var mh$ = grantpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("grantpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate(int x0, MemorySegment x1, long x2) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static long jrand48(MemorySegment x0) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a(long x0) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static void lcong48(MemorySegment x0) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static long nrand48(MemorySegment x0) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_openpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("posix_openpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static FunctionDescriptor posix_openpt$descriptor() {
        return posix_openpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MethodHandle posix_openpt$handle() {
        return posix_openpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MemorySegment posix_openpt$address() {
        return posix_openpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static int posix_openpt(int x0) {
        var mh$ = posix_openpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_openpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ptsname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static FunctionDescriptor ptsname$descriptor() {
        return ptsname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MethodHandle ptsname$handle() {
        return ptsname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname$address() {
        return ptsname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname(int x0) {
        var mh$ = ptsname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ptsname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static FunctionDescriptor ptsname_r$descriptor() {
        return ptsname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MethodHandle ptsname_r$handle() {
        return ptsname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MemorySegment ptsname_r$address() {
        return ptsname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static int ptsname_r(int fildes, MemorySegment buffer, long buflen) {
        var mh$ = ptsname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname_r", fildes, buffer, buflen);
            }
            return (int)mh$.invokeExact(fildes, buffer, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static int putenv(MemorySegment x0) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static int rand_r(MemorySegment x0) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("realpath$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath(MemorySegment x0, MemorySegment x1) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48(MemorySegment x0) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __overwrite) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __overwrite);
            }
            return (int)mh$.invokeExact(__name, __value, __overwrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate(MemorySegment x0) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static void srand48(long x0) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static void srandom(int x0) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlockpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("unlockpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static FunctionDescriptor unlockpt$descriptor() {
        return unlockpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MethodHandle unlockpt$handle() {
        return unlockpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MemorySegment unlockpt$address() {
        return unlockpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static int unlockpt(int x0) {
        var mh$ = unlockpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlockpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static int unsetenv(MemorySegment x0) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_addrandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_addrandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static FunctionDescriptor arc4random_addrandom$descriptor() {
        return arc4random_addrandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MethodHandle arc4random_addrandom$handle() {
        return arc4random_addrandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MemorySegment arc4random_addrandom$address() {
        return arc4random_addrandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static void arc4random_addrandom(MemorySegment x0, int x1) {
        var mh$ = arc4random_addrandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_addrandom", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __nbytes) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __nbytes);
            }
            mh$.invokeExact(__buf, __nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_stir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_stir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static FunctionDescriptor arc4random_stir$descriptor() {
        return arc4random_stir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MethodHandle arc4random_stir$handle() {
        return arc4random_stir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MemorySegment arc4random_stir$address() {
        return arc4random_stir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static void arc4random_stir() {
        var mh$ = arc4random_stir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_stir");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atexit_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit_b$descriptor() {
        return atexit_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit_b$handle() {
        return atexit_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit_b$address() {
        return atexit_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static int atexit_b(MemorySegment x0) {
        var mh$ = atexit_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit_b", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("bsearch_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch_b$descriptor() {
        return bsearch_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch_b$handle() {
        return bsearch_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b$address() {
        return bsearch_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_b", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetcap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetcap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static FunctionDescriptor cgetcap$descriptor() {
        return cgetcap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MethodHandle cgetcap$handle() {
        return cgetcap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap$address() {
        return cgetcap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = cgetcap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetcap", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static FunctionDescriptor cgetclose$descriptor() {
        return cgetclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MethodHandle cgetclose$handle() {
        return cgetclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MemorySegment cgetclose$address() {
        return cgetclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static int cgetclose() {
        var mh$ = cgetclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetclose");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static FunctionDescriptor cgetent$descriptor() {
        return cgetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MethodHandle cgetent$handle() {
        return cgetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MemorySegment cgetent$address() {
        return cgetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static int cgetent(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetent", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetfirst$descriptor() {
        return cgetfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MethodHandle cgetfirst$handle() {
        return cgetfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MemorySegment cgetfirst$address() {
        return cgetfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static int cgetfirst(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetfirst", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static FunctionDescriptor cgetmatch$descriptor() {
        return cgetmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MethodHandle cgetmatch$handle() {
        return cgetmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MemorySegment cgetmatch$address() {
        return cgetmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static int cgetmatch(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetmatch", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetnext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetnext$descriptor() {
        return cgetnext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MethodHandle cgetnext$handle() {
        return cgetnext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MemorySegment cgetnext$address() {
        return cgetnext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static int cgetnext(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetnext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor cgetnum$descriptor() {
        return cgetnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MethodHandle cgetnum$handle() {
        return cgetnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MemorySegment cgetnum$address() {
        return cgetnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static int cgetnum(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnum", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static FunctionDescriptor cgetset$descriptor() {
        return cgetset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MethodHandle cgetset$handle() {
        return cgetset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MemorySegment cgetset$address() {
        return cgetset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static int cgetset(MemorySegment x0) {
        var mh$ = cgetset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetstr$descriptor() {
        return cgetstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetstr$handle() {
        return cgetstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetstr$address() {
        return cgetstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static int cgetstr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetstr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetustr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetustr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetustr$descriptor() {
        return cgetustr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetustr$handle() {
        return cgetustr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetustr$address() {
        return cgetustr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static int cgetustr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetustr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetustr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static int daemon(int x0, int x1) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_SHORT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("devname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static FunctionDescriptor devname$descriptor() {
        return devname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MethodHandle devname$handle() {
        return devname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname$address() {
        return devname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname(int x0, short x1) {
        var mh$ = devname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_SHORT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("devname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static FunctionDescriptor devname_r$descriptor() {
        return devname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MethodHandle devname_r$handle() {
        return devname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r$address() {
        return devname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r(int x0, short x1, MemorySegment buf, int len) {
        var mh$ = devname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname_r", x0, x1, buf, len);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, buf, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getbsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static FunctionDescriptor getbsize$descriptor() {
        return getbsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MethodHandle getbsize$handle() {
        return getbsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize$address() {
        return getbsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = getbsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbsize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static int getloadavg(MemorySegment x0, int x1) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static FunctionDescriptor getprogname$descriptor() {
        return getprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MethodHandle getprogname$handle() {
        return getprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname$address() {
        return getprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname() {
        var mh$ = getprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprogname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static FunctionDescriptor setprogname$descriptor() {
        return setprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MethodHandle setprogname$handle() {
        return setprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MemorySegment setprogname$address() {
        return setprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static void setprogname(MemorySegment x0) {
        var mh$ = setprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprogname", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("heapsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort$descriptor() {
        return heapsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort$handle() {
        return heapsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort$address() {
        return heapsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int heapsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("heapsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort_b$descriptor() {
        return heapsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort_b$handle() {
        return heapsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort_b$address() {
        return heapsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int heapsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mergesort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort$descriptor() {
        return mergesort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort$handle() {
        return mergesort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort$address() {
        return mergesort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int mergesort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mergesort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort_b$descriptor() {
        return mergesort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort_b$handle() {
        return mergesort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort_b$address() {
        return mergesort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int mergesort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("psort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort$descriptor() {
        return psort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort$handle() {
        return psort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort$address() {
        return psort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void psort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("psort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_b$descriptor() {
        return psort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort_b$handle() {
        return psort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort_b$address() {
        return psort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void psort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("psort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_r$descriptor() {
        return psort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle psort_r$handle() {
        return psort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment psort_r$address() {
        return psort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void psort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = psort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("qsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_b$descriptor() {
        return qsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort_b$handle() {
        return qsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort_b$address() {
        return qsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void qsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("qsort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_r$descriptor() {
        return qsort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle qsort_r$handle() {
        return qsort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment qsort_r$address() {
        return qsort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void qsort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = qsort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class radixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("radixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor radixsort$descriptor() {
        return radixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle radixsort$handle() {
        return radixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment radixsort$address() {
        return radixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int radixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = radixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("radixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static int rpmatch(MemorySegment x0) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sradixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sradixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor sradixsort$descriptor() {
        return sradixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle sradixsort$handle() {
        return sradixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment sradixsort$address() {
        return sradixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int sradixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = sradixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sradixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sranddev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sranddev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static FunctionDescriptor sranddev$descriptor() {
        return sranddev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MethodHandle sranddev$handle() {
        return sranddev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MemorySegment sranddev$address() {
        return sranddev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static void sranddev() {
        var mh$ = sranddev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sranddev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandomdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srandomdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static FunctionDescriptor srandomdev$descriptor() {
        return srandomdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MethodHandle srandomdev$handle() {
        return srandomdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MemorySegment srandomdev$address() {
        return srandomdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static void srandomdev() {
        var mh$ = srandomdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandomdev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtonum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtonum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static FunctionDescriptor strtonum$descriptor() {
        return strtonum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MethodHandle strtonum$handle() {
        return strtonum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MemorySegment strtonum$address() {
        return strtonum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static long strtonum(MemorySegment __numstr, long __minval, long __maxval, MemorySegment __errstrp) {
        var mh$ = strtonum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtonum", __numstr, __minval, __maxval, __errstrp);
            }
            return (long)mh$.invokeExact(__numstr, __minval, __maxval, __errstrp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = ObjCRuntime.C_POINTER;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_char
     * }
     */
    public static final OfByte u_char = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_short
     * }
     */
    public static final OfShort u_short = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int
     * }
     */
    public static final OfInt u_int = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long u_long
     * }
     */
    public static final OfLong u_long = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t quad_t
     * }
     */
    public static final OfLong quad_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef quad_t *qaddr_t
     * }
     */
    public static final AddressLayout qaddr_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int32_t daddr_t
     * }
     */
    public static final OfInt daddr_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fixpt_t
     * }
     */
    public static final OfInt fixpt_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t segsz_t
     * }
     */
    public static final OfInt segsz_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t swblk_t
     * }
     */
    public static final OfInt swblk_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_time_t time_t
     * }
     */
    public static final OfLong time_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_suseconds_t suseconds_t
     * }
     */
    public static final OfInt suseconds_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = ObjCRuntime.C_INT;

    private static class __darwin_check_fd_set_overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("__darwin_check_fd_set_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static FunctionDescriptor __darwin_check_fd_set_overflow$descriptor() {
        return __darwin_check_fd_set_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MethodHandle __darwin_check_fd_set_overflow$handle() {
        return __darwin_check_fd_set_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MemorySegment __darwin_check_fd_set_overflow$address() {
        return __darwin_check_fd_set_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static int __darwin_check_fd_set_overflow(int x0, MemorySegment x1, int x2) {
        var mh$ = __darwin_check_fd_set_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__darwin_check_fd_set_overflow", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __int32_t fd_mask
     * }
     */
    public static final OfInt fd_mask = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct objc_class *Class
     * }
     */
    public static final AddressLayout Class_ = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_object {
     *     OBJC_ISA_AVAILABILITY Class isa;
     * } *id
     * }
     */
    public static final AddressLayout id = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_selector *SEL
     * }
     */
    public static final AddressLayout SEL = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef bool BOOL
     * }
     */
    public static final OfBoolean BOOL = ObjCRuntime.C_BOOL;
    /**
     * {@snippet lang=c :
     * typedef struct _malloc_zone_t *objc_zone_t
     * }
     */
    public static final AddressLayout objc_zone_t = ObjCRuntime.C_POINTER;

    private static class sel_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor sel_getName$descriptor() {
        return sel_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle sel_getName$handle() {
        return sel_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment sel_getName$address() {
        return sel_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment sel_getName(MemorySegment sel) {
        var mh$ = sel_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_getName", sel);
            }
            return (MemorySegment)mh$.invokeExact(sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_registerName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_registerName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static FunctionDescriptor sel_registerName$descriptor() {
        return sel_registerName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static MethodHandle sel_registerName$handle() {
        return sel_registerName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_registerName$address() {
        return sel_registerName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_registerName(MemorySegment str) {
        var mh$ = sel_registerName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_registerName", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getClassName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getClassName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_getClassName$descriptor() {
        return object_getClassName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_getClassName$handle() {
        return object_getClassName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClassName$address() {
        return object_getClassName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClassName(MemorySegment obj) {
        var mh$ = object_getClassName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getClassName", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getIndexedIvars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getIndexedIvars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_getIndexedIvars$descriptor() {
        return object_getIndexedIvars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_getIndexedIvars$handle() {
        return object_getIndexedIvars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getIndexedIvars$address() {
        return object_getIndexedIvars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getIndexedIvars(MemorySegment obj) {
        var mh$ = object_getIndexedIvars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getIndexedIvars", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_isMapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_isMapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor sel_isMapped$descriptor() {
        return sel_isMapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle sel_isMapped$handle() {
        return sel_isMapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment sel_isMapped$address() {
        return sel_isMapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static boolean sel_isMapped(MemorySegment sel) {
        var mh$ = sel_isMapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_isMapped", sel);
            }
            return (boolean)mh$.invokeExact(sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_getUid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_getUid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static FunctionDescriptor sel_getUid$descriptor() {
        return sel_getUid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static MethodHandle sel_getUid$handle() {
        return sel_getUid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_getUid$address() {
        return sel_getUid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_getUid(MemorySegment str) {
        var mh$ = sel_getUid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_getUid", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef const void *objc_objectptr_t
     * }
     */
    public static final AddressLayout objc_objectptr_t = ObjCRuntime.C_POINTER;

    private static class objc_retainedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_retainedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_retainedObject$descriptor() {
        return objc_retainedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MethodHandle objc_retainedObject$handle() {
        return objc_retainedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_retainedObject$address() {
        return objc_retainedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_retainedObject(MemorySegment obj) {
        var mh$ = objc_retainedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_retainedObject", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_unretainedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_unretainedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_unretainedObject$descriptor() {
        return objc_unretainedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MethodHandle objc_unretainedObject$handle() {
        return objc_unretainedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedObject$address() {
        return objc_unretainedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedObject(MemorySegment obj) {
        var mh$ = objc_unretainedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_unretainedObject", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_unretainedPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_unretainedPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_unretainedPointer$descriptor() {
        return objc_unretainedPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static MethodHandle objc_unretainedPointer$handle() {
        return objc_unretainedPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedPointer$address() {
        return objc_unretainedPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedPointer(MemorySegment obj) {
        var mh$ = objc_unretainedPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_unretainedPointer", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_method *Method
     * }
     */
    public static final AddressLayout Method = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_ivar *Ivar
     * }
     */
    public static final AddressLayout Ivar = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_category *Category
     * }
     */
    public static final AddressLayout Category = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_property *objc_property_t
     * }
     */
    public static final AddressLayout objc_property_t = ObjCRuntime.C_POINTER;

    private static class object_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static FunctionDescriptor object_copy$descriptor() {
        return object_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static MethodHandle object_copy$handle() {
        return object_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static MemorySegment object_copy$address() {
        return object_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static MemorySegment object_copy(MemorySegment obj, long size) {
        var mh$ = object_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_copy", obj, size);
            }
            return (MemorySegment)mh$.invokeExact(obj, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_dispose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_dispose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_dispose$descriptor() {
        return object_dispose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_dispose$handle() {
        return object_dispose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_dispose$address() {
        return object_dispose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_dispose(MemorySegment obj) {
        var mh$ = object_dispose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_dispose", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_getClass$descriptor() {
        return object_getClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_getClass$handle() {
        return object_getClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClass$address() {
        return object_getClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClass(MemorySegment obj) {
        var mh$ = object_getClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getClass", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static FunctionDescriptor object_setClass$descriptor() {
        return object_setClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static MethodHandle object_setClass$handle() {
        return object_setClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static MemorySegment object_setClass$address() {
        return object_setClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static MemorySegment object_setClass(MemorySegment obj, MemorySegment cls) {
        var mh$ = object_setClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setClass", obj, cls);
            }
            return (MemorySegment)mh$.invokeExact(obj, cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_isClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_isClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_isClass$descriptor() {
        return object_isClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_isClass$handle() {
        return object_isClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_isClass$address() {
        return object_isClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static boolean object_isClass(MemorySegment obj) {
        var mh$ = object_isClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_isClass", obj);
            }
            return (boolean)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getIvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getIvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static FunctionDescriptor object_getIvar$descriptor() {
        return object_getIvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static MethodHandle object_getIvar$handle() {
        return object_getIvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static MemorySegment object_getIvar$address() {
        return object_getIvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static MemorySegment object_getIvar(MemorySegment obj, MemorySegment ivar) {
        var mh$ = object_getIvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getIvar", obj, ivar);
            }
            return (MemorySegment)mh$.invokeExact(obj, ivar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setIvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setIvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setIvar$descriptor() {
        return object_setIvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MethodHandle object_setIvar$handle() {
        return object_setIvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MemorySegment object_setIvar$address() {
        return object_setIvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static void object_setIvar(MemorySegment obj, MemorySegment ivar, MemorySegment value) {
        var mh$ = object_setIvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setIvar", obj, ivar, value);
            }
            mh$.invokeExact(obj, ivar, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setIvarWithStrongDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setIvarWithStrongDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setIvarWithStrongDefault$descriptor() {
        return object_setIvarWithStrongDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MethodHandle object_setIvarWithStrongDefault$handle() {
        return object_setIvarWithStrongDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MemorySegment object_setIvarWithStrongDefault$address() {
        return object_setIvarWithStrongDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static void object_setIvarWithStrongDefault(MemorySegment obj, MemorySegment ivar, MemorySegment value) {
        var mh$ = object_setIvarWithStrongDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setIvarWithStrongDefault", obj, ivar, value);
            }
            mh$.invokeExact(obj, ivar, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setInstanceVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setInstanceVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setInstanceVariable$descriptor() {
        return object_setInstanceVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MethodHandle object_setInstanceVariable$handle() {
        return object_setInstanceVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariable$address() {
        return object_setInstanceVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariable(MemorySegment obj, MemorySegment name, MemorySegment value) {
        var mh$ = object_setInstanceVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setInstanceVariable", obj, name, value);
            }
            return (MemorySegment)mh$.invokeExact(obj, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setInstanceVariableWithStrongDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setInstanceVariableWithStrongDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setInstanceVariableWithStrongDefault$descriptor() {
        return object_setInstanceVariableWithStrongDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MethodHandle object_setInstanceVariableWithStrongDefault$handle() {
        return object_setInstanceVariableWithStrongDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariableWithStrongDefault$address() {
        return object_setInstanceVariableWithStrongDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariableWithStrongDefault(MemorySegment obj, MemorySegment name, MemorySegment value) {
        var mh$ = object_setInstanceVariableWithStrongDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setInstanceVariableWithStrongDefault", obj, name, value);
            }
            return (MemorySegment)mh$.invokeExact(obj, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getInstanceVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getInstanceVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static FunctionDescriptor object_getInstanceVariable$descriptor() {
        return object_getInstanceVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static MethodHandle object_getInstanceVariable$handle() {
        return object_getInstanceVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static MemorySegment object_getInstanceVariable$address() {
        return object_getInstanceVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static MemorySegment object_getInstanceVariable(MemorySegment obj, MemorySegment name, MemorySegment outValue) {
        var mh$ = object_getInstanceVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getInstanceVariable", obj, name, outValue);
            }
            return (MemorySegment)mh$.invokeExact(obj, name, outValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getClass$descriptor() {
        return objc_getClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getClass$handle() {
        return objc_getClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getClass$address() {
        return objc_getClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getClass(MemorySegment name) {
        var mh$ = objc_getClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getMetaClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getMetaClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getMetaClass$descriptor() {
        return objc_getMetaClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getMetaClass$handle() {
        return objc_getMetaClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getMetaClass$address() {
        return objc_getMetaClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getMetaClass(MemorySegment name) {
        var mh$ = objc_getMetaClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getMetaClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_lookUpClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_lookUpClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_lookUpClass$descriptor() {
        return objc_lookUpClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_lookUpClass$handle() {
        return objc_lookUpClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_lookUpClass$address() {
        return objc_lookUpClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_lookUpClass(MemorySegment name) {
        var mh$ = objc_lookUpClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_lookUpClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getRequiredClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getRequiredClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getRequiredClass$descriptor() {
        return objc_getRequiredClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getRequiredClass$handle() {
        return objc_getRequiredClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getRequiredClass$address() {
        return objc_getRequiredClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getRequiredClass(MemorySegment name) {
        var mh$ = objc_getRequiredClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getRequiredClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getClassList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getClassList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static FunctionDescriptor objc_getClassList$descriptor() {
        return objc_getClassList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static MethodHandle objc_getClassList$handle() {
        return objc_getClassList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static MemorySegment objc_getClassList$address() {
        return objc_getClassList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static int objc_getClassList(MemorySegment buffer, int bufferCount) {
        var mh$ = objc_getClassList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getClassList", buffer, bufferCount);
            }
            return (int)mh$.invokeExact(buffer, bufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyClassList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyClassList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyClassList$descriptor() {
        return objc_copyClassList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyClassList$handle() {
        return objc_copyClassList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassList$address() {
        return objc_copyClassList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassList(MemorySegment outCount) {
        var mh$ = objc_copyClassList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyClassList", outCount);
            }
            return (MemorySegment)mh$.invokeExact(outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_enumerateClasses {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_enumerateClasses");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static FunctionDescriptor objc_enumerateClasses$descriptor() {
        return objc_enumerateClasses.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static MethodHandle objc_enumerateClasses$handle() {
        return objc_enumerateClasses.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static MemorySegment objc_enumerateClasses$address() {
        return objc_enumerateClasses.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static void objc_enumerateClasses(MemorySegment image, MemorySegment namePrefix, MemorySegment conformingTo, MemorySegment subclassing, MemorySegment block) {
        var mh$ = objc_enumerateClasses.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_enumerateClasses", image, namePrefix, conformingTo, subclassing, block);
            }
            mh$.invokeExact(image, namePrefix, conformingTo, subclassing, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getName$descriptor() {
        return class_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getName$handle() {
        return class_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getName$address() {
        return class_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getName(MemorySegment cls) {
        var mh$ = class_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getName", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_isMetaClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_isMetaClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_isMetaClass$descriptor() {
        return class_isMetaClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_isMetaClass$handle() {
        return class_isMetaClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_isMetaClass$address() {
        return class_isMetaClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static boolean class_isMetaClass(MemorySegment cls) {
        var mh$ = class_isMetaClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_isMetaClass", cls);
            }
            return (boolean)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getSuperclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getSuperclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getSuperclass$descriptor() {
        return class_getSuperclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getSuperclass$handle() {
        return class_getSuperclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getSuperclass$address() {
        return class_getSuperclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getSuperclass(MemorySegment cls) {
        var mh$ = class_getSuperclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getSuperclass", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setSuperclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setSuperclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static FunctionDescriptor class_setSuperclass$descriptor() {
        return class_setSuperclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static MethodHandle class_setSuperclass$handle() {
        return class_setSuperclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static MemorySegment class_setSuperclass$address() {
        return class_setSuperclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static MemorySegment class_setSuperclass(MemorySegment cls, MemorySegment newSuper) {
        var mh$ = class_setSuperclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setSuperclass", cls, newSuper);
            }
            return (MemorySegment)mh$.invokeExact(cls, newSuper);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getVersion$descriptor() {
        return class_getVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getVersion$handle() {
        return class_getVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getVersion$address() {
        return class_getVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static int class_getVersion(MemorySegment cls) {
        var mh$ = class_getVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getVersion", cls);
            }
            return (int)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static FunctionDescriptor class_setVersion$descriptor() {
        return class_setVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static MethodHandle class_setVersion$handle() {
        return class_setVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static MemorySegment class_setVersion$address() {
        return class_setVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static void class_setVersion(MemorySegment cls, int version) {
        var mh$ = class_setVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setVersion", cls, version);
            }
            mh$.invokeExact(cls, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getInstanceSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getInstanceSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getInstanceSize$descriptor() {
        return class_getInstanceSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getInstanceSize$handle() {
        return class_getInstanceSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getInstanceSize$address() {
        return class_getInstanceSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static long class_getInstanceSize(MemorySegment cls) {
        var mh$ = class_getInstanceSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getInstanceSize", cls);
            }
            return (long)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getInstanceVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getInstanceVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getInstanceVariable$descriptor() {
        return class_getInstanceVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MethodHandle class_getInstanceVariable$handle() {
        return class_getInstanceVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceVariable$address() {
        return class_getInstanceVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceVariable(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getInstanceVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getInstanceVariable", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getClassVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getClassVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getClassVariable$descriptor() {
        return class_getClassVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MethodHandle class_getClassVariable$handle() {
        return class_getClassVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassVariable$address() {
        return class_getClassVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassVariable(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getClassVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getClassVariable", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyIvarList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyIvarList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyIvarList$descriptor() {
        return class_copyIvarList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyIvarList$handle() {
        return class_copyIvarList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyIvarList$address() {
        return class_copyIvarList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyIvarList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyIvarList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyIvarList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getInstanceMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getInstanceMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getInstanceMethod$descriptor() {
        return class_getInstanceMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getInstanceMethod$handle() {
        return class_getInstanceMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceMethod$address() {
        return class_getInstanceMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceMethod(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getInstanceMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getInstanceMethod", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getClassMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getClassMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getClassMethod$descriptor() {
        return class_getClassMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getClassMethod$handle() {
        return class_getClassMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassMethod$address() {
        return class_getClassMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassMethod(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getClassMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getClassMethod", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getMethodImplementation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getMethodImplementation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getMethodImplementation$descriptor() {
        return class_getMethodImplementation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getMethodImplementation$handle() {
        return class_getMethodImplementation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation$address() {
        return class_getMethodImplementation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getMethodImplementation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getMethodImplementation", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getMethodImplementation_stret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getMethodImplementation_stret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getMethodImplementation_stret$descriptor() {
        return class_getMethodImplementation_stret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getMethodImplementation_stret$handle() {
        return class_getMethodImplementation_stret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation_stret$address() {
        return class_getMethodImplementation_stret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation_stret(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getMethodImplementation_stret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getMethodImplementation_stret", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_respondsToSelector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_respondsToSelector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor class_respondsToSelector$descriptor() {
        return class_respondsToSelector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle class_respondsToSelector$handle() {
        return class_respondsToSelector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_respondsToSelector$address() {
        return class_respondsToSelector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static boolean class_respondsToSelector(MemorySegment cls, MemorySegment sel) {
        var mh$ = class_respondsToSelector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_respondsToSelector", cls, sel);
            }
            return (boolean)mh$.invokeExact(cls, sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyMethodList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyMethodList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyMethodList$descriptor() {
        return class_copyMethodList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyMethodList$handle() {
        return class_copyMethodList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyMethodList$address() {
        return class_copyMethodList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyMethodList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyMethodList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyMethodList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_conformsToProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_conformsToProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static FunctionDescriptor class_conformsToProtocol$descriptor() {
        return class_conformsToProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static MethodHandle class_conformsToProtocol$handle() {
        return class_conformsToProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static MemorySegment class_conformsToProtocol$address() {
        return class_conformsToProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static boolean class_conformsToProtocol(MemorySegment cls, MemorySegment protocol) {
        var mh$ = class_conformsToProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_conformsToProtocol", cls, protocol);
            }
            return (boolean)mh$.invokeExact(cls, protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyProtocolList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyProtocolList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyProtocolList$descriptor() {
        return class_copyProtocolList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyProtocolList$handle() {
        return class_copyProtocolList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyProtocolList$address() {
        return class_copyProtocolList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyProtocolList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyProtocolList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyProtocolList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getProperty$descriptor() {
        return class_getProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MethodHandle class_getProperty$handle() {
        return class_getProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getProperty$address() {
        return class_getProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getProperty(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getProperty", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyPropertyList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyPropertyList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyPropertyList$descriptor() {
        return class_copyPropertyList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyPropertyList$handle() {
        return class_copyPropertyList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyPropertyList$address() {
        return class_copyPropertyList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyPropertyList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyPropertyList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyPropertyList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getIvarLayout$descriptor() {
        return class_getIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getIvarLayout$handle() {
        return class_getIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getIvarLayout$address() {
        return class_getIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getIvarLayout(MemorySegment cls) {
        var mh$ = class_getIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getIvarLayout", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getWeakIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getWeakIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getWeakIvarLayout$descriptor() {
        return class_getWeakIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getWeakIvarLayout$handle() {
        return class_getWeakIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getWeakIvarLayout$address() {
        return class_getWeakIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getWeakIvarLayout(MemorySegment cls) {
        var mh$ = class_getWeakIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getWeakIvarLayout", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static FunctionDescriptor class_addMethod$descriptor() {
        return class_addMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MethodHandle class_addMethod$handle() {
        return class_addMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_addMethod$address() {
        return class_addMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static boolean class_addMethod(MemorySegment cls, MemorySegment name, MemorySegment imp, MemorySegment types) {
        var mh$ = class_addMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addMethod", cls, name, imp, types);
            }
            return (boolean)mh$.invokeExact(cls, name, imp, types);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_replaceMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_replaceMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static FunctionDescriptor class_replaceMethod$descriptor() {
        return class_replaceMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MethodHandle class_replaceMethod$handle() {
        return class_replaceMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_replaceMethod$address() {
        return class_replaceMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_replaceMethod(MemorySegment cls, MemorySegment name, MemorySegment imp, MemorySegment types) {
        var mh$ = class_replaceMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_replaceMethod", cls, name, imp, types);
            }
            return (MemorySegment)mh$.invokeExact(cls, name, imp, types);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addIvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_CHAR,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addIvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static FunctionDescriptor class_addIvar$descriptor() {
        return class_addIvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static MethodHandle class_addIvar$handle() {
        return class_addIvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_addIvar$address() {
        return class_addIvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static boolean class_addIvar(MemorySegment cls, MemorySegment name, long size, byte alignment, MemorySegment types) {
        var mh$ = class_addIvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addIvar", cls, name, size, alignment, types);
            }
            return (boolean)mh$.invokeExact(cls, name, size, alignment, types);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static FunctionDescriptor class_addProtocol$descriptor() {
        return class_addProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static MethodHandle class_addProtocol$handle() {
        return class_addProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static MemorySegment class_addProtocol$address() {
        return class_addProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static boolean class_addProtocol(MemorySegment cls, MemorySegment protocol) {
        var mh$ = class_addProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addProtocol", cls, protocol);
            }
            return (boolean)mh$.invokeExact(cls, protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static FunctionDescriptor class_addProperty$descriptor() {
        return class_addProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MethodHandle class_addProperty$handle() {
        return class_addProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MemorySegment class_addProperty$address() {
        return class_addProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static boolean class_addProperty(MemorySegment cls, MemorySegment name, MemorySegment attributes, int attributeCount) {
        var mh$ = class_addProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addProperty", cls, name, attributes, attributeCount);
            }
            return (boolean)mh$.invokeExact(cls, name, attributes, attributeCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_replaceProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_replaceProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static FunctionDescriptor class_replaceProperty$descriptor() {
        return class_replaceProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MethodHandle class_replaceProperty$handle() {
        return class_replaceProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MemorySegment class_replaceProperty$address() {
        return class_replaceProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static void class_replaceProperty(MemorySegment cls, MemorySegment name, MemorySegment attributes, int attributeCount) {
        var mh$ = class_replaceProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_replaceProperty", cls, name, attributes, attributeCount);
            }
            mh$.invokeExact(cls, name, attributes, attributeCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static FunctionDescriptor class_setIvarLayout$descriptor() {
        return class_setIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MethodHandle class_setIvarLayout$handle() {
        return class_setIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MemorySegment class_setIvarLayout$address() {
        return class_setIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static void class_setIvarLayout(MemorySegment cls, MemorySegment layout) {
        var mh$ = class_setIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setIvarLayout", cls, layout);
            }
            mh$.invokeExact(cls, layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setWeakIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setWeakIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static FunctionDescriptor class_setWeakIvarLayout$descriptor() {
        return class_setWeakIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MethodHandle class_setWeakIvarLayout$handle() {
        return class_setWeakIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MemorySegment class_setWeakIvarLayout$address() {
        return class_setWeakIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static void class_setWeakIvarLayout(MemorySegment cls, MemorySegment layout) {
        var mh$ = class_setWeakIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setWeakIvarLayout", cls, layout);
            }
            mh$.invokeExact(cls, layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getFutureClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getFutureClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getFutureClass$descriptor() {
        return objc_getFutureClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getFutureClass$handle() {
        return objc_getFutureClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getFutureClass$address() {
        return objc_getFutureClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getFutureClass(MemorySegment name) {
        var mh$ = objc_getFutureClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getFutureClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_createInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_createInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static FunctionDescriptor class_createInstance$descriptor() {
        return class_createInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static MethodHandle class_createInstance$handle() {
        return class_createInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static MemorySegment class_createInstance$address() {
        return class_createInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static MemorySegment class_createInstance(MemorySegment cls, long extraBytes) {
        var mh$ = class_createInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_createInstance", cls, extraBytes);
            }
            return (MemorySegment)mh$.invokeExact(cls, extraBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_constructInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_constructInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static FunctionDescriptor objc_constructInstance$descriptor() {
        return objc_constructInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static MethodHandle objc_constructInstance$handle() {
        return objc_constructInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static MemorySegment objc_constructInstance$address() {
        return objc_constructInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static MemorySegment objc_constructInstance(MemorySegment cls, MemorySegment bytes) {
        var mh$ = objc_constructInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_constructInstance", cls, bytes);
            }
            return (MemorySegment)mh$.invokeExact(cls, bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_destructInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_destructInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_destructInstance$descriptor() {
        return objc_destructInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static MethodHandle objc_destructInstance$handle() {
        return objc_destructInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_destructInstance$address() {
        return objc_destructInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_destructInstance(MemorySegment obj) {
        var mh$ = objc_destructInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_destructInstance", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_allocateClassPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_allocateClassPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static FunctionDescriptor objc_allocateClassPair$descriptor() {
        return objc_allocateClassPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MethodHandle objc_allocateClassPair$handle() {
        return objc_allocateClassPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_allocateClassPair$address() {
        return objc_allocateClassPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_allocateClassPair(MemorySegment superclass, MemorySegment name, long extraBytes) {
        var mh$ = objc_allocateClassPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_allocateClassPair", superclass, name, extraBytes);
            }
            return (MemorySegment)mh$.invokeExact(superclass, name, extraBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_registerClassPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_registerClassPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static FunctionDescriptor objc_registerClassPair$descriptor() {
        return objc_registerClassPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static MethodHandle objc_registerClassPair$handle() {
        return objc_registerClassPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static MemorySegment objc_registerClassPair$address() {
        return objc_registerClassPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static void objc_registerClassPair(MemorySegment cls) {
        var mh$ = objc_registerClassPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_registerClassPair", cls);
            }
            mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_duplicateClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_duplicateClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static FunctionDescriptor objc_duplicateClass$descriptor() {
        return objc_duplicateClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MethodHandle objc_duplicateClass$handle() {
        return objc_duplicateClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_duplicateClass$address() {
        return objc_duplicateClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_duplicateClass(MemorySegment original, MemorySegment name, long extraBytes) {
        var mh$ = objc_duplicateClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_duplicateClass", original, name, extraBytes);
            }
            return (MemorySegment)mh$.invokeExact(original, name, extraBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_disposeClassPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_disposeClassPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static FunctionDescriptor objc_disposeClassPair$descriptor() {
        return objc_disposeClassPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static MethodHandle objc_disposeClassPair$handle() {
        return objc_disposeClassPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static MemorySegment objc_disposeClassPair$address() {
        return objc_disposeClassPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static void objc_disposeClassPair(MemorySegment cls) {
        var mh$ = objc_disposeClassPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_disposeClassPair", cls);
            }
            mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getName$descriptor() {
        return method_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getName$handle() {
        return method_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getName$address() {
        return method_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getName(MemorySegment m) {
        var mh$ = method_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getName", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getImplementation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getImplementation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getImplementation$descriptor() {
        return method_getImplementation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getImplementation$handle() {
        return method_getImplementation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getImplementation$address() {
        return method_getImplementation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getImplementation(MemorySegment m) {
        var mh$ = method_getImplementation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getImplementation", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getTypeEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getTypeEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getTypeEncoding$descriptor() {
        return method_getTypeEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getTypeEncoding$handle() {
        return method_getTypeEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getTypeEncoding$address() {
        return method_getTypeEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getTypeEncoding(MemorySegment m) {
        var mh$ = method_getTypeEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getTypeEncoding", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getNumberOfArguments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getNumberOfArguments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getNumberOfArguments$descriptor() {
        return method_getNumberOfArguments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getNumberOfArguments$handle() {
        return method_getNumberOfArguments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getNumberOfArguments$address() {
        return method_getNumberOfArguments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static int method_getNumberOfArguments(MemorySegment m) {
        var mh$ = method_getNumberOfArguments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getNumberOfArguments", m);
            }
            return (int)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_copyReturnType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_copyReturnType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_copyReturnType$descriptor() {
        return method_copyReturnType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_copyReturnType$handle() {
        return method_copyReturnType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_copyReturnType$address() {
        return method_copyReturnType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_copyReturnType(MemorySegment m) {
        var mh$ = method_copyReturnType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_copyReturnType", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_copyArgumentType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_copyArgumentType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static FunctionDescriptor method_copyArgumentType$descriptor() {
        return method_copyArgumentType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static MethodHandle method_copyArgumentType$handle() {
        return method_copyArgumentType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static MemorySegment method_copyArgumentType$address() {
        return method_copyArgumentType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static MemorySegment method_copyArgumentType(MemorySegment m, int index) {
        var mh$ = method_copyArgumentType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_copyArgumentType", m, index);
            }
            return (MemorySegment)mh$.invokeExact(m, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getReturnType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getReturnType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static FunctionDescriptor method_getReturnType$descriptor() {
        return method_getReturnType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static MethodHandle method_getReturnType$handle() {
        return method_getReturnType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static MemorySegment method_getReturnType$address() {
        return method_getReturnType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static void method_getReturnType(MemorySegment m, MemorySegment dst, long dst_len) {
        var mh$ = method_getReturnType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getReturnType", m, dst, dst_len);
            }
            mh$.invokeExact(m, dst, dst_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getArgumentType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getArgumentType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static FunctionDescriptor method_getArgumentType$descriptor() {
        return method_getArgumentType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static MethodHandle method_getArgumentType$handle() {
        return method_getArgumentType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static MemorySegment method_getArgumentType$address() {
        return method_getArgumentType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static void method_getArgumentType(MemorySegment m, int index, MemorySegment dst, long dst_len) {
        var mh$ = method_getArgumentType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getArgumentType", m, index, dst, dst_len);
            }
            mh$.invokeExact(m, index, dst, dst_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getDescription$descriptor() {
        return method_getDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getDescription$handle() {
        return method_getDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getDescription$address() {
        return method_getDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getDescription(MemorySegment m) {
        var mh$ = method_getDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getDescription", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_setImplementation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_setImplementation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static FunctionDescriptor method_setImplementation$descriptor() {
        return method_setImplementation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static MethodHandle method_setImplementation$handle() {
        return method_setImplementation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static MemorySegment method_setImplementation$address() {
        return method_setImplementation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static MemorySegment method_setImplementation(MemorySegment m, MemorySegment imp) {
        var mh$ = method_setImplementation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_setImplementation", m, imp);
            }
            return (MemorySegment)mh$.invokeExact(m, imp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_exchangeImplementations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_exchangeImplementations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static FunctionDescriptor method_exchangeImplementations$descriptor() {
        return method_exchangeImplementations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static MethodHandle method_exchangeImplementations$handle() {
        return method_exchangeImplementations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static MemorySegment method_exchangeImplementations$address() {
        return method_exchangeImplementations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static void method_exchangeImplementations(MemorySegment m1, MemorySegment m2) {
        var mh$ = method_exchangeImplementations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_exchangeImplementations", m1, m2);
            }
            mh$.invokeExact(m1, m2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ivar_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ivar_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static FunctionDescriptor ivar_getName$descriptor() {
        return ivar_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static MethodHandle ivar_getName$handle() {
        return ivar_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getName$address() {
        return ivar_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getName(MemorySegment v) {
        var mh$ = ivar_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ivar_getName", v);
            }
            return (MemorySegment)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ivar_getTypeEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ivar_getTypeEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static FunctionDescriptor ivar_getTypeEncoding$descriptor() {
        return ivar_getTypeEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static MethodHandle ivar_getTypeEncoding$handle() {
        return ivar_getTypeEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getTypeEncoding$address() {
        return ivar_getTypeEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getTypeEncoding(MemorySegment v) {
        var mh$ = ivar_getTypeEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ivar_getTypeEncoding", v);
            }
            return (MemorySegment)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ivar_getOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ivar_getOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static FunctionDescriptor ivar_getOffset$descriptor() {
        return ivar_getOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static MethodHandle ivar_getOffset$handle() {
        return ivar_getOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getOffset$address() {
        return ivar_getOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static long ivar_getOffset(MemorySegment v) {
        var mh$ = ivar_getOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ivar_getOffset", v);
            }
            return (long)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static FunctionDescriptor property_getName$descriptor() {
        return property_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static MethodHandle property_getName$handle() {
        return property_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getName$address() {
        return property_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getName(MemorySegment property) {
        var mh$ = property_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_getName", property);
            }
            return (MemorySegment)mh$.invokeExact(property);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_getAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_getAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static FunctionDescriptor property_getAttributes$descriptor() {
        return property_getAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static MethodHandle property_getAttributes$handle() {
        return property_getAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getAttributes$address() {
        return property_getAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getAttributes(MemorySegment property) {
        var mh$ = property_getAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_getAttributes", property);
            }
            return (MemorySegment)mh$.invokeExact(property);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_copyAttributeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_copyAttributeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor property_copyAttributeList$descriptor() {
        return property_copyAttributeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle property_copyAttributeList$handle() {
        return property_copyAttributeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment property_copyAttributeList$address() {
        return property_copyAttributeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment property_copyAttributeList(MemorySegment property, MemorySegment outCount) {
        var mh$ = property_copyAttributeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_copyAttributeList", property, outCount);
            }
            return (MemorySegment)mh$.invokeExact(property, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_copyAttributeValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_copyAttributeValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static FunctionDescriptor property_copyAttributeValue$descriptor() {
        return property_copyAttributeValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static MethodHandle property_copyAttributeValue$handle() {
        return property_copyAttributeValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static MemorySegment property_copyAttributeValue$address() {
        return property_copyAttributeValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static MemorySegment property_copyAttributeValue(MemorySegment property, MemorySegment attributeName) {
        var mh$ = property_copyAttributeValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_copyAttributeValue", property, attributeName);
            }
            return (MemorySegment)mh$.invokeExact(property, attributeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getProtocol$descriptor() {
        return objc_getProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getProtocol$handle() {
        return objc_getProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getProtocol$address() {
        return objc_getProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getProtocol(MemorySegment name) {
        var mh$ = objc_getProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getProtocol", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyProtocolList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyProtocolList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyProtocolList$descriptor() {
        return objc_copyProtocolList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyProtocolList$handle() {
        return objc_copyProtocolList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyProtocolList$address() {
        return objc_copyProtocolList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyProtocolList(MemorySegment outCount) {
        var mh$ = objc_copyProtocolList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyProtocolList", outCount);
            }
            return (MemorySegment)mh$.invokeExact(outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_conformsToProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_conformsToProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static FunctionDescriptor protocol_conformsToProtocol$descriptor() {
        return protocol_conformsToProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MethodHandle protocol_conformsToProtocol$handle() {
        return protocol_conformsToProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MemorySegment protocol_conformsToProtocol$address() {
        return protocol_conformsToProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static boolean protocol_conformsToProtocol(MemorySegment proto, MemorySegment other) {
        var mh$ = protocol_conformsToProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_conformsToProtocol", proto, other);
            }
            return (boolean)mh$.invokeExact(proto, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_isEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_isEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static FunctionDescriptor protocol_isEqual$descriptor() {
        return protocol_isEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MethodHandle protocol_isEqual$handle() {
        return protocol_isEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MemorySegment protocol_isEqual$address() {
        return protocol_isEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static boolean protocol_isEqual(MemorySegment proto, MemorySegment other) {
        var mh$ = protocol_isEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_isEqual", proto, other);
            }
            return (boolean)mh$.invokeExact(proto, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static FunctionDescriptor protocol_getName$descriptor() {
        return protocol_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static MethodHandle protocol_getName$handle() {
        return protocol_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static MemorySegment protocol_getName$address() {
        return protocol_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static MemorySegment protocol_getName(MemorySegment proto) {
        var mh$ = protocol_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_getName", proto);
            }
            return (MemorySegment)mh$.invokeExact(proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_getMethodDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            objc_method_description.layout(),
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_getMethodDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static FunctionDescriptor protocol_getMethodDescription$descriptor() {
        return protocol_getMethodDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MethodHandle protocol_getMethodDescription$handle() {
        return protocol_getMethodDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MemorySegment protocol_getMethodDescription$address() {
        return protocol_getMethodDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MemorySegment protocol_getMethodDescription(SegmentAllocator allocator, MemorySegment proto, MemorySegment aSel, boolean isRequiredMethod, boolean isInstanceMethod) {
        var mh$ = protocol_getMethodDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_getMethodDescription", allocator, proto, aSel, isRequiredMethod, isInstanceMethod);
            }
            return (MemorySegment)mh$.invokeExact(allocator, proto, aSel, isRequiredMethod, isInstanceMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyMethodDescriptionList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyMethodDescriptionList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor protocol_copyMethodDescriptionList$descriptor() {
        return protocol_copyMethodDescriptionList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle protocol_copyMethodDescriptionList$handle() {
        return protocol_copyMethodDescriptionList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyMethodDescriptionList$address() {
        return protocol_copyMethodDescriptionList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyMethodDescriptionList(MemorySegment proto, boolean isRequiredMethod, boolean isInstanceMethod, MemorySegment outCount) {
        var mh$ = protocol_copyMethodDescriptionList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyMethodDescriptionList", proto, isRequiredMethod, isInstanceMethod, outCount);
            }
            return (MemorySegment)mh$.invokeExact(proto, isRequiredMethod, isInstanceMethod, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_getProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_getProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static FunctionDescriptor protocol_getProperty$descriptor() {
        return protocol_getProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MethodHandle protocol_getProperty$handle() {
        return protocol_getProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_getProperty$address() {
        return protocol_getProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_getProperty(MemorySegment proto, MemorySegment name, boolean isRequiredProperty, boolean isInstanceProperty) {
        var mh$ = protocol_getProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_getProperty", proto, name, isRequiredProperty, isInstanceProperty);
            }
            return (MemorySegment)mh$.invokeExact(proto, name, isRequiredProperty, isInstanceProperty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyPropertyList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyPropertyList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor protocol_copyPropertyList$descriptor() {
        return protocol_copyPropertyList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle protocol_copyPropertyList$handle() {
        return protocol_copyPropertyList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyPropertyList$address() {
        return protocol_copyPropertyList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyPropertyList(MemorySegment proto, MemorySegment outCount) {
        var mh$ = protocol_copyPropertyList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyPropertyList", proto, outCount);
            }
            return (MemorySegment)mh$.invokeExact(proto, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyPropertyList2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyPropertyList2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static FunctionDescriptor protocol_copyPropertyList2$descriptor() {
        return protocol_copyPropertyList2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MethodHandle protocol_copyPropertyList2$handle() {
        return protocol_copyPropertyList2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_copyPropertyList2$address() {
        return protocol_copyPropertyList2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_copyPropertyList2(MemorySegment proto, MemorySegment outCount, boolean isRequiredProperty, boolean isInstanceProperty) {
        var mh$ = protocol_copyPropertyList2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyPropertyList2", proto, outCount, isRequiredProperty, isInstanceProperty);
            }
            return (MemorySegment)mh$.invokeExact(proto, outCount, isRequiredProperty, isInstanceProperty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyProtocolList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyProtocolList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor protocol_copyProtocolList$descriptor() {
        return protocol_copyProtocolList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle protocol_copyProtocolList$handle() {
        return protocol_copyProtocolList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyProtocolList$address() {
        return protocol_copyProtocolList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyProtocolList(MemorySegment proto, MemorySegment outCount) {
        var mh$ = protocol_copyProtocolList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyProtocolList", proto, outCount);
            }
            return (MemorySegment)mh$.invokeExact(proto, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_allocateProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_allocateProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_allocateProtocol$descriptor() {
        return objc_allocateProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_allocateProtocol$handle() {
        return objc_allocateProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_allocateProtocol$address() {
        return objc_allocateProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_allocateProtocol(MemorySegment name) {
        var mh$ = objc_allocateProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_allocateProtocol", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_registerProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_registerProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static FunctionDescriptor objc_registerProtocol$descriptor() {
        return objc_registerProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static MethodHandle objc_registerProtocol$handle() {
        return objc_registerProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static MemorySegment objc_registerProtocol$address() {
        return objc_registerProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static void objc_registerProtocol(MemorySegment proto) {
        var mh$ = objc_registerProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_registerProtocol", proto);
            }
            mh$.invokeExact(proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_addMethodDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_addMethodDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static FunctionDescriptor protocol_addMethodDescription$descriptor() {
        return protocol_addMethodDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MethodHandle protocol_addMethodDescription$handle() {
        return protocol_addMethodDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MemorySegment protocol_addMethodDescription$address() {
        return protocol_addMethodDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static void protocol_addMethodDescription(MemorySegment proto, MemorySegment name, MemorySegment types, boolean isRequiredMethod, boolean isInstanceMethod) {
        var mh$ = protocol_addMethodDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_addMethodDescription", proto, name, types, isRequiredMethod, isInstanceMethod);
            }
            mh$.invokeExact(proto, name, types, isRequiredMethod, isInstanceMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_addProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_addProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static FunctionDescriptor protocol_addProtocol$descriptor() {
        return protocol_addProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static MethodHandle protocol_addProtocol$handle() {
        return protocol_addProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static MemorySegment protocol_addProtocol$address() {
        return protocol_addProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static void protocol_addProtocol(MemorySegment proto, MemorySegment addition) {
        var mh$ = protocol_addProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_addProtocol", proto, addition);
            }
            mh$.invokeExact(proto, addition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_addProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_addProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static FunctionDescriptor protocol_addProperty$descriptor() {
        return protocol_addProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MethodHandle protocol_addProperty$handle() {
        return protocol_addProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_addProperty$address() {
        return protocol_addProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static void protocol_addProperty(MemorySegment proto, MemorySegment name, MemorySegment attributes, int attributeCount, boolean isRequiredProperty, boolean isInstanceProperty) {
        var mh$ = protocol_addProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_addProperty", proto, name, attributes, attributeCount, isRequiredProperty, isInstanceProperty);
            }
            mh$.invokeExact(proto, name, attributes, attributeCount, isRequiredProperty, isInstanceProperty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyImageNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyImageNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyImageNames$descriptor() {
        return objc_copyImageNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyImageNames$handle() {
        return objc_copyImageNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyImageNames$address() {
        return objc_copyImageNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyImageNames(MemorySegment outCount) {
        var mh$ = objc_copyImageNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyImageNames", outCount);
            }
            return (MemorySegment)mh$.invokeExact(outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getImageName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getImageName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getImageName$descriptor() {
        return class_getImageName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getImageName$handle() {
        return class_getImageName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getImageName$address() {
        return class_getImageName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getImageName(MemorySegment cls) {
        var mh$ = class_getImageName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getImageName", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyClassNamesForImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyClassNamesForImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyClassNamesForImage$descriptor() {
        return objc_copyClassNamesForImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyClassNamesForImage$handle() {
        return objc_copyClassNamesForImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassNamesForImage$address() {
        return objc_copyClassNamesForImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassNamesForImage(MemorySegment image, MemorySegment outCount) {
        var mh$ = objc_copyClassNamesForImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyClassNamesForImage", image, outCount);
            }
            return (MemorySegment)mh$.invokeExact(image, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_isEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_isEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static FunctionDescriptor sel_isEqual$descriptor() {
        return sel_isEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static MethodHandle sel_isEqual$handle() {
        return sel_isEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static MemorySegment sel_isEqual$address() {
        return sel_isEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static boolean sel_isEqual(MemorySegment lhs, MemorySegment rhs) {
        var mh$ = sel_isEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_isEqual", lhs, rhs);
            }
            return (boolean)mh$.invokeExact(lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_enumerationMutation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_enumerationMutation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static FunctionDescriptor objc_enumerationMutation$descriptor() {
        return objc_enumerationMutation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static MethodHandle objc_enumerationMutation$handle() {
        return objc_enumerationMutation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static MemorySegment objc_enumerationMutation$address() {
        return objc_enumerationMutation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static void objc_enumerationMutation(MemorySegment obj) {
        var mh$ = objc_enumerationMutation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_enumerationMutation", obj);
            }
            mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setEnumerationMutationHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setEnumerationMutationHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static FunctionDescriptor objc_setEnumerationMutationHandler$descriptor() {
        return objc_setEnumerationMutationHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static MethodHandle objc_setEnumerationMutationHandler$handle() {
        return objc_setEnumerationMutationHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static MemorySegment objc_setEnumerationMutationHandler$address() {
        return objc_setEnumerationMutationHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static void objc_setEnumerationMutationHandler(MemorySegment handler) {
        var mh$ = objc_setEnumerationMutationHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setEnumerationMutationHandler", handler);
            }
            mh$.invokeExact(handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setForwardHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setForwardHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static FunctionDescriptor objc_setForwardHandler$descriptor() {
        return objc_setForwardHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static MethodHandle objc_setForwardHandler$handle() {
        return objc_setForwardHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static MemorySegment objc_setForwardHandler$address() {
        return objc_setForwardHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static void objc_setForwardHandler(MemorySegment fwd, MemorySegment fwd_stret) {
        var mh$ = objc_setForwardHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setForwardHandler", fwd, fwd_stret);
            }
            mh$.invokeExact(fwd, fwd_stret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imp_implementationWithBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("imp_implementationWithBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static FunctionDescriptor imp_implementationWithBlock$descriptor() {
        return imp_implementationWithBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static MethodHandle imp_implementationWithBlock$handle() {
        return imp_implementationWithBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static MemorySegment imp_implementationWithBlock$address() {
        return imp_implementationWithBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static MemorySegment imp_implementationWithBlock(MemorySegment block) {
        var mh$ = imp_implementationWithBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imp_implementationWithBlock", block);
            }
            return (MemorySegment)mh$.invokeExact(block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imp_getBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("imp_getBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static FunctionDescriptor imp_getBlock$descriptor() {
        return imp_getBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MethodHandle imp_getBlock$handle() {
        return imp_getBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MemorySegment imp_getBlock$address() {
        return imp_getBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MemorySegment imp_getBlock(MemorySegment anImp) {
        var mh$ = imp_getBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imp_getBlock", anImp);
            }
            return (MemorySegment)mh$.invokeExact(anImp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imp_removeBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("imp_removeBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static FunctionDescriptor imp_removeBlock$descriptor() {
        return imp_removeBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MethodHandle imp_removeBlock$handle() {
        return imp_removeBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MemorySegment imp_removeBlock$address() {
        return imp_removeBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static boolean imp_removeBlock(MemorySegment anImp) {
        var mh$ = imp_removeBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imp_removeBlock", anImp);
            }
            return (boolean)mh$.invokeExact(anImp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_loadWeak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_loadWeak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static FunctionDescriptor objc_loadWeak$descriptor() {
        return objc_loadWeak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static MethodHandle objc_loadWeak$handle() {
        return objc_loadWeak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static MemorySegment objc_loadWeak$address() {
        return objc_loadWeak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static MemorySegment objc_loadWeak(MemorySegment location) {
        var mh$ = objc_loadWeak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_loadWeak", location);
            }
            return (MemorySegment)mh$.invokeExact(location);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_storeWeak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_storeWeak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_storeWeak$descriptor() {
        return objc_storeWeak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static MethodHandle objc_storeWeak$handle() {
        return objc_storeWeak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_storeWeak$address() {
        return objc_storeWeak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_storeWeak(MemorySegment location, MemorySegment obj) {
        var mh$ = objc_storeWeak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_storeWeak", location, obj);
            }
            return (MemorySegment)mh$.invokeExact(location, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uintptr_t objc_AssociationPolicy
     * }
     */
    public static final OfLong objc_AssociationPolicy = ObjCRuntime.C_LONG;
    private static final int OBJC_ASSOCIATION_ASSIGN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_ASSIGN = 0
     * }
     */
    public static int OBJC_ASSOCIATION_ASSIGN() {
        return OBJC_ASSOCIATION_ASSIGN;
    }
    private static final int OBJC_ASSOCIATION_RETAIN_NONATOMIC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1
     * }
     */
    public static int OBJC_ASSOCIATION_RETAIN_NONATOMIC() {
        return OBJC_ASSOCIATION_RETAIN_NONATOMIC;
    }
    private static final int OBJC_ASSOCIATION_COPY_NONATOMIC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_COPY_NONATOMIC = 3
     * }
     */
    public static int OBJC_ASSOCIATION_COPY_NONATOMIC() {
        return OBJC_ASSOCIATION_COPY_NONATOMIC;
    }
    private static final int OBJC_ASSOCIATION_RETAIN = (int)769L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_RETAIN = 769
     * }
     */
    public static int OBJC_ASSOCIATION_RETAIN() {
        return OBJC_ASSOCIATION_RETAIN;
    }
    private static final int OBJC_ASSOCIATION_COPY = (int)771L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_COPY = 771
     * }
     */
    public static int OBJC_ASSOCIATION_COPY() {
        return OBJC_ASSOCIATION_COPY;
    }

    private static class objc_setAssociatedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setAssociatedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static FunctionDescriptor objc_setAssociatedObject$descriptor() {
        return objc_setAssociatedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static MethodHandle objc_setAssociatedObject$handle() {
        return objc_setAssociatedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static MemorySegment objc_setAssociatedObject$address() {
        return objc_setAssociatedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static void objc_setAssociatedObject(MemorySegment object, MemorySegment key, MemorySegment value, long policy) {
        var mh$ = objc_setAssociatedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setAssociatedObject", object, key, value, policy);
            }
            mh$.invokeExact(object, key, value, policy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getAssociatedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getAssociatedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static FunctionDescriptor objc_getAssociatedObject$descriptor() {
        return objc_getAssociatedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static MethodHandle objc_getAssociatedObject$handle() {
        return objc_getAssociatedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static MemorySegment objc_getAssociatedObject$address() {
        return objc_getAssociatedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static MemorySegment objc_getAssociatedObject(MemorySegment object, MemorySegment key) {
        var mh$ = objc_getAssociatedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getAssociatedObject", object, key);
            }
            return (MemorySegment)mh$.invokeExact(object, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_removeAssociatedObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_removeAssociatedObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static FunctionDescriptor objc_removeAssociatedObjects$descriptor() {
        return objc_removeAssociatedObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static MethodHandle objc_removeAssociatedObjects$handle() {
        return objc_removeAssociatedObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static MemorySegment objc_removeAssociatedObjects$address() {
        return objc_removeAssociatedObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static void objc_removeAssociatedObjects(MemorySegment object) {
        var mh$ = objc_removeAssociatedObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_removeAssociatedObjects", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setHook_getImageName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setHook_getImageName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static FunctionDescriptor objc_setHook_getImageName$descriptor() {
        return objc_setHook_getImageName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MethodHandle objc_setHook_getImageName$handle() {
        return objc_setHook_getImageName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MemorySegment objc_setHook_getImageName$address() {
        return objc_setHook_getImageName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static void objc_setHook_getImageName(MemorySegment newValue, MemorySegment outOldValue) {
        var mh$ = objc_setHook_getImageName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setHook_getImageName", newValue, outOldValue);
            }
            mh$.invokeExact(newValue, outOldValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setHook_getClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setHook_getClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static FunctionDescriptor objc_setHook_getClass$descriptor() {
        return objc_setHook_getClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MethodHandle objc_setHook_getClass$handle() {
        return objc_setHook_getClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MemorySegment objc_setHook_getClass$address() {
        return objc_setHook_getClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static void objc_setHook_getClass(MemorySegment newValue, MemorySegment outOldValue) {
        var mh$ = objc_setHook_getClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setHook_getClass", newValue, outOldValue);
            }
            mh$.invokeExact(newValue, outOldValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_addLoadImageFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_addLoadImageFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static FunctionDescriptor objc_addLoadImageFunc$descriptor() {
        return objc_addLoadImageFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static MethodHandle objc_addLoadImageFunc$handle() {
        return objc_addLoadImageFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static MemorySegment objc_addLoadImageFunc$address() {
        return objc_addLoadImageFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static void objc_addLoadImageFunc(MemorySegment func) {
        var mh$ = objc_addLoadImageFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_addLoadImageFunc", func);
            }
            mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setHook_lazyClassNamer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setHook_lazyClassNamer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static FunctionDescriptor objc_setHook_lazyClassNamer$descriptor() {
        return objc_setHook_lazyClassNamer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static MethodHandle objc_setHook_lazyClassNamer$handle() {
        return objc_setHook_lazyClassNamer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static MemorySegment objc_setHook_lazyClassNamer$address() {
        return objc_setHook_lazyClassNamer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static void objc_setHook_lazyClassNamer(MemorySegment newValue, MemorySegment oldOutValue) {
        var mh$ = objc_setHook_lazyClassNamer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setHook_lazyClassNamer", newValue, oldOutValue);
            }
            mh$.invokeExact(newValue, oldOutValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _objc_realizeClassFromSwift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_objc_realizeClassFromSwift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static FunctionDescriptor _objc_realizeClassFromSwift$descriptor() {
        return _objc_realizeClassFromSwift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static MethodHandle _objc_realizeClassFromSwift$handle() {
        return _objc_realizeClassFromSwift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static MemorySegment _objc_realizeClassFromSwift$address() {
        return _objc_realizeClassFromSwift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static MemorySegment _objc_realizeClassFromSwift(MemorySegment cls, MemorySegment previously) {
        var mh$ = _objc_realizeClassFromSwift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_objc_realizeClassFromSwift", cls, previously);
            }
            return (MemorySegment)mh$.invokeExact(cls, previously);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _objc_flush_caches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_objc_flush_caches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor _objc_flush_caches$descriptor() {
        return _objc_flush_caches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static MethodHandle _objc_flush_caches$handle() {
        return _objc_flush_caches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static MemorySegment _objc_flush_caches$address() {
        return _objc_flush_caches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static void _objc_flush_caches(MemorySegment cls) {
        var mh$ = _objc_flush_caches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_objc_flush_caches", cls);
            }
            mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_lookupMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_lookupMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor class_lookupMethod$descriptor() {
        return class_lookupMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle class_lookupMethod$handle() {
        return class_lookupMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_lookupMethod$address() {
        return class_lookupMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_lookupMethod(MemorySegment cls, MemorySegment sel) {
        var mh$ = class_lookupMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_lookupMethod", cls, sel);
            }
            return (MemorySegment)mh$.invokeExact(cls, sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_respondsToMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_respondsToMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor class_respondsToMethod$descriptor() {
        return class_respondsToMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle class_respondsToMethod$handle() {
        return class_respondsToMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_respondsToMethod$address() {
        return class_respondsToMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static boolean class_respondsToMethod(MemorySegment cls, MemorySegment sel) {
        var mh$ = class_respondsToMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_respondsToMethod", cls, sel);
            }
            return (boolean)mh$.invokeExact(cls, sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_copyFromZone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_copyFromZone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static FunctionDescriptor object_copyFromZone$descriptor() {
        return object_copyFromZone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static MethodHandle object_copyFromZone$handle() {
        return object_copyFromZone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static MemorySegment object_copyFromZone$address() {
        return object_copyFromZone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static MemorySegment object_copyFromZone(MemorySegment anObject, long nBytes, MemorySegment zone) {
        var mh$ = object_copyFromZone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_copyFromZone", anObject, nBytes, zone);
            }
            return (MemorySegment)mh$.invokeExact(anObject, nBytes, zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_createInstanceFromZone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_createInstanceFromZone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static FunctionDescriptor class_createInstanceFromZone$descriptor() {
        return class_createInstanceFromZone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static MethodHandle class_createInstanceFromZone$handle() {
        return class_createInstanceFromZone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static MemorySegment class_createInstanceFromZone$address() {
        return class_createInstanceFromZone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static MemorySegment class_createInstanceFromZone(MemorySegment x0, long idxIvars, MemorySegment zone) {
        var mh$ = class_createInstanceFromZone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_createInstanceFromZone", x0, idxIvars, zone);
            }
            return (MemorySegment)mh$.invokeExact(x0, idxIvars, zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int __DARWIN_BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BYTE_ORDER 1234
     * }
     */
    public static int __DARWIN_BYTE_ORDER() {
        return __DARWIN_BYTE_ORDER;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final long __DARWIN_NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NFDBITS 32
     * }
     */
    public static long __DARWIN_NFDBITS() {
        return __DARWIN_NFDBITS;
    }
    private static final int NBBY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define NBBY 8
     * }
     */
    public static int NBBY() {
        return NBBY;
    }
    private static final long NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 32
     * }
     */
    public static long NFDBITS() {
        return NFDBITS;
    }
    private static final boolean YES = true;
    /**
     * {@snippet lang=c :
     * #define YES 1
     * }
     */
    public static boolean YES() {
        return YES;
    }
    private static final boolean NO = false;
    /**
     * {@snippet lang=c :
     * #define NO 0
     * }
     */
    public static boolean NO() {
        return NO;
    }
    private static final MemorySegment Nil = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define Nil (void*) 0
     * }
     */
    public static MemorySegment Nil() {
        return Nil;
    }
    private static final MemorySegment nil = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define nil (void*) 0
     * }
     */
    public static MemorySegment nil() {
        return nil;
    }
    private static final MemorySegment OBJC_DYNAMIC_CLASSES = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define OBJC_DYNAMIC_CLASSES (void*) -1
     * }
     */
    public static MemorySegment OBJC_DYNAMIC_CLASSES() {
        return OBJC_DYNAMIC_CLASSES;
    }
    private static final int _C_ID = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _C_ID 64
     * }
     */
    public static int _C_ID() {
        return _C_ID;
    }
    private static final int _C_CLASS = (int)35L;
    /**
     * {@snippet lang=c :
     * #define _C_CLASS 35
     * }
     */
    public static int _C_CLASS() {
        return _C_CLASS;
    }
    private static final int _C_SEL = (int)58L;
    /**
     * {@snippet lang=c :
     * #define _C_SEL 58
     * }
     */
    public static int _C_SEL() {
        return _C_SEL;
    }
    private static final int _C_CHR = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _C_CHR 99
     * }
     */
    public static int _C_CHR() {
        return _C_CHR;
    }
    private static final int _C_UCHR = (int)67L;
    /**
     * {@snippet lang=c :
     * #define _C_UCHR 67
     * }
     */
    public static int _C_UCHR() {
        return _C_UCHR;
    }
    private static final int _C_SHT = (int)115L;
    /**
     * {@snippet lang=c :
     * #define _C_SHT 115
     * }
     */
    public static int _C_SHT() {
        return _C_SHT;
    }
    private static final int _C_USHT = (int)83L;
    /**
     * {@snippet lang=c :
     * #define _C_USHT 83
     * }
     */
    public static int _C_USHT() {
        return _C_USHT;
    }
    private static final int _C_INT = (int)105L;
    /**
     * {@snippet lang=c :
     * #define _C_INT 105
     * }
     */
    public static int _C_INT() {
        return _C_INT;
    }
    private static final int _C_UINT = (int)73L;
    /**
     * {@snippet lang=c :
     * #define _C_UINT 73
     * }
     */
    public static int _C_UINT() {
        return _C_UINT;
    }
    private static final int _C_LNG = (int)108L;
    /**
     * {@snippet lang=c :
     * #define _C_LNG 108
     * }
     */
    public static int _C_LNG() {
        return _C_LNG;
    }
    private static final int _C_ULNG = (int)76L;
    /**
     * {@snippet lang=c :
     * #define _C_ULNG 76
     * }
     */
    public static int _C_ULNG() {
        return _C_ULNG;
    }
    private static final int _C_LNG_LNG = (int)113L;
    /**
     * {@snippet lang=c :
     * #define _C_LNG_LNG 113
     * }
     */
    public static int _C_LNG_LNG() {
        return _C_LNG_LNG;
    }
    private static final int _C_ULNG_LNG = (int)81L;
    /**
     * {@snippet lang=c :
     * #define _C_ULNG_LNG 81
     * }
     */
    public static int _C_ULNG_LNG() {
        return _C_ULNG_LNG;
    }
    private static final int _C_INT128 = (int)116L;
    /**
     * {@snippet lang=c :
     * #define _C_INT128 116
     * }
     */
    public static int _C_INT128() {
        return _C_INT128;
    }
    private static final int _C_UINT128 = (int)84L;
    /**
     * {@snippet lang=c :
     * #define _C_UINT128 84
     * }
     */
    public static int _C_UINT128() {
        return _C_UINT128;
    }
    private static final int _C_FLT = (int)102L;
    /**
     * {@snippet lang=c :
     * #define _C_FLT 102
     * }
     */
    public static int _C_FLT() {
        return _C_FLT;
    }
    private static final int _C_DBL = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _C_DBL 100
     * }
     */
    public static int _C_DBL() {
        return _C_DBL;
    }
    private static final int _C_LNG_DBL = (int)68L;
    /**
     * {@snippet lang=c :
     * #define _C_LNG_DBL 68
     * }
     */
    public static int _C_LNG_DBL() {
        return _C_LNG_DBL;
    }
    private static final int _C_BFLD = (int)98L;
    /**
     * {@snippet lang=c :
     * #define _C_BFLD 98
     * }
     */
    public static int _C_BFLD() {
        return _C_BFLD;
    }
    private static final int _C_BOOL = (int)66L;
    /**
     * {@snippet lang=c :
     * #define _C_BOOL 66
     * }
     */
    public static int _C_BOOL() {
        return _C_BOOL;
    }
    private static final int _C_VOID = (int)118L;
    /**
     * {@snippet lang=c :
     * #define _C_VOID 118
     * }
     */
    public static int _C_VOID() {
        return _C_VOID;
    }
    private static final int _C_UNDEF = (int)63L;
    /**
     * {@snippet lang=c :
     * #define _C_UNDEF 63
     * }
     */
    public static int _C_UNDEF() {
        return _C_UNDEF;
    }
    private static final int _C_PTR = (int)94L;
    /**
     * {@snippet lang=c :
     * #define _C_PTR 94
     * }
     */
    public static int _C_PTR() {
        return _C_PTR;
    }
    private static final int _C_CHARPTR = (int)42L;
    /**
     * {@snippet lang=c :
     * #define _C_CHARPTR 42
     * }
     */
    public static int _C_CHARPTR() {
        return _C_CHARPTR;
    }
    private static final int _C_ATOM = (int)37L;
    /**
     * {@snippet lang=c :
     * #define _C_ATOM 37
     * }
     */
    public static int _C_ATOM() {
        return _C_ATOM;
    }
    private static final int _C_ARY_B = (int)91L;
    /**
     * {@snippet lang=c :
     * #define _C_ARY_B 91
     * }
     */
    public static int _C_ARY_B() {
        return _C_ARY_B;
    }
    private static final int _C_ARY_E = (int)93L;
    /**
     * {@snippet lang=c :
     * #define _C_ARY_E 93
     * }
     */
    public static int _C_ARY_E() {
        return _C_ARY_E;
    }
    private static final int _C_UNION_B = (int)40L;
    /**
     * {@snippet lang=c :
     * #define _C_UNION_B 40
     * }
     */
    public static int _C_UNION_B() {
        return _C_UNION_B;
    }
    private static final int _C_UNION_E = (int)41L;
    /**
     * {@snippet lang=c :
     * #define _C_UNION_E 41
     * }
     */
    public static int _C_UNION_E() {
        return _C_UNION_E;
    }
    private static final int _C_STRUCT_B = (int)123L;
    /**
     * {@snippet lang=c :
     * #define _C_STRUCT_B 123
     * }
     */
    public static int _C_STRUCT_B() {
        return _C_STRUCT_B;
    }
    private static final int _C_STRUCT_E = (int)125L;
    /**
     * {@snippet lang=c :
     * #define _C_STRUCT_E 125
     * }
     */
    public static int _C_STRUCT_E() {
        return _C_STRUCT_E;
    }
    private static final int _C_VECTOR = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _C_VECTOR 33
     * }
     */
    public static int _C_VECTOR() {
        return _C_VECTOR;
    }
    private static final int _C_COMPLEX = (int)106L;
    /**
     * {@snippet lang=c :
     * #define _C_COMPLEX 106
     * }
     */
    public static int _C_COMPLEX() {
        return _C_COMPLEX;
    }
    private static final int _C_ATOMIC = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _C_ATOMIC 65
     * }
     */
    public static int _C_ATOMIC() {
        return _C_ATOMIC;
    }
    private static final int _C_CONST = (int)114L;
    /**
     * {@snippet lang=c :
     * #define _C_CONST 114
     * }
     */
    public static int _C_CONST() {
        return _C_CONST;
    }
    private static final int _C_IN = (int)110L;
    /**
     * {@snippet lang=c :
     * #define _C_IN 110
     * }
     */
    public static int _C_IN() {
        return _C_IN;
    }
    private static final int _C_INOUT = (int)78L;
    /**
     * {@snippet lang=c :
     * #define _C_INOUT 78
     * }
     */
    public static int _C_INOUT() {
        return _C_INOUT;
    }
    private static final int _C_OUT = (int)111L;
    /**
     * {@snippet lang=c :
     * #define _C_OUT 111
     * }
     */
    public static int _C_OUT() {
        return _C_OUT;
    }
    private static final int _C_BYCOPY = (int)79L;
    /**
     * {@snippet lang=c :
     * #define _C_BYCOPY 79
     * }
     */
    public static int _C_BYCOPY() {
        return _C_BYCOPY;
    }
    private static final int _C_BYREF = (int)82L;
    /**
     * {@snippet lang=c :
     * #define _C_BYREF 82
     * }
     */
    public static int _C_BYREF() {
        return _C_BYREF;
    }
    private static final int _C_ONEWAY = (int)86L;
    /**
     * {@snippet lang=c :
     * #define _C_ONEWAY 86
     * }
     */
    public static int _C_ONEWAY() {
        return _C_ONEWAY;
    }
    private static final int _C_GNUREGISTER = (int)43L;
    /**
     * {@snippet lang=c :
     * #define _C_GNUREGISTER 43
     * }
     */
    public static int _C_GNUREGISTER() {
        return _C_GNUREGISTER;
    }
}

