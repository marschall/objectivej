// Generated by jextract

package com.github.marschall.objectivej.header;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class ObjCRuntime_1 extends ObjCRuntime_2 {

    ObjCRuntime_1() {
        // Should not be called directly
    }
    private static final int THREAD_STATE_NONE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_NONE 5
     * }
     */
    public static int THREAD_STATE_NONE() {
        return THREAD_STATE_NONE;
    }
    private static final int ARM_THREAD_STATE64 = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ARM_THREAD_STATE64 6
     * }
     */
    public static int ARM_THREAD_STATE64() {
        return ARM_THREAD_STATE64;
    }
    private static final int ARM_EXCEPTION_STATE64 = (int)7L;
    /**
     * {@snippet lang=c :
     * #define ARM_EXCEPTION_STATE64 7
     * }
     */
    public static int ARM_EXCEPTION_STATE64() {
        return ARM_EXCEPTION_STATE64;
    }
    private static final int ARM_THREAD_STATE32 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define ARM_THREAD_STATE32 9
     * }
     */
    public static int ARM_THREAD_STATE32() {
        return ARM_THREAD_STATE32;
    }
    private static final int ARM_EXCEPTION_STATE64_V2 = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ARM_EXCEPTION_STATE64_V2 10
     * }
     */
    public static int ARM_EXCEPTION_STATE64_V2() {
        return ARM_EXCEPTION_STATE64_V2;
    }
    private static final int ARM_DEBUG_STATE32 = (int)14L;
    /**
     * {@snippet lang=c :
     * #define ARM_DEBUG_STATE32 14
     * }
     */
    public static int ARM_DEBUG_STATE32() {
        return ARM_DEBUG_STATE32;
    }
    private static final int ARM_DEBUG_STATE64 = (int)15L;
    /**
     * {@snippet lang=c :
     * #define ARM_DEBUG_STATE64 15
     * }
     */
    public static int ARM_DEBUG_STATE64() {
        return ARM_DEBUG_STATE64;
    }
    private static final int ARM_NEON_STATE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define ARM_NEON_STATE 16
     * }
     */
    public static int ARM_NEON_STATE() {
        return ARM_NEON_STATE;
    }
    private static final int ARM_NEON_STATE64 = (int)17L;
    /**
     * {@snippet lang=c :
     * #define ARM_NEON_STATE64 17
     * }
     */
    public static int ARM_NEON_STATE64() {
        return ARM_NEON_STATE64;
    }
    private static final int ARM_CPMU_STATE64 = (int)18L;
    /**
     * {@snippet lang=c :
     * #define ARM_CPMU_STATE64 18
     * }
     */
    public static int ARM_CPMU_STATE64() {
        return ARM_CPMU_STATE64;
    }
    private static final int ARM_PAGEIN_STATE = (int)27L;
    /**
     * {@snippet lang=c :
     * #define ARM_PAGEIN_STATE 27
     * }
     */
    public static int ARM_PAGEIN_STATE() {
        return ARM_PAGEIN_STATE;
    }
    private static final int THREAD_STATE_FLAVORS = (int)29L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_FLAVORS 29
     * }
     */
    public static int THREAD_STATE_FLAVORS() {
        return THREAD_STATE_FLAVORS;
    }
    private static final int THREAD_STATE_FLAVOR_LIST = (int)0L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_FLAVOR_LIST 0
     * }
     */
    public static int THREAD_STATE_FLAVOR_LIST() {
        return THREAD_STATE_FLAVOR_LIST;
    }
    private static final int THREAD_STATE_FLAVOR_LIST_NEW = (int)128L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_FLAVOR_LIST_NEW 128
     * }
     */
    public static int THREAD_STATE_FLAVOR_LIST_NEW() {
        return THREAD_STATE_FLAVOR_LIST_NEW;
    }
    private static final int THREAD_STATE_FLAVOR_LIST_10_9 = (int)129L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_FLAVOR_LIST_10_9 129
     * }
     */
    public static int THREAD_STATE_FLAVOR_LIST_10_9() {
        return THREAD_STATE_FLAVOR_LIST_10_9;
    }
    private static final int THREAD_STATE_FLAVOR_LIST_10_13 = (int)130L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_FLAVOR_LIST_10_13 130
     * }
     */
    public static int THREAD_STATE_FLAVOR_LIST_10_13() {
        return THREAD_STATE_FLAVOR_LIST_10_13;
    }
    private static final int THREAD_STATE_FLAVOR_LIST_10_15 = (int)131L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STATE_FLAVOR_LIST_10_15 131
     * }
     */
    public static int THREAD_STATE_FLAVOR_LIST_10_15() {
        return THREAD_STATE_FLAVOR_LIST_10_15;
    }
    private static final int THREAD_CONVERT_THREAD_STATE_TO_SELF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_CONVERT_THREAD_STATE_TO_SELF 1
     * }
     */
    public static int THREAD_CONVERT_THREAD_STATE_TO_SELF() {
        return THREAD_CONVERT_THREAD_STATE_TO_SELF;
    }
    private static final int THREAD_CONVERT_THREAD_STATE_FROM_SELF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define THREAD_CONVERT_THREAD_STATE_FROM_SELF 2
     * }
     */
    public static int THREAD_CONVERT_THREAD_STATE_FROM_SELF() {
        return THREAD_CONVERT_THREAD_STATE_FROM_SELF;
    }
    private static final int PROCESSOR_CPU_STAT = (int)268435459L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_CPU_STAT 268435459
     * }
     */
    public static int PROCESSOR_CPU_STAT() {
        return PROCESSOR_CPU_STAT;
    }
    private static final int PROCESSOR_CPU_STAT64 = (int)268435460L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_CPU_STAT64 268435460
     * }
     */
    public static int PROCESSOR_CPU_STAT64() {
        return PROCESSOR_CPU_STAT64;
    }
    private static final int PROCESSOR_BASIC_INFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_BASIC_INFO 1
     * }
     */
    public static int PROCESSOR_BASIC_INFO() {
        return PROCESSOR_BASIC_INFO;
    }
    private static final int PROCESSOR_CPU_LOAD_INFO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_CPU_LOAD_INFO 2
     * }
     */
    public static int PROCESSOR_CPU_LOAD_INFO() {
        return PROCESSOR_CPU_LOAD_INFO;
    }
    private static final int PROCESSOR_PM_REGS_INFO = (int)268435457L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_PM_REGS_INFO 268435457
     * }
     */
    public static int PROCESSOR_PM_REGS_INFO() {
        return PROCESSOR_PM_REGS_INFO;
    }
    private static final int PROCESSOR_TEMPERATURE = (int)268435458L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_TEMPERATURE 268435458
     * }
     */
    public static int PROCESSOR_TEMPERATURE() {
        return PROCESSOR_TEMPERATURE;
    }
    private static final int LOAD_SCALE = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define LOAD_SCALE 1000
     * }
     */
    public static int LOAD_SCALE() {
        return LOAD_SCALE;
    }
    private static final int PROCESSOR_SET_BASIC_INFO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_SET_BASIC_INFO 5
     * }
     */
    public static int PROCESSOR_SET_BASIC_INFO() {
        return PROCESSOR_SET_BASIC_INFO;
    }
    private static final int PROCESSOR_SET_LOAD_INFO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_SET_LOAD_INFO 4
     * }
     */
    public static int PROCESSOR_SET_LOAD_INFO() {
        return PROCESSOR_SET_LOAD_INFO;
    }
    private static final int POLICY_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define POLICY_NULL 0
     * }
     */
    public static int POLICY_NULL() {
        return POLICY_NULL;
    }
    private static final int POLICY_TIMESHARE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLICY_TIMESHARE 1
     * }
     */
    public static int POLICY_TIMESHARE() {
        return POLICY_TIMESHARE;
    }
    private static final int POLICY_RR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define POLICY_RR 2
     * }
     */
    public static int POLICY_RR() {
        return POLICY_RR;
    }
    private static final int POLICY_FIFO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define POLICY_FIFO 4
     * }
     */
    public static int POLICY_FIFO() {
        return POLICY_FIFO;
    }
    private static final int TASK_BASIC_INFO_32 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC_INFO_32 4
     * }
     */
    public static int TASK_BASIC_INFO_32() {
        return TASK_BASIC_INFO_32;
    }
    private static final int TASK_BASIC2_INFO_32 = (int)6L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC2_INFO_32 6
     * }
     */
    public static int TASK_BASIC2_INFO_32() {
        return TASK_BASIC2_INFO_32;
    }
    private static final int TASK_EVENTS_INFO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TASK_EVENTS_INFO 2
     * }
     */
    public static int TASK_EVENTS_INFO() {
        return TASK_EVENTS_INFO;
    }
    private static final int TASK_THREAD_TIMES_INFO = (int)3L;
    /**
     * {@snippet lang=c :
     * #define TASK_THREAD_TIMES_INFO 3
     * }
     */
    public static int TASK_THREAD_TIMES_INFO() {
        return TASK_THREAD_TIMES_INFO;
    }
    private static final int TASK_ABSOLUTETIME_INFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_ABSOLUTETIME_INFO 1
     * }
     */
    public static int TASK_ABSOLUTETIME_INFO() {
        return TASK_ABSOLUTETIME_INFO;
    }
    private static final int TASK_KERNELMEMORY_INFO = (int)7L;
    /**
     * {@snippet lang=c :
     * #define TASK_KERNELMEMORY_INFO 7
     * }
     */
    public static int TASK_KERNELMEMORY_INFO() {
        return TASK_KERNELMEMORY_INFO;
    }
    private static final int TASK_SECURITY_TOKEN = (int)13L;
    /**
     * {@snippet lang=c :
     * #define TASK_SECURITY_TOKEN 13
     * }
     */
    public static int TASK_SECURITY_TOKEN() {
        return TASK_SECURITY_TOKEN;
    }
    private static final int TASK_AUDIT_TOKEN = (int)15L;
    /**
     * {@snippet lang=c :
     * #define TASK_AUDIT_TOKEN 15
     * }
     */
    public static int TASK_AUDIT_TOKEN() {
        return TASK_AUDIT_TOKEN;
    }
    private static final int TASK_AFFINITY_TAG_INFO = (int)16L;
    /**
     * {@snippet lang=c :
     * #define TASK_AFFINITY_TAG_INFO 16
     * }
     */
    public static int TASK_AFFINITY_TAG_INFO() {
        return TASK_AFFINITY_TAG_INFO;
    }
    private static final int TASK_DYLD_INFO = (int)17L;
    /**
     * {@snippet lang=c :
     * #define TASK_DYLD_INFO 17
     * }
     */
    public static int TASK_DYLD_INFO() {
        return TASK_DYLD_INFO;
    }
    private static final int TASK_DYLD_ALL_IMAGE_INFO_32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define TASK_DYLD_ALL_IMAGE_INFO_32 0
     * }
     */
    public static int TASK_DYLD_ALL_IMAGE_INFO_32() {
        return TASK_DYLD_ALL_IMAGE_INFO_32;
    }
    private static final int TASK_DYLD_ALL_IMAGE_INFO_64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_DYLD_ALL_IMAGE_INFO_64 1
     * }
     */
    public static int TASK_DYLD_ALL_IMAGE_INFO_64() {
        return TASK_DYLD_ALL_IMAGE_INFO_64;
    }
    private static final int TASK_BASIC_INFO_64_2 = (int)18L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC_INFO_64_2 18
     * }
     */
    public static int TASK_BASIC_INFO_64_2() {
        return TASK_BASIC_INFO_64_2;
    }
    private static final int TASK_EXTMOD_INFO = (int)19L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXTMOD_INFO 19
     * }
     */
    public static int TASK_EXTMOD_INFO() {
        return TASK_EXTMOD_INFO;
    }
    private static final int MACH_TASK_BASIC_INFO = (int)20L;
    /**
     * {@snippet lang=c :
     * #define MACH_TASK_BASIC_INFO 20
     * }
     */
    public static int MACH_TASK_BASIC_INFO() {
        return MACH_TASK_BASIC_INFO;
    }
    private static final int TASK_POWER_INFO = (int)21L;
    /**
     * {@snippet lang=c :
     * #define TASK_POWER_INFO 21
     * }
     */
    public static int TASK_POWER_INFO() {
        return TASK_POWER_INFO;
    }
    private static final int TASK_VM_INFO = (int)22L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO 22
     * }
     */
    public static int TASK_VM_INFO() {
        return TASK_VM_INFO;
    }
    private static final int TASK_VM_INFO_PURGEABLE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_PURGEABLE 23
     * }
     */
    public static int TASK_VM_INFO_PURGEABLE() {
        return TASK_VM_INFO_PURGEABLE;
    }
    private static final int TASK_TRACE_MEMORY_INFO = (int)24L;
    /**
     * {@snippet lang=c :
     * #define TASK_TRACE_MEMORY_INFO 24
     * }
     */
    public static int TASK_TRACE_MEMORY_INFO() {
        return TASK_TRACE_MEMORY_INFO;
    }
    private static final int TASK_WAIT_STATE_INFO = (int)25L;
    /**
     * {@snippet lang=c :
     * #define TASK_WAIT_STATE_INFO 25
     * }
     */
    public static int TASK_WAIT_STATE_INFO() {
        return TASK_WAIT_STATE_INFO;
    }
    private static final int TASK_POWER_INFO_V2 = (int)26L;
    /**
     * {@snippet lang=c :
     * #define TASK_POWER_INFO_V2 26
     * }
     */
    public static int TASK_POWER_INFO_V2() {
        return TASK_POWER_INFO_V2;
    }
    private static final int TASK_VM_INFO_PURGEABLE_ACCOUNT = (int)27L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_PURGEABLE_ACCOUNT 27
     * }
     */
    public static int TASK_VM_INFO_PURGEABLE_ACCOUNT() {
        return TASK_VM_INFO_PURGEABLE_ACCOUNT;
    }
    private static final int TASK_FLAGS_INFO = (int)28L;
    /**
     * {@snippet lang=c :
     * #define TASK_FLAGS_INFO 28
     * }
     */
    public static int TASK_FLAGS_INFO() {
        return TASK_FLAGS_INFO;
    }
    private static final int TF_LP64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TF_LP64 1
     * }
     */
    public static int TF_LP64() {
        return TF_LP64;
    }
    private static final int TF_64B_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TF_64B_DATA 2
     * }
     */
    public static int TF_64B_DATA() {
        return TF_64B_DATA;
    }
    private static final int TASK_DEBUG_INFO_INTERNAL = (int)29L;
    /**
     * {@snippet lang=c :
     * #define TASK_DEBUG_INFO_INTERNAL 29
     * }
     */
    public static int TASK_DEBUG_INFO_INTERNAL() {
        return TASK_DEBUG_INFO_INTERNAL;
    }
    private static final int TASK_EXC_GUARD_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_NONE 0
     * }
     */
    public static int TASK_EXC_GUARD_NONE() {
        return TASK_EXC_GUARD_NONE;
    }
    private static final int TASK_EXC_GUARD_VM_DELIVER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_VM_DELIVER 1
     * }
     */
    public static int TASK_EXC_GUARD_VM_DELIVER() {
        return TASK_EXC_GUARD_VM_DELIVER;
    }
    private static final int TASK_EXC_GUARD_VM_ONCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_VM_ONCE 2
     * }
     */
    public static int TASK_EXC_GUARD_VM_ONCE() {
        return TASK_EXC_GUARD_VM_ONCE;
    }
    private static final int TASK_EXC_GUARD_VM_CORPSE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_VM_CORPSE 4
     * }
     */
    public static int TASK_EXC_GUARD_VM_CORPSE() {
        return TASK_EXC_GUARD_VM_CORPSE;
    }
    private static final int TASK_EXC_GUARD_VM_FATAL = (int)8L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_VM_FATAL 8
     * }
     */
    public static int TASK_EXC_GUARD_VM_FATAL() {
        return TASK_EXC_GUARD_VM_FATAL;
    }
    private static final int TASK_EXC_GUARD_VM_ALL = (int)15L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_VM_ALL 15
     * }
     */
    public static int TASK_EXC_GUARD_VM_ALL() {
        return TASK_EXC_GUARD_VM_ALL;
    }
    private static final int TASK_EXC_GUARD_MP_DELIVER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_MP_DELIVER 16
     * }
     */
    public static int TASK_EXC_GUARD_MP_DELIVER() {
        return TASK_EXC_GUARD_MP_DELIVER;
    }
    private static final int TASK_EXC_GUARD_MP_ONCE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_MP_ONCE 32
     * }
     */
    public static int TASK_EXC_GUARD_MP_ONCE() {
        return TASK_EXC_GUARD_MP_ONCE;
    }
    private static final int TASK_EXC_GUARD_MP_CORPSE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_MP_CORPSE 64
     * }
     */
    public static int TASK_EXC_GUARD_MP_CORPSE() {
        return TASK_EXC_GUARD_MP_CORPSE;
    }
    private static final int TASK_EXC_GUARD_MP_FATAL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_MP_FATAL 128
     * }
     */
    public static int TASK_EXC_GUARD_MP_FATAL() {
        return TASK_EXC_GUARD_MP_FATAL;
    }
    private static final int TASK_EXC_GUARD_MP_ALL = (int)240L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_MP_ALL 240
     * }
     */
    public static int TASK_EXC_GUARD_MP_ALL() {
        return TASK_EXC_GUARD_MP_ALL;
    }
    private static final int TASK_EXC_GUARD_ALL = (int)255L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXC_GUARD_ALL 255
     * }
     */
    public static int TASK_EXC_GUARD_ALL() {
        return TASK_EXC_GUARD_ALL;
    }
    private static final int TASK_CORPSE_FORKING_DISABLED_MEM_DIAG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_CORPSE_FORKING_DISABLED_MEM_DIAG 1
     * }
     */
    public static int TASK_CORPSE_FORKING_DISABLED_MEM_DIAG() {
        return TASK_CORPSE_FORKING_DISABLED_MEM_DIAG;
    }
    private static final int TASK_SCHED_TIMESHARE_INFO = (int)10L;
    /**
     * {@snippet lang=c :
     * #define TASK_SCHED_TIMESHARE_INFO 10
     * }
     */
    public static int TASK_SCHED_TIMESHARE_INFO() {
        return TASK_SCHED_TIMESHARE_INFO;
    }
    private static final int TASK_SCHED_RR_INFO = (int)11L;
    /**
     * {@snippet lang=c :
     * #define TASK_SCHED_RR_INFO 11
     * }
     */
    public static int TASK_SCHED_RR_INFO() {
        return TASK_SCHED_RR_INFO;
    }
    private static final int TASK_SCHED_FIFO_INFO = (int)12L;
    /**
     * {@snippet lang=c :
     * #define TASK_SCHED_FIFO_INFO 12
     * }
     */
    public static int TASK_SCHED_FIFO_INFO() {
        return TASK_SCHED_FIFO_INFO;
    }
    private static final int TASK_SCHED_INFO = (int)14L;
    /**
     * {@snippet lang=c :
     * #define TASK_SCHED_INFO 14
     * }
     */
    public static int TASK_SCHED_INFO() {
        return TASK_SCHED_INFO;
    }
    private static final int TASK_CATEGORY_POLICY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_CATEGORY_POLICY 1
     * }
     */
    public static int TASK_CATEGORY_POLICY() {
        return TASK_CATEGORY_POLICY;
    }
    private static final int TASK_SUPPRESSION_POLICY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define TASK_SUPPRESSION_POLICY 3
     * }
     */
    public static int TASK_SUPPRESSION_POLICY() {
        return TASK_SUPPRESSION_POLICY;
    }
    private static final int TASK_POLICY_STATE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TASK_POLICY_STATE 4
     * }
     */
    public static int TASK_POLICY_STATE() {
        return TASK_POLICY_STATE;
    }
    private static final int TASK_BASE_QOS_POLICY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASE_QOS_POLICY 8
     * }
     */
    public static int TASK_BASE_QOS_POLICY() {
        return TASK_BASE_QOS_POLICY;
    }
    private static final int TASK_OVERRIDE_QOS_POLICY = (int)9L;
    /**
     * {@snippet lang=c :
     * #define TASK_OVERRIDE_QOS_POLICY 9
     * }
     */
    public static int TASK_OVERRIDE_QOS_POLICY() {
        return TASK_OVERRIDE_QOS_POLICY;
    }
    private static final int TASK_BASE_LATENCY_QOS_POLICY = (int)10L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASE_LATENCY_QOS_POLICY 10
     * }
     */
    public static int TASK_BASE_LATENCY_QOS_POLICY() {
        return TASK_BASE_LATENCY_QOS_POLICY;
    }
    private static final int TASK_BASE_THROUGHPUT_QOS_POLICY = (int)11L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASE_THROUGHPUT_QOS_POLICY 11
     * }
     */
    public static int TASK_BASE_THROUGHPUT_QOS_POLICY() {
        return TASK_BASE_THROUGHPUT_QOS_POLICY;
    }
    private static final int PROC_FLAG_DARWINBG = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_DARWINBG 32768
     * }
     */
    public static int PROC_FLAG_DARWINBG() {
        return PROC_FLAG_DARWINBG;
    }
    private static final int PROC_FLAG_EXT_DARWINBG = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_EXT_DARWINBG 65536
     * }
     */
    public static int PROC_FLAG_EXT_DARWINBG() {
        return PROC_FLAG_EXT_DARWINBG;
    }
    private static final int PROC_FLAG_IOS_APPLEDAEMON = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_IOS_APPLEDAEMON 131072
     * }
     */
    public static int PROC_FLAG_IOS_APPLEDAEMON() {
        return PROC_FLAG_IOS_APPLEDAEMON;
    }
    private static final int PROC_FLAG_IOS_IMPPROMOTION = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_IOS_IMPPROMOTION 524288
     * }
     */
    public static int PROC_FLAG_IOS_IMPPROMOTION() {
        return PROC_FLAG_IOS_IMPPROMOTION;
    }
    private static final int PROC_FLAG_ADAPTIVE = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_ADAPTIVE 1048576
     * }
     */
    public static int PROC_FLAG_ADAPTIVE() {
        return PROC_FLAG_ADAPTIVE;
    }
    private static final int PROC_FLAG_ADAPTIVE_IMPORTANT = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_ADAPTIVE_IMPORTANT 2097152
     * }
     */
    public static int PROC_FLAG_ADAPTIVE_IMPORTANT() {
        return PROC_FLAG_ADAPTIVE_IMPORTANT;
    }
    private static final int PROC_FLAG_IMPORTANCE_DONOR = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_IMPORTANCE_DONOR 4194304
     * }
     */
    public static int PROC_FLAG_IMPORTANCE_DONOR() {
        return PROC_FLAG_IMPORTANCE_DONOR;
    }
    private static final int PROC_FLAG_SUPPRESSED = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_SUPPRESSED 8388608
     * }
     */
    public static int PROC_FLAG_SUPPRESSED() {
        return PROC_FLAG_SUPPRESSED;
    }
    private static final int PROC_FLAG_APPLICATION = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_APPLICATION 16777216
     * }
     */
    public static int PROC_FLAG_APPLICATION() {
        return PROC_FLAG_APPLICATION;
    }
    private static final int TASK_KERNEL_PORT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_KERNEL_PORT 1
     * }
     */
    public static int TASK_KERNEL_PORT() {
        return TASK_KERNEL_PORT;
    }
    private static final int TASK_HOST_PORT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TASK_HOST_PORT 2
     * }
     */
    public static int TASK_HOST_PORT() {
        return TASK_HOST_PORT;
    }
    private static final int TASK_NAME_PORT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define TASK_NAME_PORT 3
     * }
     */
    public static int TASK_NAME_PORT() {
        return TASK_NAME_PORT;
    }
    private static final int TASK_BOOTSTRAP_PORT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TASK_BOOTSTRAP_PORT 4
     * }
     */
    public static int TASK_BOOTSTRAP_PORT() {
        return TASK_BOOTSTRAP_PORT;
    }
    private static final int TASK_INSPECT_PORT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define TASK_INSPECT_PORT 5
     * }
     */
    public static int TASK_INSPECT_PORT() {
        return TASK_INSPECT_PORT;
    }
    private static final int TASK_READ_PORT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define TASK_READ_PORT 6
     * }
     */
    public static int TASK_READ_PORT() {
        return TASK_READ_PORT;
    }
    private static final int TASK_ACCESS_PORT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define TASK_ACCESS_PORT 9
     * }
     */
    public static int TASK_ACCESS_PORT() {
        return TASK_ACCESS_PORT;
    }
    private static final int TASK_DEBUG_CONTROL_PORT = (int)10L;
    /**
     * {@snippet lang=c :
     * #define TASK_DEBUG_CONTROL_PORT 10
     * }
     */
    public static int TASK_DEBUG_CONTROL_PORT() {
        return TASK_DEBUG_CONTROL_PORT;
    }
    private static final int TASK_RESOURCE_NOTIFY_PORT = (int)11L;
    /**
     * {@snippet lang=c :
     * #define TASK_RESOURCE_NOTIFY_PORT 11
     * }
     */
    public static int TASK_RESOURCE_NOTIFY_PORT() {
        return TASK_RESOURCE_NOTIFY_PORT;
    }
    private static final int THREAD_BASIC_INFO = (int)3L;
    /**
     * {@snippet lang=c :
     * #define THREAD_BASIC_INFO 3
     * }
     */
    public static int THREAD_BASIC_INFO() {
        return THREAD_BASIC_INFO;
    }
    private static final int THREAD_IDENTIFIER_INFO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define THREAD_IDENTIFIER_INFO 4
     * }
     */
    public static int THREAD_IDENTIFIER_INFO() {
        return THREAD_IDENTIFIER_INFO;
    }
    private static final int TH_USAGE_SCALE = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define TH_USAGE_SCALE 1000
     * }
     */
    public static int TH_USAGE_SCALE() {
        return TH_USAGE_SCALE;
    }
    private static final int TH_STATE_RUNNING = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_RUNNING 1
     * }
     */
    public static int TH_STATE_RUNNING() {
        return TH_STATE_RUNNING;
    }
    private static final int TH_STATE_STOPPED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_STOPPED 2
     * }
     */
    public static int TH_STATE_STOPPED() {
        return TH_STATE_STOPPED;
    }
    private static final int TH_STATE_WAITING = (int)3L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_WAITING 3
     * }
     */
    public static int TH_STATE_WAITING() {
        return TH_STATE_WAITING;
    }
    private static final int TH_STATE_UNINTERRUPTIBLE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_UNINTERRUPTIBLE 4
     * }
     */
    public static int TH_STATE_UNINTERRUPTIBLE() {
        return TH_STATE_UNINTERRUPTIBLE;
    }
    private static final int TH_STATE_HALTED = (int)5L;
    /**
     * {@snippet lang=c :
     * #define TH_STATE_HALTED 5
     * }
     */
    public static int TH_STATE_HALTED() {
        return TH_STATE_HALTED;
    }
    private static final int TH_FLAGS_SWAPPED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TH_FLAGS_SWAPPED 1
     * }
     */
    public static int TH_FLAGS_SWAPPED() {
        return TH_FLAGS_SWAPPED;
    }
    private static final int TH_FLAGS_IDLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TH_FLAGS_IDLE 2
     * }
     */
    public static int TH_FLAGS_IDLE() {
        return TH_FLAGS_IDLE;
    }
    private static final int TH_FLAGS_GLOBAL_FORCED_IDLE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TH_FLAGS_GLOBAL_FORCED_IDLE 4
     * }
     */
    public static int TH_FLAGS_GLOBAL_FORCED_IDLE() {
        return TH_FLAGS_GLOBAL_FORCED_IDLE;
    }
    private static final int THREAD_EXTENDED_INFO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define THREAD_EXTENDED_INFO 5
     * }
     */
    public static int THREAD_EXTENDED_INFO() {
        return THREAD_EXTENDED_INFO;
    }
    private static final int MAXTHREADNAMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define MAXTHREADNAMESIZE 64
     * }
     */
    public static int MAXTHREADNAMESIZE() {
        return MAXTHREADNAMESIZE;
    }
    private static final int THREAD_DEBUG_INFO_INTERNAL = (int)6L;
    /**
     * {@snippet lang=c :
     * #define THREAD_DEBUG_INFO_INTERNAL 6
     * }
     */
    public static int THREAD_DEBUG_INFO_INTERNAL() {
        return THREAD_DEBUG_INFO_INTERNAL;
    }
    private static final int IO_NUM_PRIORITIES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IO_NUM_PRIORITIES 4
     * }
     */
    public static int IO_NUM_PRIORITIES() {
        return IO_NUM_PRIORITIES;
    }
    private static final int THREAD_SCHED_TIMESHARE_INFO = (int)10L;
    /**
     * {@snippet lang=c :
     * #define THREAD_SCHED_TIMESHARE_INFO 10
     * }
     */
    public static int THREAD_SCHED_TIMESHARE_INFO() {
        return THREAD_SCHED_TIMESHARE_INFO;
    }
    private static final int THREAD_SCHED_RR_INFO = (int)11L;
    /**
     * {@snippet lang=c :
     * #define THREAD_SCHED_RR_INFO 11
     * }
     */
    public static int THREAD_SCHED_RR_INFO() {
        return THREAD_SCHED_RR_INFO;
    }
    private static final int THREAD_SCHED_FIFO_INFO = (int)12L;
    /**
     * {@snippet lang=c :
     * #define THREAD_SCHED_FIFO_INFO 12
     * }
     */
    public static int THREAD_SCHED_FIFO_INFO() {
        return THREAD_SCHED_FIFO_INFO;
    }
    private static final int THREAD_STANDARD_POLICY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STANDARD_POLICY 1
     * }
     */
    public static int THREAD_STANDARD_POLICY() {
        return THREAD_STANDARD_POLICY;
    }
    private static final int THREAD_STANDARD_POLICY_COUNT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define THREAD_STANDARD_POLICY_COUNT 0
     * }
     */
    public static int THREAD_STANDARD_POLICY_COUNT() {
        return THREAD_STANDARD_POLICY_COUNT;
    }
    private static final int THREAD_EXTENDED_POLICY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_EXTENDED_POLICY 1
     * }
     */
    public static int THREAD_EXTENDED_POLICY() {
        return THREAD_EXTENDED_POLICY;
    }
    private static final int THREAD_TIME_CONSTRAINT_POLICY = (int)2L;
    /**
     * {@snippet lang=c :
     * #define THREAD_TIME_CONSTRAINT_POLICY 2
     * }
     */
    public static int THREAD_TIME_CONSTRAINT_POLICY() {
        return THREAD_TIME_CONSTRAINT_POLICY;
    }
    private static final int THREAD_PRECEDENCE_POLICY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define THREAD_PRECEDENCE_POLICY 3
     * }
     */
    public static int THREAD_PRECEDENCE_POLICY() {
        return THREAD_PRECEDENCE_POLICY;
    }
    private static final int THREAD_AFFINITY_POLICY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define THREAD_AFFINITY_POLICY 4
     * }
     */
    public static int THREAD_AFFINITY_POLICY() {
        return THREAD_AFFINITY_POLICY;
    }
    private static final int THREAD_AFFINITY_TAG_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define THREAD_AFFINITY_TAG_NULL 0
     * }
     */
    public static int THREAD_AFFINITY_TAG_NULL() {
        return THREAD_AFFINITY_TAG_NULL;
    }
    private static final int THREAD_BACKGROUND_POLICY = (int)5L;
    /**
     * {@snippet lang=c :
     * #define THREAD_BACKGROUND_POLICY 5
     * }
     */
    public static int THREAD_BACKGROUND_POLICY() {
        return THREAD_BACKGROUND_POLICY;
    }
    private static final int THREAD_BACKGROUND_POLICY_DARWIN_BG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define THREAD_BACKGROUND_POLICY_DARWIN_BG 4096
     * }
     */
    public static int THREAD_BACKGROUND_POLICY_DARWIN_BG() {
        return THREAD_BACKGROUND_POLICY_DARWIN_BG;
    }
    private static final int THREAD_LATENCY_QOS_POLICY = (int)7L;
    /**
     * {@snippet lang=c :
     * #define THREAD_LATENCY_QOS_POLICY 7
     * }
     */
    public static int THREAD_LATENCY_QOS_POLICY() {
        return THREAD_LATENCY_QOS_POLICY;
    }
    private static final int THREAD_THROUGHPUT_QOS_POLICY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define THREAD_THROUGHPUT_QOS_POLICY 8
     * }
     */
    public static int THREAD_THROUGHPUT_QOS_POLICY() {
        return THREAD_THROUGHPUT_QOS_POLICY;
    }
    private static final int THREAD_KERNEL_PORT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_KERNEL_PORT 1
     * }
     */
    public static int THREAD_KERNEL_PORT() {
        return THREAD_KERNEL_PORT;
    }
    private static final int THREAD_INSPECT_PORT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define THREAD_INSPECT_PORT 2
     * }
     */
    public static int THREAD_INSPECT_PORT() {
        return THREAD_INSPECT_PORT;
    }
    private static final int THREAD_READ_PORT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define THREAD_READ_PORT 3
     * }
     */
    public static int THREAD_READ_PORT() {
        return THREAD_READ_PORT;
    }
    private static final int SYSTEM_CLOCK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SYSTEM_CLOCK 0
     * }
     */
    public static int SYSTEM_CLOCK() {
        return SYSTEM_CLOCK;
    }
    private static final int CALENDAR_CLOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CALENDAR_CLOCK 1
     * }
     */
    public static int CALENDAR_CLOCK() {
        return CALENDAR_CLOCK;
    }
    private static final int REALTIME_CLOCK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define REALTIME_CLOCK 0
     * }
     */
    public static int REALTIME_CLOCK() {
        return REALTIME_CLOCK;
    }
    private static final int CLOCK_GET_TIME_RES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_GET_TIME_RES 1
     * }
     */
    public static int CLOCK_GET_TIME_RES() {
        return CLOCK_GET_TIME_RES;
    }
    private static final int CLOCK_ALARM_CURRES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_ALARM_CURRES 3
     * }
     */
    public static int CLOCK_ALARM_CURRES() {
        return CLOCK_ALARM_CURRES;
    }
    private static final int CLOCK_ALARM_MINRES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_ALARM_MINRES 4
     * }
     */
    public static int CLOCK_ALARM_MINRES() {
        return CLOCK_ALARM_MINRES;
    }
    private static final int CLOCK_ALARM_MAXRES = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_ALARM_MAXRES 5
     * }
     */
    public static int CLOCK_ALARM_MAXRES() {
        return CLOCK_ALARM_MAXRES;
    }
    private static final int ALRMTYPE = (int)255L;
    /**
     * {@snippet lang=c :
     * #define ALRMTYPE 255
     * }
     */
    public static int ALRMTYPE() {
        return ALRMTYPE;
    }
    private static final int TIME_ABSOLUTE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define TIME_ABSOLUTE 0
     * }
     */
    public static int TIME_ABSOLUTE() {
        return TIME_ABSOLUTE;
    }
    private static final int TIME_RELATIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIME_RELATIVE 1
     * }
     */
    public static int TIME_RELATIVE() {
        return TIME_RELATIVE;
    }
    private static final int MATTR_CACHE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATTR_CACHE 1
     * }
     */
    public static int MATTR_CACHE() {
        return MATTR_CACHE;
    }
    private static final int MATTR_MIGRATE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MATTR_MIGRATE 2
     * }
     */
    public static int MATTR_MIGRATE() {
        return MATTR_MIGRATE;
    }
    private static final int MATTR_REPLICATE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MATTR_REPLICATE 4
     * }
     */
    public static int MATTR_REPLICATE() {
        return MATTR_REPLICATE;
    }
    private static final int MATTR_VAL_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_OFF 0
     * }
     */
    public static int MATTR_VAL_OFF() {
        return MATTR_VAL_OFF;
    }
    private static final int MATTR_VAL_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_ON 1
     * }
     */
    public static int MATTR_VAL_ON() {
        return MATTR_VAL_ON;
    }
    private static final int MATTR_VAL_GET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_GET 2
     * }
     */
    public static int MATTR_VAL_GET() {
        return MATTR_VAL_GET;
    }
    private static final int MATTR_VAL_CACHE_FLUSH = (int)6L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_CACHE_FLUSH 6
     * }
     */
    public static int MATTR_VAL_CACHE_FLUSH() {
        return MATTR_VAL_CACHE_FLUSH;
    }
    private static final int MATTR_VAL_DCACHE_FLUSH = (int)7L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_DCACHE_FLUSH 7
     * }
     */
    public static int MATTR_VAL_DCACHE_FLUSH() {
        return MATTR_VAL_DCACHE_FLUSH;
    }
    private static final int MATTR_VAL_ICACHE_FLUSH = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_ICACHE_FLUSH 8
     * }
     */
    public static int MATTR_VAL_ICACHE_FLUSH() {
        return MATTR_VAL_ICACHE_FLUSH;
    }
    private static final int MATTR_VAL_CACHE_SYNC = (int)9L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_CACHE_SYNC 9
     * }
     */
    public static int MATTR_VAL_CACHE_SYNC() {
        return MATTR_VAL_CACHE_SYNC;
    }
    private static final int MATTR_VAL_GET_INFO = (int)10L;
    /**
     * {@snippet lang=c :
     * #define MATTR_VAL_GET_INFO 10
     * }
     */
    public static int MATTR_VAL_GET_INFO() {
        return MATTR_VAL_GET_INFO;
    }
    private static final int VM_PURGABLE_NO_AGING_SHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_NO_AGING_SHIFT 16
     * }
     */
    public static int VM_PURGABLE_NO_AGING_SHIFT() {
        return VM_PURGABLE_NO_AGING_SHIFT;
    }
    private static final int VM_PURGABLE_DEBUG_SHIFT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_DEBUG_SHIFT 12
     * }
     */
    public static int VM_PURGABLE_DEBUG_SHIFT() {
        return VM_PURGABLE_DEBUG_SHIFT;
    }
    private static final int VM_VOLATILE_GROUP_SHIFT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_SHIFT 8
     * }
     */
    public static int VM_VOLATILE_GROUP_SHIFT() {
        return VM_VOLATILE_GROUP_SHIFT;
    }
    private static final int VM_PURGABLE_BEHAVIOR_SHIFT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_BEHAVIOR_SHIFT 6
     * }
     */
    public static int VM_PURGABLE_BEHAVIOR_SHIFT() {
        return VM_PURGABLE_BEHAVIOR_SHIFT;
    }
    private static final int VM_PURGABLE_ORDERING_SHIFT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_ORDERING_SHIFT 5
     * }
     */
    public static int VM_PURGABLE_ORDERING_SHIFT() {
        return VM_PURGABLE_ORDERING_SHIFT;
    }
    private static final int VM_VOLATILE_ORDER_SHIFT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_ORDER_SHIFT 4
     * }
     */
    public static int VM_VOLATILE_ORDER_SHIFT() {
        return VM_VOLATILE_ORDER_SHIFT;
    }
    private static final int VM_PURGABLE_STATE_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_STATE_MIN 0
     * }
     */
    public static int VM_PURGABLE_STATE_MIN() {
        return VM_PURGABLE_STATE_MIN;
    }
    private static final int VM_PURGABLE_STATE_MAX = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_STATE_MAX 3
     * }
     */
    public static int VM_PURGABLE_STATE_MAX() {
        return VM_PURGABLE_STATE_MAX;
    }
    private static final int VM_PURGABLE_STATE_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_STATE_MASK 3
     * }
     */
    public static int VM_PURGABLE_STATE_MASK() {
        return VM_PURGABLE_STATE_MASK;
    }
    private static final int VM_PURGABLE_NONVOLATILE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_NONVOLATILE 0
     * }
     */
    public static int VM_PURGABLE_NONVOLATILE() {
        return VM_PURGABLE_NONVOLATILE;
    }
    private static final int VM_PURGABLE_VOLATILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_VOLATILE 1
     * }
     */
    public static int VM_PURGABLE_VOLATILE() {
        return VM_PURGABLE_VOLATILE;
    }
    private static final int VM_PURGABLE_EMPTY = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_EMPTY 2
     * }
     */
    public static int VM_PURGABLE_EMPTY() {
        return VM_PURGABLE_EMPTY;
    }
    private static final int VM_PURGABLE_DENY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_DENY 3
     * }
     */
    public static int VM_PURGABLE_DENY() {
        return VM_PURGABLE_DENY;
    }
    private static final int BYTE_SIZE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define BYTE_SIZE 8
     * }
     */
    public static int BYTE_SIZE() {
        return BYTE_SIZE;
    }
    private static final int PAGE_MAX_SHIFT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define PAGE_MAX_SHIFT 14
     * }
     */
    public static int PAGE_MAX_SHIFT() {
        return PAGE_MAX_SHIFT;
    }
    private static final int PAGE_MIN_SHIFT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define PAGE_MIN_SHIFT 12
     * }
     */
    public static int PAGE_MIN_SHIFT() {
        return PAGE_MIN_SHIFT;
    }
    private static final int SWI_SYSCALL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define SWI_SYSCALL 128
     * }
     */
    public static int SWI_SYSCALL() {
        return SWI_SYSCALL;
    }
    private static final int VM_REGION_BASIC_INFO_64 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_BASIC_INFO_64 9
     * }
     */
    public static int VM_REGION_BASIC_INFO_64() {
        return VM_REGION_BASIC_INFO_64;
    }
    private static final int VM_REGION_BASIC_INFO = (int)10L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_BASIC_INFO 10
     * }
     */
    public static int VM_REGION_BASIC_INFO() {
        return VM_REGION_BASIC_INFO;
    }
    private static final int SM_COW = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SM_COW 1
     * }
     */
    public static int SM_COW() {
        return SM_COW;
    }
    private static final int SM_PRIVATE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SM_PRIVATE 2
     * }
     */
    public static int SM_PRIVATE() {
        return SM_PRIVATE;
    }
    private static final int SM_EMPTY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SM_EMPTY 3
     * }
     */
    public static int SM_EMPTY() {
        return SM_EMPTY;
    }
    private static final int SM_SHARED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SM_SHARED 4
     * }
     */
    public static int SM_SHARED() {
        return SM_SHARED;
    }
    private static final int SM_TRUESHARED = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SM_TRUESHARED 5
     * }
     */
    public static int SM_TRUESHARED() {
        return SM_TRUESHARED;
    }
    private static final int SM_PRIVATE_ALIASED = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SM_PRIVATE_ALIASED 6
     * }
     */
    public static int SM_PRIVATE_ALIASED() {
        return SM_PRIVATE_ALIASED;
    }
    private static final int SM_SHARED_ALIASED = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SM_SHARED_ALIASED 7
     * }
     */
    public static int SM_SHARED_ALIASED() {
        return SM_SHARED_ALIASED;
    }
    private static final int SM_LARGE_PAGE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SM_LARGE_PAGE 8
     * }
     */
    public static int SM_LARGE_PAGE() {
        return SM_LARGE_PAGE;
    }
    private static final int VM_REGION_EXTENDED_INFO = (int)13L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_EXTENDED_INFO 13
     * }
     */
    public static int VM_REGION_EXTENDED_INFO() {
        return VM_REGION_EXTENDED_INFO;
    }
    private static final int VM_REGION_TOP_INFO = (int)12L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_TOP_INFO 12
     * }
     */
    public static int VM_REGION_TOP_INFO() {
        return VM_REGION_TOP_INFO;
    }
    private static final int VM_PAGE_INFO_BASIC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_PAGE_INFO_BASIC 1
     * }
     */
    public static int VM_PAGE_INFO_BASIC() {
        return VM_PAGE_INFO_BASIC;
    }
    private static final int API_TO_BE_DEPRECATED = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED() {
        return API_TO_BE_DEPRECATED;
    }
    private static final int API_TO_BE_DEPRECATED_MACOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_MACOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_MACOS() {
        return API_TO_BE_DEPRECATED_MACOS;
    }
    private static final int API_TO_BE_DEPRECATED_IOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_IOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_IOS() {
        return API_TO_BE_DEPRECATED_IOS;
    }
    private static final int API_TO_BE_DEPRECATED_TVOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_TVOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_TVOS() {
        return API_TO_BE_DEPRECATED_TVOS;
    }
    private static final int API_TO_BE_DEPRECATED_WATCHOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_WATCHOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_WATCHOS() {
        return API_TO_BE_DEPRECATED_WATCHOS;
    }
    private static final int API_TO_BE_DEPRECATED_DRIVERKIT = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_DRIVERKIT 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_DRIVERKIT() {
        return API_TO_BE_DEPRECATED_DRIVERKIT;
    }
    private static final int API_TO_BE_DEPRECATED_VISIONOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define API_TO_BE_DEPRECATED_VISIONOS 100000
     * }
     */
    public static int API_TO_BE_DEPRECATED_VISIONOS() {
        return API_TO_BE_DEPRECATED_VISIONOS;
    }
    private static final int MALLOC_PTR_IN_USE_RANGE_TYPE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MALLOC_PTR_IN_USE_RANGE_TYPE 1
     * }
     */
    public static int MALLOC_PTR_IN_USE_RANGE_TYPE() {
        return MALLOC_PTR_IN_USE_RANGE_TYPE;
    }
    private static final int MALLOC_PTR_REGION_RANGE_TYPE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MALLOC_PTR_REGION_RANGE_TYPE 2
     * }
     */
    public static int MALLOC_PTR_REGION_RANGE_TYPE() {
        return MALLOC_PTR_REGION_RANGE_TYPE;
    }
    private static final int MALLOC_ADMIN_REGION_RANGE_TYPE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MALLOC_ADMIN_REGION_RANGE_TYPE 4
     * }
     */
    public static int MALLOC_ADMIN_REGION_RANGE_TYPE() {
        return MALLOC_ADMIN_REGION_RANGE_TYPE;
    }
    private static final int MALLOC_ZONE_SPECIFIC_FLAGS = (int)65280L;
    /**
     * {@snippet lang=c :
     * #define MALLOC_ZONE_SPECIFIC_FLAGS 65280
     * }
     */
    public static int MALLOC_ZONE_SPECIFIC_FLAGS() {
        return MALLOC_ZONE_SPECIFIC_FLAGS;
    }
    private static final int MALLOC_VERBOSE_PRINT_LEVEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MALLOC_VERBOSE_PRINT_LEVEL 2
     * }
     */
    public static int MALLOC_VERBOSE_PRINT_LEVEL() {
        return MALLOC_VERBOSE_PRINT_LEVEL;
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = ObjCRuntime.C_INT;
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct __darwin_mcontext64 {
     *     struct __darwin_arm_exception_state64 __es;
     *     struct __darwin_arm_thread_state64 __ss;
     *     struct __darwin_arm_neon_state64 __ns;
     * } *mcontext_t
     * }
     */
    public static final AddressLayout mcontext_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = ObjCRuntime.C_INT;

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t rlim_t
     * }
     */
    public static final OfLong rlim_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *rusage_info_t
     * }
     */
    public static final AddressLayout rusage_info_t = ObjCRuntime.C_POINTER;

    private static class getpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static FunctionDescriptor getpriority$descriptor() {
        return getpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MethodHandle getpriority$handle() {
        return getpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MemorySegment getpriority$address() {
        return getpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static int getpriority(int x0, int x1) {
        var mh$ = getpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpriority", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static FunctionDescriptor getiopolicy_np$descriptor() {
        return getiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MethodHandle getiopolicy_np$handle() {
        return getiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MemorySegment getiopolicy_np$address() {
        return getiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static int getiopolicy_np(int x0, int x1) {
        var mh$ = getiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getiopolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static FunctionDescriptor getrlimit$descriptor() {
        return getrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MethodHandle getrlimit$handle() {
        return getrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MemorySegment getrlimit$address() {
        return getrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static int getrlimit(int x0, MemorySegment x1) {
        var mh$ = getrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrusage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getrusage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static FunctionDescriptor getrusage$descriptor() {
        return getrusage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MethodHandle getrusage$handle() {
        return getrusage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MemorySegment getrusage$address() {
        return getrusage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static int getrusage(int x0, MemorySegment x1) {
        var mh$ = getrusage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrusage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static FunctionDescriptor setpriority$descriptor() {
        return setpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MethodHandle setpriority$handle() {
        return setpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MemorySegment setpriority$address() {
        return setpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static int setpriority(int x0, int x1, int x2) {
        var mh$ = setpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpriority", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static FunctionDescriptor setiopolicy_np$descriptor() {
        return setiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MethodHandle setiopolicy_np$handle() {
        return setiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MemorySegment setiopolicy_np$address() {
        return setiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static int setiopolicy_np(int x0, int x1, int x2) {
        var mh$ = setiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setiopolicy_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static FunctionDescriptor setrlimit$descriptor() {
        return setrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MethodHandle setrlimit$handle() {
        return setrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MemorySegment setrlimit$address() {
        return setrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static int setrlimit(int x0, MemorySegment x1) {
        var mh$ = setrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static int waitpid(int x0, MemorySegment x1, int x2) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static int waitid(int x0, int x1, MemorySegment x2, int x3) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static int wait3(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static int wait4(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca(long x0) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ct_rune_t ct_rune_t
     * }
     */
    public static final OfInt ct_rune_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_rune_t rune_t
     * }
     */
    public static final OfInt rune_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t wchar_t
     * }
     */
    public static final OfInt wchar_t = ObjCRuntime.C_INT;

    private static class __mb_cur_max$constants {
        public static final OfInt LAYOUT = ObjCRuntime.C_INT;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("__mb_cur_max").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static OfInt __mb_cur_max$layout() {
        return __mb_cur_max$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static MemorySegment __mb_cur_max$segment() {
        return __mb_cur_max$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static int __mb_cur_max() {
        return __mb_cur_max$constants.SEGMENT.get(__mb_cur_max$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static void __mb_cur_max(int varValue) {
        __mb_cur_max$constants.SEGMENT.set(__mb_cur_max$constants.LAYOUT, 0L, varValue);
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __count, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __count, __size);
            }
            return (MemorySegment)mh$.invokeExact(__count, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static void free(MemorySegment x0) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("reallocf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocf$descriptor() {
        return reallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle reallocf$handle() {
        return reallocf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf$address() {
        return reallocf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf(MemorySegment __ptr, long __size) {
        var mh$ = reallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocf", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static int abs(int x0) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment x0) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static double atof(MemorySegment x0) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static int atoi(MemorySegment x0) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static long atol(MemorySegment x0) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static long atoll(MemorySegment x0) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int x0, int x1) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static void exit(int x0) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv(MemorySegment x0) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static long labs(long x0) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static long llabs(long x0) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static long mbstowcs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static int mbtowc(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void qsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static void quick_exit(int x0) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static void srand(int x0) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static double strtod(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_FLOAT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static float strtof(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static int system(MemorySegment x0) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static long wcstombs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static int wctomb(MemorySegment x0, int x1) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static long a64l(MemorySegment x0) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static double erand48(MemorySegment x0) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_DOUBLE,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt(double x0, int x1, MemorySegment x2) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class grantpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("grantpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static FunctionDescriptor grantpt$descriptor() {
        return grantpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MethodHandle grantpt$handle() {
        return grantpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MemorySegment grantpt$address() {
        return grantpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static int grantpt(int x0) {
        var mh$ = grantpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("grantpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate(int x0, MemorySegment x1, long x2) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static long jrand48(MemorySegment x0) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a(long x0) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static void lcong48(MemorySegment x0) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static long nrand48(MemorySegment x0) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_openpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("posix_openpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static FunctionDescriptor posix_openpt$descriptor() {
        return posix_openpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MethodHandle posix_openpt$handle() {
        return posix_openpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MemorySegment posix_openpt$address() {
        return posix_openpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static int posix_openpt(int x0) {
        var mh$ = posix_openpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_openpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ptsname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static FunctionDescriptor ptsname$descriptor() {
        return ptsname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MethodHandle ptsname$handle() {
        return ptsname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname$address() {
        return ptsname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname(int x0) {
        var mh$ = ptsname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ptsname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static FunctionDescriptor ptsname_r$descriptor() {
        return ptsname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MethodHandle ptsname_r$handle() {
        return ptsname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MemorySegment ptsname_r$address() {
        return ptsname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static int ptsname_r(int fildes, MemorySegment buffer, long buflen) {
        var mh$ = ptsname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname_r", fildes, buffer, buflen);
            }
            return (int)mh$.invokeExact(fildes, buffer, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static int putenv(MemorySegment x0) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static int rand_r(MemorySegment x0) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("realpath$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath(MemorySegment x0, MemorySegment x1) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48(MemorySegment x0) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __overwrite) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __overwrite);
            }
            return (int)mh$.invokeExact(__name, __value, __overwrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate(MemorySegment x0) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static void srand48(long x0) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static void srandom(int x0) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlockpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("unlockpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static FunctionDescriptor unlockpt$descriptor() {
        return unlockpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MethodHandle unlockpt$handle() {
        return unlockpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MemorySegment unlockpt$address() {
        return unlockpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static int unlockpt(int x0) {
        var mh$ = unlockpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlockpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static int unsetenv(MemorySegment x0) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = ObjCRuntime.C_SHORT;

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_addrandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_addrandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static FunctionDescriptor arc4random_addrandom$descriptor() {
        return arc4random_addrandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MethodHandle arc4random_addrandom$handle() {
        return arc4random_addrandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MemorySegment arc4random_addrandom$address() {
        return arc4random_addrandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static void arc4random_addrandom(MemorySegment x0, int x1) {
        var mh$ = arc4random_addrandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_addrandom", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __nbytes) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __nbytes);
            }
            mh$.invokeExact(__buf, __nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_stir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_stir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static FunctionDescriptor arc4random_stir$descriptor() {
        return arc4random_stir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MethodHandle arc4random_stir$handle() {
        return arc4random_stir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MemorySegment arc4random_stir$address() {
        return arc4random_stir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static void arc4random_stir() {
        var mh$ = arc4random_stir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_stir");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("atexit_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit_b$descriptor() {
        return atexit_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit_b$handle() {
        return atexit_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit_b$address() {
        return atexit_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static int atexit_b(MemorySegment x0) {
        var mh$ = atexit_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit_b", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("bsearch_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch_b$descriptor() {
        return bsearch_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch_b$handle() {
        return bsearch_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b$address() {
        return bsearch_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_b", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetcap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetcap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static FunctionDescriptor cgetcap$descriptor() {
        return cgetcap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MethodHandle cgetcap$handle() {
        return cgetcap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap$address() {
        return cgetcap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = cgetcap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetcap", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static FunctionDescriptor cgetclose$descriptor() {
        return cgetclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MethodHandle cgetclose$handle() {
        return cgetclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MemorySegment cgetclose$address() {
        return cgetclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static int cgetclose() {
        var mh$ = cgetclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetclose");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static FunctionDescriptor cgetent$descriptor() {
        return cgetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MethodHandle cgetent$handle() {
        return cgetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MemorySegment cgetent$address() {
        return cgetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static int cgetent(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetent", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetfirst$descriptor() {
        return cgetfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MethodHandle cgetfirst$handle() {
        return cgetfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MemorySegment cgetfirst$address() {
        return cgetfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static int cgetfirst(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetfirst", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static FunctionDescriptor cgetmatch$descriptor() {
        return cgetmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MethodHandle cgetmatch$handle() {
        return cgetmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MemorySegment cgetmatch$address() {
        return cgetmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static int cgetmatch(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetmatch", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetnext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetnext$descriptor() {
        return cgetnext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MethodHandle cgetnext$handle() {
        return cgetnext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MemorySegment cgetnext$address() {
        return cgetnext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static int cgetnext(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetnext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor cgetnum$descriptor() {
        return cgetnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MethodHandle cgetnum$handle() {
        return cgetnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MemorySegment cgetnum$address() {
        return cgetnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static int cgetnum(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnum", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static FunctionDescriptor cgetset$descriptor() {
        return cgetset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MethodHandle cgetset$handle() {
        return cgetset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MemorySegment cgetset$address() {
        return cgetset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static int cgetset(MemorySegment x0) {
        var mh$ = cgetset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetstr$descriptor() {
        return cgetstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetstr$handle() {
        return cgetstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetstr$address() {
        return cgetstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static int cgetstr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetstr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetustr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("cgetustr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetustr$descriptor() {
        return cgetustr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetustr$handle() {
        return cgetustr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetustr$address() {
        return cgetustr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static int cgetustr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetustr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetustr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static int daemon(int x0, int x1) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_SHORT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("devname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static FunctionDescriptor devname$descriptor() {
        return devname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MethodHandle devname$handle() {
        return devname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname$address() {
        return devname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname(int x0, short x1) {
        var mh$ = devname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_SHORT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("devname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static FunctionDescriptor devname_r$descriptor() {
        return devname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MethodHandle devname_r$handle() {
        return devname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r$address() {
        return devname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r(int x0, short x1, MemorySegment buf, int len) {
        var mh$ = devname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname_r", x0, x1, buf, len);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, buf, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getbsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static FunctionDescriptor getbsize$descriptor() {
        return getbsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MethodHandle getbsize$handle() {
        return getbsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize$address() {
        return getbsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = getbsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbsize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static int getloadavg(MemorySegment x0, int x1) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("getprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static FunctionDescriptor getprogname$descriptor() {
        return getprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MethodHandle getprogname$handle() {
        return getprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname$address() {
        return getprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname() {
        var mh$ = getprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprogname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("setprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static FunctionDescriptor setprogname$descriptor() {
        return setprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MethodHandle setprogname$handle() {
        return setprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MemorySegment setprogname$address() {
        return setprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static void setprogname(MemorySegment x0) {
        var mh$ = setprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprogname", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("heapsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort$descriptor() {
        return heapsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort$handle() {
        return heapsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort$address() {
        return heapsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int heapsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("heapsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort_b$descriptor() {
        return heapsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort_b$handle() {
        return heapsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort_b$address() {
        return heapsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int heapsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mergesort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort$descriptor() {
        return mergesort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort$handle() {
        return mergesort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort$address() {
        return mergesort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int mergesort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mergesort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort_b$descriptor() {
        return mergesort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort_b$handle() {
        return mergesort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort_b$address() {
        return mergesort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int mergesort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("psort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort$descriptor() {
        return psort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort$handle() {
        return psort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort$address() {
        return psort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void psort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("psort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_b$descriptor() {
        return psort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort_b$handle() {
        return psort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort_b$address() {
        return psort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void psort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("psort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_r$descriptor() {
        return psort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle psort_r$handle() {
        return psort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment psort_r$address() {
        return psort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void psort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = psort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("qsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_b$descriptor() {
        return qsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort_b$handle() {
        return qsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort_b$address() {
        return qsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void qsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("qsort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_r$descriptor() {
        return qsort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle qsort_r$handle() {
        return qsort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment qsort_r$address() {
        return qsort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void qsort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = qsort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class radixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("radixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor radixsort$descriptor() {
        return radixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle radixsort$handle() {
        return radixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment radixsort$address() {
        return radixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int radixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = radixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("radixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static int rpmatch(MemorySegment x0) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sradixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sradixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor sradixsort$descriptor() {
        return sradixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle sradixsort$handle() {
        return sradixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment sradixsort$address() {
        return sradixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int sradixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = sradixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sradixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sranddev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sranddev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static FunctionDescriptor sranddev$descriptor() {
        return sranddev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MethodHandle sranddev$handle() {
        return sranddev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MemorySegment sranddev$address() {
        return sranddev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static void sranddev() {
        var mh$ = sranddev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sranddev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandomdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("srandomdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static FunctionDescriptor srandomdev$descriptor() {
        return srandomdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MethodHandle srandomdev$handle() {
        return srandomdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MemorySegment srandomdev$address() {
        return srandomdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static void srandomdev() {
        var mh$ = srandomdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandomdev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtonum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtonum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static FunctionDescriptor strtonum$descriptor() {
        return strtonum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MethodHandle strtonum$handle() {
        return strtonum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MemorySegment strtonum$address() {
        return strtonum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static long strtonum(MemorySegment __numstr, long __minval, long __maxval, MemorySegment __errstrp) {
        var mh$ = strtonum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtonum", __numstr, __minval, __maxval, __errstrp);
            }
            return (long)mh$.invokeExact(__numstr, __minval, __maxval, __errstrp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = ObjCRuntime.C_POINTER;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ptrdiff_t ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_char
     * }
     */
    public static final OfByte u_char = ObjCRuntime.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_short
     * }
     */
    public static final OfShort u_short = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int
     * }
     */
    public static final OfInt u_int = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long u_long
     * }
     */
    public static final OfLong u_long = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t quad_t
     * }
     */
    public static final OfLong quad_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef quad_t *qaddr_t
     * }
     */
    public static final AddressLayout qaddr_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef char *caddr_t
     * }
     */
    public static final AddressLayout caddr_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int32_t daddr_t
     * }
     */
    public static final OfInt daddr_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fixpt_t
     * }
     */
    public static final OfInt fixpt_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blksize_t blksize_t
     * }
     */
    public static final OfInt blksize_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_gid_t gid_t
     * }
     */
    public static final OfInt gid_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t in_addr_t
     * }
     */
    public static final OfInt in_addr_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t in_port_t
     * }
     */
    public static final OfShort in_port_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino_t ino_t
     * }
     */
    public static final OfLong ino_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t ino64_t
     * }
     */
    public static final OfLong ino64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t key_t
     * }
     */
    public static final OfInt key_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t nlink_t
     * }
     */
    public static final OfShort nlink_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int32_t segsz_t
     * }
     */
    public static final OfInt segsz_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t swblk_t
     * }
     */
    public static final OfInt swblk_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_clock_t clock_t
     * }
     */
    public static final OfLong clock_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_time_t time_t
     * }
     */
    public static final OfLong time_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_useconds_t useconds_t
     * }
     */
    public static final OfInt useconds_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_suseconds_t suseconds_t
     * }
     */
    public static final OfInt suseconds_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = ObjCRuntime.C_INT;

    private static class __darwin_check_fd_set_overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("__darwin_check_fd_set_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static FunctionDescriptor __darwin_check_fd_set_overflow$descriptor() {
        return __darwin_check_fd_set_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MethodHandle __darwin_check_fd_set_overflow$handle() {
        return __darwin_check_fd_set_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MemorySegment __darwin_check_fd_set_overflow$address() {
        return __darwin_check_fd_set_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static int __darwin_check_fd_set_overflow(int x0, MemorySegment x1, int x2) {
        var mh$ = __darwin_check_fd_set_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__darwin_check_fd_set_overflow", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __int32_t fd_mask
     * }
     */
    public static final OfInt fd_mask = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_t pthread_t
     * }
     */
    public static final AddressLayout pthread_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_key_t pthread_key_t
     * }
     */
    public static final OfLong pthread_key_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfInt fsblkcnt_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfInt fsfilcnt_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct objc_class *Class
     * }
     */
    public static final AddressLayout Class_ = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_object {
     *     OBJC_ISA_AVAILABILITY Class isa;
     * } *id
     * }
     */
    public static final AddressLayout id = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_selector *SEL
     * }
     */
    public static final AddressLayout SEL = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef bool BOOL
     * }
     */
    public static final OfBoolean BOOL = ObjCRuntime.C_BOOL;
    /**
     * {@snippet lang=c :
     * typedef struct _malloc_zone_t {
     *     void *reserved1;
     *     void *reserved2;
     *     size_t (*size)(struct _malloc_zone_t *, const void *);
     *     void *(*malloc)(struct _malloc_zone_t *, size_t);
     *     void *(*calloc)(struct _malloc_zone_t *, size_t, size_t);
     *     void *(*valloc)(struct _malloc_zone_t *, size_t);
     *     void (*free)(struct _malloc_zone_t *, void *);
     *     void *(*realloc)(struct _malloc_zone_t *, void *, size_t);
     *     void (*destroy)(struct _malloc_zone_t *);
     *     const char *zone_name;
     *     unsigned int (*batch_malloc)(struct _malloc_zone_t *, size_t, void **, unsigned int);
     *     void (*batch_free)(struct _malloc_zone_t *, void **, unsigned int);
     *     struct malloc_introspection_t *introspect;
     *     unsigned int version;
     *     void *(*memalign)(struct _malloc_zone_t *, size_t, size_t);
     *     void (*free_definite_size)(struct _malloc_zone_t *, void *, size_t);
     *     size_t (*pressure_relief)(struct _malloc_zone_t *, size_t);
     *     boolean_t (*claimed_address)(struct _malloc_zone_t *, void *);
     *     void (*try_free_default)(struct _malloc_zone_t *, void *);
     *     void *(*malloc_with_options)(struct _malloc_zone_t *, size_t, size_t, uint64_t);
     *     void *(*malloc_type_malloc)(struct _malloc_zone_t *, size_t, malloc_type_id_t);
     *     void *(*malloc_type_calloc)(struct _malloc_zone_t *, size_t, size_t, malloc_type_id_t);
     *     void *(*malloc_type_realloc)(struct _malloc_zone_t *, void *, size_t, malloc_type_id_t);
     *     void *(*malloc_type_memalign)(struct _malloc_zone_t *, size_t, size_t, malloc_type_id_t);
     *     void *(*malloc_type_malloc_with_options)(struct _malloc_zone_t *, size_t, size_t, uint64_t, malloc_type_id_t);
     * } *objc_zone_t
     * }
     */
    public static final AddressLayout objc_zone_t = ObjCRuntime.C_POINTER;

    private static class sel_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor sel_getName$descriptor() {
        return sel_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle sel_getName$handle() {
        return sel_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment sel_getName$address() {
        return sel_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment sel_getName(MemorySegment sel) {
        var mh$ = sel_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_getName", sel);
            }
            return (MemorySegment)mh$.invokeExact(sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_registerName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_registerName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static FunctionDescriptor sel_registerName$descriptor() {
        return sel_registerName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static MethodHandle sel_registerName$handle() {
        return sel_registerName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_registerName$address() {
        return sel_registerName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_registerName(MemorySegment str) {
        var mh$ = sel_registerName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_registerName", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getClassName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getClassName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_getClassName$descriptor() {
        return object_getClassName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_getClassName$handle() {
        return object_getClassName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClassName$address() {
        return object_getClassName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClassName(MemorySegment obj) {
        var mh$ = object_getClassName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getClassName", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getIndexedIvars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getIndexedIvars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_getIndexedIvars$descriptor() {
        return object_getIndexedIvars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_getIndexedIvars$handle() {
        return object_getIndexedIvars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getIndexedIvars$address() {
        return object_getIndexedIvars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getIndexedIvars(MemorySegment obj) {
        var mh$ = object_getIndexedIvars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getIndexedIvars", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_isMapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_isMapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor sel_isMapped$descriptor() {
        return sel_isMapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle sel_isMapped$handle() {
        return sel_isMapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment sel_isMapped$address() {
        return sel_isMapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static boolean sel_isMapped(MemorySegment sel) {
        var mh$ = sel_isMapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_isMapped", sel);
            }
            return (boolean)mh$.invokeExact(sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_getUid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_getUid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static FunctionDescriptor sel_getUid$descriptor() {
        return sel_getUid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static MethodHandle sel_getUid$handle() {
        return sel_getUid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_getUid$address() {
        return sel_getUid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_getUid(MemorySegment str) {
        var mh$ = sel_getUid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_getUid", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef const void *objc_objectptr_t
     * }
     */
    public static final AddressLayout objc_objectptr_t = ObjCRuntime.C_POINTER;

    private static class objc_retainedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_retainedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_retainedObject$descriptor() {
        return objc_retainedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MethodHandle objc_retainedObject$handle() {
        return objc_retainedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_retainedObject$address() {
        return objc_retainedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_retainedObject(MemorySegment obj) {
        var mh$ = objc_retainedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_retainedObject", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_unretainedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_unretainedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_unretainedObject$descriptor() {
        return objc_unretainedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MethodHandle objc_unretainedObject$handle() {
        return objc_unretainedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedObject$address() {
        return objc_unretainedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedObject(MemorySegment obj) {
        var mh$ = objc_unretainedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_unretainedObject", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_unretainedPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_unretainedPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_unretainedPointer$descriptor() {
        return objc_unretainedPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static MethodHandle objc_unretainedPointer$handle() {
        return objc_unretainedPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedPointer$address() {
        return objc_unretainedPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedPointer(MemorySegment obj) {
        var mh$ = objc_unretainedPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_unretainedPointer", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_method *Method
     * }
     */
    public static final AddressLayout Method = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_ivar *Ivar
     * }
     */
    public static final AddressLayout Ivar = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_category *Category
     * }
     */
    public static final AddressLayout Category = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_property *objc_property_t
     * }
     */
    public static final AddressLayout objc_property_t = ObjCRuntime.C_POINTER;

    private static class object_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static FunctionDescriptor object_copy$descriptor() {
        return object_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static MethodHandle object_copy$handle() {
        return object_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static MemorySegment object_copy$address() {
        return object_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static MemorySegment object_copy(MemorySegment obj, long size) {
        var mh$ = object_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_copy", obj, size);
            }
            return (MemorySegment)mh$.invokeExact(obj, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_dispose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_dispose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_dispose$descriptor() {
        return object_dispose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_dispose$handle() {
        return object_dispose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_dispose$address() {
        return object_dispose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_dispose(MemorySegment obj) {
        var mh$ = object_dispose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_dispose", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_getClass$descriptor() {
        return object_getClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_getClass$handle() {
        return object_getClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClass$address() {
        return object_getClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClass(MemorySegment obj) {
        var mh$ = object_getClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getClass", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static FunctionDescriptor object_setClass$descriptor() {
        return object_setClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static MethodHandle object_setClass$handle() {
        return object_setClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static MemorySegment object_setClass$address() {
        return object_setClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static MemorySegment object_setClass(MemorySegment obj, MemorySegment cls) {
        var mh$ = object_setClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setClass", obj, cls);
            }
            return (MemorySegment)mh$.invokeExact(obj, cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_isClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_isClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_isClass$descriptor() {
        return object_isClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_isClass$handle() {
        return object_isClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_isClass$address() {
        return object_isClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static boolean object_isClass(MemorySegment obj) {
        var mh$ = object_isClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_isClass", obj);
            }
            return (boolean)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getIvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getIvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static FunctionDescriptor object_getIvar$descriptor() {
        return object_getIvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static MethodHandle object_getIvar$handle() {
        return object_getIvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static MemorySegment object_getIvar$address() {
        return object_getIvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static MemorySegment object_getIvar(MemorySegment obj, MemorySegment ivar) {
        var mh$ = object_getIvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getIvar", obj, ivar);
            }
            return (MemorySegment)mh$.invokeExact(obj, ivar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setIvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setIvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setIvar$descriptor() {
        return object_setIvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MethodHandle object_setIvar$handle() {
        return object_setIvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MemorySegment object_setIvar$address() {
        return object_setIvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static void object_setIvar(MemorySegment obj, MemorySegment ivar, MemorySegment value) {
        var mh$ = object_setIvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setIvar", obj, ivar, value);
            }
            mh$.invokeExact(obj, ivar, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setIvarWithStrongDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setIvarWithStrongDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setIvarWithStrongDefault$descriptor() {
        return object_setIvarWithStrongDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MethodHandle object_setIvarWithStrongDefault$handle() {
        return object_setIvarWithStrongDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MemorySegment object_setIvarWithStrongDefault$address() {
        return object_setIvarWithStrongDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static void object_setIvarWithStrongDefault(MemorySegment obj, MemorySegment ivar, MemorySegment value) {
        var mh$ = object_setIvarWithStrongDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setIvarWithStrongDefault", obj, ivar, value);
            }
            mh$.invokeExact(obj, ivar, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setInstanceVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setInstanceVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setInstanceVariable$descriptor() {
        return object_setInstanceVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MethodHandle object_setInstanceVariable$handle() {
        return object_setInstanceVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariable$address() {
        return object_setInstanceVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariable(MemorySegment obj, MemorySegment name, MemorySegment value) {
        var mh$ = object_setInstanceVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setInstanceVariable", obj, name, value);
            }
            return (MemorySegment)mh$.invokeExact(obj, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setInstanceVariableWithStrongDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setInstanceVariableWithStrongDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setInstanceVariableWithStrongDefault$descriptor() {
        return object_setInstanceVariableWithStrongDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MethodHandle object_setInstanceVariableWithStrongDefault$handle() {
        return object_setInstanceVariableWithStrongDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariableWithStrongDefault$address() {
        return object_setInstanceVariableWithStrongDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariableWithStrongDefault(MemorySegment obj, MemorySegment name, MemorySegment value) {
        var mh$ = object_setInstanceVariableWithStrongDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setInstanceVariableWithStrongDefault", obj, name, value);
            }
            return (MemorySegment)mh$.invokeExact(obj, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getInstanceVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getInstanceVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static FunctionDescriptor object_getInstanceVariable$descriptor() {
        return object_getInstanceVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static MethodHandle object_getInstanceVariable$handle() {
        return object_getInstanceVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static MemorySegment object_getInstanceVariable$address() {
        return object_getInstanceVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static MemorySegment object_getInstanceVariable(MemorySegment obj, MemorySegment name, MemorySegment outValue) {
        var mh$ = object_getInstanceVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getInstanceVariable", obj, name, outValue);
            }
            return (MemorySegment)mh$.invokeExact(obj, name, outValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getClass$descriptor() {
        return objc_getClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getClass$handle() {
        return objc_getClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getClass$address() {
        return objc_getClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getClass(MemorySegment name) {
        var mh$ = objc_getClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getMetaClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getMetaClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getMetaClass$descriptor() {
        return objc_getMetaClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getMetaClass$handle() {
        return objc_getMetaClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getMetaClass$address() {
        return objc_getMetaClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getMetaClass(MemorySegment name) {
        var mh$ = objc_getMetaClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getMetaClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_lookUpClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_lookUpClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_lookUpClass$descriptor() {
        return objc_lookUpClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_lookUpClass$handle() {
        return objc_lookUpClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_lookUpClass$address() {
        return objc_lookUpClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_lookUpClass(MemorySegment name) {
        var mh$ = objc_lookUpClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_lookUpClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getRequiredClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getRequiredClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getRequiredClass$descriptor() {
        return objc_getRequiredClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getRequiredClass$handle() {
        return objc_getRequiredClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getRequiredClass$address() {
        return objc_getRequiredClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getRequiredClass(MemorySegment name) {
        var mh$ = objc_getRequiredClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getRequiredClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getClassList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getClassList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static FunctionDescriptor objc_getClassList$descriptor() {
        return objc_getClassList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static MethodHandle objc_getClassList$handle() {
        return objc_getClassList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static MemorySegment objc_getClassList$address() {
        return objc_getClassList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static int objc_getClassList(MemorySegment buffer, int bufferCount) {
        var mh$ = objc_getClassList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getClassList", buffer, bufferCount);
            }
            return (int)mh$.invokeExact(buffer, bufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyClassList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyClassList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyClassList$descriptor() {
        return objc_copyClassList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyClassList$handle() {
        return objc_copyClassList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassList$address() {
        return objc_copyClassList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassList(MemorySegment outCount) {
        var mh$ = objc_copyClassList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyClassList", outCount);
            }
            return (MemorySegment)mh$.invokeExact(outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_enumerateClasses {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_enumerateClasses");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static FunctionDescriptor objc_enumerateClasses$descriptor() {
        return objc_enumerateClasses.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static MethodHandle objc_enumerateClasses$handle() {
        return objc_enumerateClasses.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static MemorySegment objc_enumerateClasses$address() {
        return objc_enumerateClasses.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static void objc_enumerateClasses(MemorySegment image, MemorySegment namePrefix, MemorySegment conformingTo, MemorySegment subclassing, MemorySegment block) {
        var mh$ = objc_enumerateClasses.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_enumerateClasses", image, namePrefix, conformingTo, subclassing, block);
            }
            mh$.invokeExact(image, namePrefix, conformingTo, subclassing, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getName$descriptor() {
        return class_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getName$handle() {
        return class_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getName$address() {
        return class_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getName(MemorySegment cls) {
        var mh$ = class_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getName", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_isMetaClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_isMetaClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_isMetaClass$descriptor() {
        return class_isMetaClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_isMetaClass$handle() {
        return class_isMetaClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_isMetaClass$address() {
        return class_isMetaClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static boolean class_isMetaClass(MemorySegment cls) {
        var mh$ = class_isMetaClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_isMetaClass", cls);
            }
            return (boolean)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getSuperclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getSuperclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getSuperclass$descriptor() {
        return class_getSuperclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getSuperclass$handle() {
        return class_getSuperclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getSuperclass$address() {
        return class_getSuperclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getSuperclass(MemorySegment cls) {
        var mh$ = class_getSuperclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getSuperclass", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setSuperclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setSuperclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static FunctionDescriptor class_setSuperclass$descriptor() {
        return class_setSuperclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static MethodHandle class_setSuperclass$handle() {
        return class_setSuperclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static MemorySegment class_setSuperclass$address() {
        return class_setSuperclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static MemorySegment class_setSuperclass(MemorySegment cls, MemorySegment newSuper) {
        var mh$ = class_setSuperclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setSuperclass", cls, newSuper);
            }
            return (MemorySegment)mh$.invokeExact(cls, newSuper);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getVersion$descriptor() {
        return class_getVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getVersion$handle() {
        return class_getVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getVersion$address() {
        return class_getVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static int class_getVersion(MemorySegment cls) {
        var mh$ = class_getVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getVersion", cls);
            }
            return (int)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static FunctionDescriptor class_setVersion$descriptor() {
        return class_setVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static MethodHandle class_setVersion$handle() {
        return class_setVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static MemorySegment class_setVersion$address() {
        return class_setVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static void class_setVersion(MemorySegment cls, int version) {
        var mh$ = class_setVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setVersion", cls, version);
            }
            mh$.invokeExact(cls, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getInstanceSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getInstanceSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getInstanceSize$descriptor() {
        return class_getInstanceSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getInstanceSize$handle() {
        return class_getInstanceSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getInstanceSize$address() {
        return class_getInstanceSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static long class_getInstanceSize(MemorySegment cls) {
        var mh$ = class_getInstanceSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getInstanceSize", cls);
            }
            return (long)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getInstanceVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getInstanceVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getInstanceVariable$descriptor() {
        return class_getInstanceVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MethodHandle class_getInstanceVariable$handle() {
        return class_getInstanceVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceVariable$address() {
        return class_getInstanceVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceVariable(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getInstanceVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getInstanceVariable", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getClassVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getClassVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getClassVariable$descriptor() {
        return class_getClassVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MethodHandle class_getClassVariable$handle() {
        return class_getClassVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassVariable$address() {
        return class_getClassVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassVariable(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getClassVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getClassVariable", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyIvarList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyIvarList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyIvarList$descriptor() {
        return class_copyIvarList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyIvarList$handle() {
        return class_copyIvarList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyIvarList$address() {
        return class_copyIvarList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyIvarList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyIvarList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyIvarList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getInstanceMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getInstanceMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getInstanceMethod$descriptor() {
        return class_getInstanceMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getInstanceMethod$handle() {
        return class_getInstanceMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceMethod$address() {
        return class_getInstanceMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceMethod(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getInstanceMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getInstanceMethod", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getClassMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getClassMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getClassMethod$descriptor() {
        return class_getClassMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getClassMethod$handle() {
        return class_getClassMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassMethod$address() {
        return class_getClassMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassMethod(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getClassMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getClassMethod", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getMethodImplementation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getMethodImplementation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getMethodImplementation$descriptor() {
        return class_getMethodImplementation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getMethodImplementation$handle() {
        return class_getMethodImplementation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation$address() {
        return class_getMethodImplementation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getMethodImplementation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getMethodImplementation", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getMethodImplementation_stret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getMethodImplementation_stret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getMethodImplementation_stret$descriptor() {
        return class_getMethodImplementation_stret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getMethodImplementation_stret$handle() {
        return class_getMethodImplementation_stret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation_stret$address() {
        return class_getMethodImplementation_stret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation_stret(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getMethodImplementation_stret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getMethodImplementation_stret", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_respondsToSelector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_respondsToSelector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor class_respondsToSelector$descriptor() {
        return class_respondsToSelector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle class_respondsToSelector$handle() {
        return class_respondsToSelector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_respondsToSelector$address() {
        return class_respondsToSelector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static boolean class_respondsToSelector(MemorySegment cls, MemorySegment sel) {
        var mh$ = class_respondsToSelector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_respondsToSelector", cls, sel);
            }
            return (boolean)mh$.invokeExact(cls, sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyMethodList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyMethodList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyMethodList$descriptor() {
        return class_copyMethodList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyMethodList$handle() {
        return class_copyMethodList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyMethodList$address() {
        return class_copyMethodList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyMethodList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyMethodList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyMethodList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_conformsToProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_conformsToProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static FunctionDescriptor class_conformsToProtocol$descriptor() {
        return class_conformsToProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static MethodHandle class_conformsToProtocol$handle() {
        return class_conformsToProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static MemorySegment class_conformsToProtocol$address() {
        return class_conformsToProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static boolean class_conformsToProtocol(MemorySegment cls, MemorySegment protocol) {
        var mh$ = class_conformsToProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_conformsToProtocol", cls, protocol);
            }
            return (boolean)mh$.invokeExact(cls, protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyProtocolList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyProtocolList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyProtocolList$descriptor() {
        return class_copyProtocolList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyProtocolList$handle() {
        return class_copyProtocolList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyProtocolList$address() {
        return class_copyProtocolList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyProtocolList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyProtocolList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyProtocolList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getProperty$descriptor() {
        return class_getProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MethodHandle class_getProperty$handle() {
        return class_getProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getProperty$address() {
        return class_getProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getProperty(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getProperty", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyPropertyList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyPropertyList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyPropertyList$descriptor() {
        return class_copyPropertyList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyPropertyList$handle() {
        return class_copyPropertyList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyPropertyList$address() {
        return class_copyPropertyList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyPropertyList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyPropertyList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyPropertyList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getIvarLayout$descriptor() {
        return class_getIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getIvarLayout$handle() {
        return class_getIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getIvarLayout$address() {
        return class_getIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getIvarLayout(MemorySegment cls) {
        var mh$ = class_getIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getIvarLayout", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getWeakIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getWeakIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getWeakIvarLayout$descriptor() {
        return class_getWeakIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getWeakIvarLayout$handle() {
        return class_getWeakIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getWeakIvarLayout$address() {
        return class_getWeakIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getWeakIvarLayout(MemorySegment cls) {
        var mh$ = class_getWeakIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getWeakIvarLayout", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static FunctionDescriptor class_addMethod$descriptor() {
        return class_addMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MethodHandle class_addMethod$handle() {
        return class_addMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_addMethod$address() {
        return class_addMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static boolean class_addMethod(MemorySegment cls, MemorySegment name, MemorySegment imp, MemorySegment types) {
        var mh$ = class_addMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addMethod", cls, name, imp, types);
            }
            return (boolean)mh$.invokeExact(cls, name, imp, types);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_replaceMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_replaceMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static FunctionDescriptor class_replaceMethod$descriptor() {
        return class_replaceMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MethodHandle class_replaceMethod$handle() {
        return class_replaceMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_replaceMethod$address() {
        return class_replaceMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_replaceMethod(MemorySegment cls, MemorySegment name, MemorySegment imp, MemorySegment types) {
        var mh$ = class_replaceMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_replaceMethod", cls, name, imp, types);
            }
            return (MemorySegment)mh$.invokeExact(cls, name, imp, types);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addIvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_CHAR,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addIvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static FunctionDescriptor class_addIvar$descriptor() {
        return class_addIvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static MethodHandle class_addIvar$handle() {
        return class_addIvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_addIvar$address() {
        return class_addIvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static boolean class_addIvar(MemorySegment cls, MemorySegment name, long size, byte alignment, MemorySegment types) {
        var mh$ = class_addIvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addIvar", cls, name, size, alignment, types);
            }
            return (boolean)mh$.invokeExact(cls, name, size, alignment, types);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static FunctionDescriptor class_addProtocol$descriptor() {
        return class_addProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static MethodHandle class_addProtocol$handle() {
        return class_addProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static MemorySegment class_addProtocol$address() {
        return class_addProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static boolean class_addProtocol(MemorySegment cls, MemorySegment protocol) {
        var mh$ = class_addProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addProtocol", cls, protocol);
            }
            return (boolean)mh$.invokeExact(cls, protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static FunctionDescriptor class_addProperty$descriptor() {
        return class_addProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MethodHandle class_addProperty$handle() {
        return class_addProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MemorySegment class_addProperty$address() {
        return class_addProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static boolean class_addProperty(MemorySegment cls, MemorySegment name, MemorySegment attributes, int attributeCount) {
        var mh$ = class_addProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addProperty", cls, name, attributes, attributeCount);
            }
            return (boolean)mh$.invokeExact(cls, name, attributes, attributeCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_replaceProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_replaceProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static FunctionDescriptor class_replaceProperty$descriptor() {
        return class_replaceProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MethodHandle class_replaceProperty$handle() {
        return class_replaceProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MemorySegment class_replaceProperty$address() {
        return class_replaceProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static void class_replaceProperty(MemorySegment cls, MemorySegment name, MemorySegment attributes, int attributeCount) {
        var mh$ = class_replaceProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_replaceProperty", cls, name, attributes, attributeCount);
            }
            mh$.invokeExact(cls, name, attributes, attributeCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static FunctionDescriptor class_setIvarLayout$descriptor() {
        return class_setIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MethodHandle class_setIvarLayout$handle() {
        return class_setIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MemorySegment class_setIvarLayout$address() {
        return class_setIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static void class_setIvarLayout(MemorySegment cls, MemorySegment layout) {
        var mh$ = class_setIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setIvarLayout", cls, layout);
            }
            mh$.invokeExact(cls, layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setWeakIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setWeakIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static FunctionDescriptor class_setWeakIvarLayout$descriptor() {
        return class_setWeakIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MethodHandle class_setWeakIvarLayout$handle() {
        return class_setWeakIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MemorySegment class_setWeakIvarLayout$address() {
        return class_setWeakIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static void class_setWeakIvarLayout(MemorySegment cls, MemorySegment layout) {
        var mh$ = class_setWeakIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setWeakIvarLayout", cls, layout);
            }
            mh$.invokeExact(cls, layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getFutureClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getFutureClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getFutureClass$descriptor() {
        return objc_getFutureClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getFutureClass$handle() {
        return objc_getFutureClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getFutureClass$address() {
        return objc_getFutureClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getFutureClass(MemorySegment name) {
        var mh$ = objc_getFutureClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getFutureClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_createInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_createInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static FunctionDescriptor class_createInstance$descriptor() {
        return class_createInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static MethodHandle class_createInstance$handle() {
        return class_createInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static MemorySegment class_createInstance$address() {
        return class_createInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static MemorySegment class_createInstance(MemorySegment cls, long extraBytes) {
        var mh$ = class_createInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_createInstance", cls, extraBytes);
            }
            return (MemorySegment)mh$.invokeExact(cls, extraBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_constructInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_constructInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static FunctionDescriptor objc_constructInstance$descriptor() {
        return objc_constructInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static MethodHandle objc_constructInstance$handle() {
        return objc_constructInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static MemorySegment objc_constructInstance$address() {
        return objc_constructInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static MemorySegment objc_constructInstance(MemorySegment cls, MemorySegment bytes) {
        var mh$ = objc_constructInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_constructInstance", cls, bytes);
            }
            return (MemorySegment)mh$.invokeExact(cls, bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_destructInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_destructInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_destructInstance$descriptor() {
        return objc_destructInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static MethodHandle objc_destructInstance$handle() {
        return objc_destructInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_destructInstance$address() {
        return objc_destructInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_destructInstance(MemorySegment obj) {
        var mh$ = objc_destructInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_destructInstance", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_allocateClassPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_allocateClassPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static FunctionDescriptor objc_allocateClassPair$descriptor() {
        return objc_allocateClassPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MethodHandle objc_allocateClassPair$handle() {
        return objc_allocateClassPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_allocateClassPair$address() {
        return objc_allocateClassPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_allocateClassPair(MemorySegment superclass, MemorySegment name, long extraBytes) {
        var mh$ = objc_allocateClassPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_allocateClassPair", superclass, name, extraBytes);
            }
            return (MemorySegment)mh$.invokeExact(superclass, name, extraBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_registerClassPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_registerClassPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static FunctionDescriptor objc_registerClassPair$descriptor() {
        return objc_registerClassPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static MethodHandle objc_registerClassPair$handle() {
        return objc_registerClassPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static MemorySegment objc_registerClassPair$address() {
        return objc_registerClassPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static void objc_registerClassPair(MemorySegment cls) {
        var mh$ = objc_registerClassPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_registerClassPair", cls);
            }
            mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_duplicateClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_duplicateClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static FunctionDescriptor objc_duplicateClass$descriptor() {
        return objc_duplicateClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MethodHandle objc_duplicateClass$handle() {
        return objc_duplicateClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_duplicateClass$address() {
        return objc_duplicateClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_duplicateClass(MemorySegment original, MemorySegment name, long extraBytes) {
        var mh$ = objc_duplicateClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_duplicateClass", original, name, extraBytes);
            }
            return (MemorySegment)mh$.invokeExact(original, name, extraBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_disposeClassPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_disposeClassPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static FunctionDescriptor objc_disposeClassPair$descriptor() {
        return objc_disposeClassPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static MethodHandle objc_disposeClassPair$handle() {
        return objc_disposeClassPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static MemorySegment objc_disposeClassPair$address() {
        return objc_disposeClassPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static void objc_disposeClassPair(MemorySegment cls) {
        var mh$ = objc_disposeClassPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_disposeClassPair", cls);
            }
            mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getName$descriptor() {
        return method_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getName$handle() {
        return method_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getName$address() {
        return method_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getName(MemorySegment m) {
        var mh$ = method_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getName", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getImplementation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getImplementation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getImplementation$descriptor() {
        return method_getImplementation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getImplementation$handle() {
        return method_getImplementation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getImplementation$address() {
        return method_getImplementation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getImplementation(MemorySegment m) {
        var mh$ = method_getImplementation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getImplementation", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getTypeEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getTypeEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getTypeEncoding$descriptor() {
        return method_getTypeEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getTypeEncoding$handle() {
        return method_getTypeEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getTypeEncoding$address() {
        return method_getTypeEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getTypeEncoding(MemorySegment m) {
        var mh$ = method_getTypeEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getTypeEncoding", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getNumberOfArguments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getNumberOfArguments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getNumberOfArguments$descriptor() {
        return method_getNumberOfArguments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getNumberOfArguments$handle() {
        return method_getNumberOfArguments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getNumberOfArguments$address() {
        return method_getNumberOfArguments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static int method_getNumberOfArguments(MemorySegment m) {
        var mh$ = method_getNumberOfArguments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getNumberOfArguments", m);
            }
            return (int)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_copyReturnType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_copyReturnType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_copyReturnType$descriptor() {
        return method_copyReturnType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_copyReturnType$handle() {
        return method_copyReturnType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_copyReturnType$address() {
        return method_copyReturnType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_copyReturnType(MemorySegment m) {
        var mh$ = method_copyReturnType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_copyReturnType", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_copyArgumentType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_copyArgumentType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static FunctionDescriptor method_copyArgumentType$descriptor() {
        return method_copyArgumentType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static MethodHandle method_copyArgumentType$handle() {
        return method_copyArgumentType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static MemorySegment method_copyArgumentType$address() {
        return method_copyArgumentType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static MemorySegment method_copyArgumentType(MemorySegment m, int index) {
        var mh$ = method_copyArgumentType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_copyArgumentType", m, index);
            }
            return (MemorySegment)mh$.invokeExact(m, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getReturnType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getReturnType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static FunctionDescriptor method_getReturnType$descriptor() {
        return method_getReturnType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static MethodHandle method_getReturnType$handle() {
        return method_getReturnType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static MemorySegment method_getReturnType$address() {
        return method_getReturnType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static void method_getReturnType(MemorySegment m, MemorySegment dst, long dst_len) {
        var mh$ = method_getReturnType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getReturnType", m, dst, dst_len);
            }
            mh$.invokeExact(m, dst, dst_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getArgumentType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getArgumentType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static FunctionDescriptor method_getArgumentType$descriptor() {
        return method_getArgumentType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static MethodHandle method_getArgumentType$handle() {
        return method_getArgumentType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static MemorySegment method_getArgumentType$address() {
        return method_getArgumentType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static void method_getArgumentType(MemorySegment m, int index, MemorySegment dst, long dst_len) {
        var mh$ = method_getArgumentType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getArgumentType", m, index, dst, dst_len);
            }
            mh$.invokeExact(m, index, dst, dst_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getDescription$descriptor() {
        return method_getDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getDescription$handle() {
        return method_getDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getDescription$address() {
        return method_getDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getDescription(MemorySegment m) {
        var mh$ = method_getDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getDescription", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_setImplementation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_setImplementation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static FunctionDescriptor method_setImplementation$descriptor() {
        return method_setImplementation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static MethodHandle method_setImplementation$handle() {
        return method_setImplementation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static MemorySegment method_setImplementation$address() {
        return method_setImplementation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static MemorySegment method_setImplementation(MemorySegment m, MemorySegment imp) {
        var mh$ = method_setImplementation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_setImplementation", m, imp);
            }
            return (MemorySegment)mh$.invokeExact(m, imp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_exchangeImplementations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_exchangeImplementations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static FunctionDescriptor method_exchangeImplementations$descriptor() {
        return method_exchangeImplementations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static MethodHandle method_exchangeImplementations$handle() {
        return method_exchangeImplementations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static MemorySegment method_exchangeImplementations$address() {
        return method_exchangeImplementations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static void method_exchangeImplementations(MemorySegment m1, MemorySegment m2) {
        var mh$ = method_exchangeImplementations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_exchangeImplementations", m1, m2);
            }
            mh$.invokeExact(m1, m2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ivar_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ivar_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static FunctionDescriptor ivar_getName$descriptor() {
        return ivar_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static MethodHandle ivar_getName$handle() {
        return ivar_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getName$address() {
        return ivar_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getName(MemorySegment v) {
        var mh$ = ivar_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ivar_getName", v);
            }
            return (MemorySegment)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ivar_getTypeEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ivar_getTypeEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static FunctionDescriptor ivar_getTypeEncoding$descriptor() {
        return ivar_getTypeEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static MethodHandle ivar_getTypeEncoding$handle() {
        return ivar_getTypeEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getTypeEncoding$address() {
        return ivar_getTypeEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getTypeEncoding(MemorySegment v) {
        var mh$ = ivar_getTypeEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ivar_getTypeEncoding", v);
            }
            return (MemorySegment)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ivar_getOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ivar_getOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static FunctionDescriptor ivar_getOffset$descriptor() {
        return ivar_getOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static MethodHandle ivar_getOffset$handle() {
        return ivar_getOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getOffset$address() {
        return ivar_getOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static long ivar_getOffset(MemorySegment v) {
        var mh$ = ivar_getOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ivar_getOffset", v);
            }
            return (long)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static FunctionDescriptor property_getName$descriptor() {
        return property_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static MethodHandle property_getName$handle() {
        return property_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getName$address() {
        return property_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getName(MemorySegment property) {
        var mh$ = property_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_getName", property);
            }
            return (MemorySegment)mh$.invokeExact(property);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_getAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_getAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static FunctionDescriptor property_getAttributes$descriptor() {
        return property_getAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static MethodHandle property_getAttributes$handle() {
        return property_getAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getAttributes$address() {
        return property_getAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getAttributes(MemorySegment property) {
        var mh$ = property_getAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_getAttributes", property);
            }
            return (MemorySegment)mh$.invokeExact(property);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_copyAttributeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_copyAttributeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor property_copyAttributeList$descriptor() {
        return property_copyAttributeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle property_copyAttributeList$handle() {
        return property_copyAttributeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment property_copyAttributeList$address() {
        return property_copyAttributeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment property_copyAttributeList(MemorySegment property, MemorySegment outCount) {
        var mh$ = property_copyAttributeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_copyAttributeList", property, outCount);
            }
            return (MemorySegment)mh$.invokeExact(property, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_copyAttributeValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_copyAttributeValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static FunctionDescriptor property_copyAttributeValue$descriptor() {
        return property_copyAttributeValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static MethodHandle property_copyAttributeValue$handle() {
        return property_copyAttributeValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static MemorySegment property_copyAttributeValue$address() {
        return property_copyAttributeValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static MemorySegment property_copyAttributeValue(MemorySegment property, MemorySegment attributeName) {
        var mh$ = property_copyAttributeValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_copyAttributeValue", property, attributeName);
            }
            return (MemorySegment)mh$.invokeExact(property, attributeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getProtocol$descriptor() {
        return objc_getProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getProtocol$handle() {
        return objc_getProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getProtocol$address() {
        return objc_getProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getProtocol(MemorySegment name) {
        var mh$ = objc_getProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getProtocol", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyProtocolList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyProtocolList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyProtocolList$descriptor() {
        return objc_copyProtocolList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyProtocolList$handle() {
        return objc_copyProtocolList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyProtocolList$address() {
        return objc_copyProtocolList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyProtocolList(MemorySegment outCount) {
        var mh$ = objc_copyProtocolList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyProtocolList", outCount);
            }
            return (MemorySegment)mh$.invokeExact(outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_conformsToProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_conformsToProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static FunctionDescriptor protocol_conformsToProtocol$descriptor() {
        return protocol_conformsToProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MethodHandle protocol_conformsToProtocol$handle() {
        return protocol_conformsToProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MemorySegment protocol_conformsToProtocol$address() {
        return protocol_conformsToProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static boolean protocol_conformsToProtocol(MemorySegment proto, MemorySegment other) {
        var mh$ = protocol_conformsToProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_conformsToProtocol", proto, other);
            }
            return (boolean)mh$.invokeExact(proto, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_isEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_isEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static FunctionDescriptor protocol_isEqual$descriptor() {
        return protocol_isEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MethodHandle protocol_isEqual$handle() {
        return protocol_isEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MemorySegment protocol_isEqual$address() {
        return protocol_isEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static boolean protocol_isEqual(MemorySegment proto, MemorySegment other) {
        var mh$ = protocol_isEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_isEqual", proto, other);
            }
            return (boolean)mh$.invokeExact(proto, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static FunctionDescriptor protocol_getName$descriptor() {
        return protocol_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static MethodHandle protocol_getName$handle() {
        return protocol_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static MemorySegment protocol_getName$address() {
        return protocol_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static MemorySegment protocol_getName(MemorySegment proto) {
        var mh$ = protocol_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_getName", proto);
            }
            return (MemorySegment)mh$.invokeExact(proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_getMethodDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            objc_method_description.layout(),
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_getMethodDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static FunctionDescriptor protocol_getMethodDescription$descriptor() {
        return protocol_getMethodDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MethodHandle protocol_getMethodDescription$handle() {
        return protocol_getMethodDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MemorySegment protocol_getMethodDescription$address() {
        return protocol_getMethodDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MemorySegment protocol_getMethodDescription(SegmentAllocator allocator, MemorySegment proto, MemorySegment aSel, boolean isRequiredMethod, boolean isInstanceMethod) {
        var mh$ = protocol_getMethodDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_getMethodDescription", allocator, proto, aSel, isRequiredMethod, isInstanceMethod);
            }
            return (MemorySegment)mh$.invokeExact(allocator, proto, aSel, isRequiredMethod, isInstanceMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyMethodDescriptionList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyMethodDescriptionList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor protocol_copyMethodDescriptionList$descriptor() {
        return protocol_copyMethodDescriptionList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle protocol_copyMethodDescriptionList$handle() {
        return protocol_copyMethodDescriptionList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyMethodDescriptionList$address() {
        return protocol_copyMethodDescriptionList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyMethodDescriptionList(MemorySegment proto, boolean isRequiredMethod, boolean isInstanceMethod, MemorySegment outCount) {
        var mh$ = protocol_copyMethodDescriptionList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyMethodDescriptionList", proto, isRequiredMethod, isInstanceMethod, outCount);
            }
            return (MemorySegment)mh$.invokeExact(proto, isRequiredMethod, isInstanceMethod, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_getProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_getProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static FunctionDescriptor protocol_getProperty$descriptor() {
        return protocol_getProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MethodHandle protocol_getProperty$handle() {
        return protocol_getProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_getProperty$address() {
        return protocol_getProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_getProperty(MemorySegment proto, MemorySegment name, boolean isRequiredProperty, boolean isInstanceProperty) {
        var mh$ = protocol_getProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_getProperty", proto, name, isRequiredProperty, isInstanceProperty);
            }
            return (MemorySegment)mh$.invokeExact(proto, name, isRequiredProperty, isInstanceProperty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyPropertyList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyPropertyList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor protocol_copyPropertyList$descriptor() {
        return protocol_copyPropertyList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle protocol_copyPropertyList$handle() {
        return protocol_copyPropertyList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyPropertyList$address() {
        return protocol_copyPropertyList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyPropertyList(MemorySegment proto, MemorySegment outCount) {
        var mh$ = protocol_copyPropertyList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyPropertyList", proto, outCount);
            }
            return (MemorySegment)mh$.invokeExact(proto, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyPropertyList2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyPropertyList2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static FunctionDescriptor protocol_copyPropertyList2$descriptor() {
        return protocol_copyPropertyList2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MethodHandle protocol_copyPropertyList2$handle() {
        return protocol_copyPropertyList2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_copyPropertyList2$address() {
        return protocol_copyPropertyList2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_copyPropertyList2(MemorySegment proto, MemorySegment outCount, boolean isRequiredProperty, boolean isInstanceProperty) {
        var mh$ = protocol_copyPropertyList2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyPropertyList2", proto, outCount, isRequiredProperty, isInstanceProperty);
            }
            return (MemorySegment)mh$.invokeExact(proto, outCount, isRequiredProperty, isInstanceProperty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyProtocolList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyProtocolList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor protocol_copyProtocolList$descriptor() {
        return protocol_copyProtocolList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle protocol_copyProtocolList$handle() {
        return protocol_copyProtocolList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyProtocolList$address() {
        return protocol_copyProtocolList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyProtocolList(MemorySegment proto, MemorySegment outCount) {
        var mh$ = protocol_copyProtocolList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyProtocolList", proto, outCount);
            }
            return (MemorySegment)mh$.invokeExact(proto, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_allocateProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_allocateProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_allocateProtocol$descriptor() {
        return objc_allocateProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_allocateProtocol$handle() {
        return objc_allocateProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_allocateProtocol$address() {
        return objc_allocateProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_allocateProtocol(MemorySegment name) {
        var mh$ = objc_allocateProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_allocateProtocol", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_registerProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_registerProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static FunctionDescriptor objc_registerProtocol$descriptor() {
        return objc_registerProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static MethodHandle objc_registerProtocol$handle() {
        return objc_registerProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static MemorySegment objc_registerProtocol$address() {
        return objc_registerProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static void objc_registerProtocol(MemorySegment proto) {
        var mh$ = objc_registerProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_registerProtocol", proto);
            }
            mh$.invokeExact(proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_addMethodDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_addMethodDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static FunctionDescriptor protocol_addMethodDescription$descriptor() {
        return protocol_addMethodDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MethodHandle protocol_addMethodDescription$handle() {
        return protocol_addMethodDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MemorySegment protocol_addMethodDescription$address() {
        return protocol_addMethodDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static void protocol_addMethodDescription(MemorySegment proto, MemorySegment name, MemorySegment types, boolean isRequiredMethod, boolean isInstanceMethod) {
        var mh$ = protocol_addMethodDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_addMethodDescription", proto, name, types, isRequiredMethod, isInstanceMethod);
            }
            mh$.invokeExact(proto, name, types, isRequiredMethod, isInstanceMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_addProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_addProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static FunctionDescriptor protocol_addProtocol$descriptor() {
        return protocol_addProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static MethodHandle protocol_addProtocol$handle() {
        return protocol_addProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static MemorySegment protocol_addProtocol$address() {
        return protocol_addProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static void protocol_addProtocol(MemorySegment proto, MemorySegment addition) {
        var mh$ = protocol_addProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_addProtocol", proto, addition);
            }
            mh$.invokeExact(proto, addition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_addProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_addProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static FunctionDescriptor protocol_addProperty$descriptor() {
        return protocol_addProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MethodHandle protocol_addProperty$handle() {
        return protocol_addProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_addProperty$address() {
        return protocol_addProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static void protocol_addProperty(MemorySegment proto, MemorySegment name, MemorySegment attributes, int attributeCount, boolean isRequiredProperty, boolean isInstanceProperty) {
        var mh$ = protocol_addProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_addProperty", proto, name, attributes, attributeCount, isRequiredProperty, isInstanceProperty);
            }
            mh$.invokeExact(proto, name, attributes, attributeCount, isRequiredProperty, isInstanceProperty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyImageNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyImageNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyImageNames$descriptor() {
        return objc_copyImageNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyImageNames$handle() {
        return objc_copyImageNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyImageNames$address() {
        return objc_copyImageNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyImageNames(MemorySegment outCount) {
        var mh$ = objc_copyImageNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyImageNames", outCount);
            }
            return (MemorySegment)mh$.invokeExact(outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getImageName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getImageName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getImageName$descriptor() {
        return class_getImageName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getImageName$handle() {
        return class_getImageName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getImageName$address() {
        return class_getImageName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getImageName(MemorySegment cls) {
        var mh$ = class_getImageName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getImageName", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyClassNamesForImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyClassNamesForImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyClassNamesForImage$descriptor() {
        return objc_copyClassNamesForImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyClassNamesForImage$handle() {
        return objc_copyClassNamesForImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassNamesForImage$address() {
        return objc_copyClassNamesForImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassNamesForImage(MemorySegment image, MemorySegment outCount) {
        var mh$ = objc_copyClassNamesForImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyClassNamesForImage", image, outCount);
            }
            return (MemorySegment)mh$.invokeExact(image, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_isEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_isEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static FunctionDescriptor sel_isEqual$descriptor() {
        return sel_isEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static MethodHandle sel_isEqual$handle() {
        return sel_isEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static MemorySegment sel_isEqual$address() {
        return sel_isEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static boolean sel_isEqual(MemorySegment lhs, MemorySegment rhs) {
        var mh$ = sel_isEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_isEqual", lhs, rhs);
            }
            return (boolean)mh$.invokeExact(lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_enumerationMutation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_enumerationMutation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static FunctionDescriptor objc_enumerationMutation$descriptor() {
        return objc_enumerationMutation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static MethodHandle objc_enumerationMutation$handle() {
        return objc_enumerationMutation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static MemorySegment objc_enumerationMutation$address() {
        return objc_enumerationMutation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static void objc_enumerationMutation(MemorySegment obj) {
        var mh$ = objc_enumerationMutation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_enumerationMutation", obj);
            }
            mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setEnumerationMutationHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setEnumerationMutationHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static FunctionDescriptor objc_setEnumerationMutationHandler$descriptor() {
        return objc_setEnumerationMutationHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static MethodHandle objc_setEnumerationMutationHandler$handle() {
        return objc_setEnumerationMutationHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static MemorySegment objc_setEnumerationMutationHandler$address() {
        return objc_setEnumerationMutationHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static void objc_setEnumerationMutationHandler(MemorySegment handler) {
        var mh$ = objc_setEnumerationMutationHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setEnumerationMutationHandler", handler);
            }
            mh$.invokeExact(handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setForwardHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setForwardHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static FunctionDescriptor objc_setForwardHandler$descriptor() {
        return objc_setForwardHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static MethodHandle objc_setForwardHandler$handle() {
        return objc_setForwardHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static MemorySegment objc_setForwardHandler$address() {
        return objc_setForwardHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static void objc_setForwardHandler(MemorySegment fwd, MemorySegment fwd_stret) {
        var mh$ = objc_setForwardHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setForwardHandler", fwd, fwd_stret);
            }
            mh$.invokeExact(fwd, fwd_stret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imp_implementationWithBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("imp_implementationWithBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static FunctionDescriptor imp_implementationWithBlock$descriptor() {
        return imp_implementationWithBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static MethodHandle imp_implementationWithBlock$handle() {
        return imp_implementationWithBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static MemorySegment imp_implementationWithBlock$address() {
        return imp_implementationWithBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static MemorySegment imp_implementationWithBlock(MemorySegment block) {
        var mh$ = imp_implementationWithBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imp_implementationWithBlock", block);
            }
            return (MemorySegment)mh$.invokeExact(block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imp_getBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("imp_getBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static FunctionDescriptor imp_getBlock$descriptor() {
        return imp_getBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MethodHandle imp_getBlock$handle() {
        return imp_getBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MemorySegment imp_getBlock$address() {
        return imp_getBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MemorySegment imp_getBlock(MemorySegment anImp) {
        var mh$ = imp_getBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imp_getBlock", anImp);
            }
            return (MemorySegment)mh$.invokeExact(anImp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imp_removeBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("imp_removeBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static FunctionDescriptor imp_removeBlock$descriptor() {
        return imp_removeBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MethodHandle imp_removeBlock$handle() {
        return imp_removeBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MemorySegment imp_removeBlock$address() {
        return imp_removeBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static boolean imp_removeBlock(MemorySegment anImp) {
        var mh$ = imp_removeBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imp_removeBlock", anImp);
            }
            return (boolean)mh$.invokeExact(anImp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_loadWeak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_loadWeak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static FunctionDescriptor objc_loadWeak$descriptor() {
        return objc_loadWeak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static MethodHandle objc_loadWeak$handle() {
        return objc_loadWeak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static MemorySegment objc_loadWeak$address() {
        return objc_loadWeak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static MemorySegment objc_loadWeak(MemorySegment location) {
        var mh$ = objc_loadWeak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_loadWeak", location);
            }
            return (MemorySegment)mh$.invokeExact(location);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_storeWeak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_storeWeak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_storeWeak$descriptor() {
        return objc_storeWeak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static MethodHandle objc_storeWeak$handle() {
        return objc_storeWeak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_storeWeak$address() {
        return objc_storeWeak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_storeWeak(MemorySegment location, MemorySegment obj) {
        var mh$ = objc_storeWeak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_storeWeak", location, obj);
            }
            return (MemorySegment)mh$.invokeExact(location, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uintptr_t objc_AssociationPolicy
     * }
     */
    public static final OfLong objc_AssociationPolicy = ObjCRuntime.C_LONG;
    private static final int OBJC_ASSOCIATION_ASSIGN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_ASSIGN = 0
     * }
     */
    public static int OBJC_ASSOCIATION_ASSIGN() {
        return OBJC_ASSOCIATION_ASSIGN;
    }
    private static final int OBJC_ASSOCIATION_RETAIN_NONATOMIC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1
     * }
     */
    public static int OBJC_ASSOCIATION_RETAIN_NONATOMIC() {
        return OBJC_ASSOCIATION_RETAIN_NONATOMIC;
    }
    private static final int OBJC_ASSOCIATION_COPY_NONATOMIC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_COPY_NONATOMIC = 3
     * }
     */
    public static int OBJC_ASSOCIATION_COPY_NONATOMIC() {
        return OBJC_ASSOCIATION_COPY_NONATOMIC;
    }
    private static final int OBJC_ASSOCIATION_RETAIN = (int)769L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_RETAIN = 769
     * }
     */
    public static int OBJC_ASSOCIATION_RETAIN() {
        return OBJC_ASSOCIATION_RETAIN;
    }
    private static final int OBJC_ASSOCIATION_COPY = (int)771L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_COPY = 771
     * }
     */
    public static int OBJC_ASSOCIATION_COPY() {
        return OBJC_ASSOCIATION_COPY;
    }

    private static class objc_setAssociatedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setAssociatedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static FunctionDescriptor objc_setAssociatedObject$descriptor() {
        return objc_setAssociatedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static MethodHandle objc_setAssociatedObject$handle() {
        return objc_setAssociatedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static MemorySegment objc_setAssociatedObject$address() {
        return objc_setAssociatedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static void objc_setAssociatedObject(MemorySegment object, MemorySegment key, MemorySegment value, long policy) {
        var mh$ = objc_setAssociatedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setAssociatedObject", object, key, value, policy);
            }
            mh$.invokeExact(object, key, value, policy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getAssociatedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getAssociatedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static FunctionDescriptor objc_getAssociatedObject$descriptor() {
        return objc_getAssociatedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static MethodHandle objc_getAssociatedObject$handle() {
        return objc_getAssociatedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static MemorySegment objc_getAssociatedObject$address() {
        return objc_getAssociatedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static MemorySegment objc_getAssociatedObject(MemorySegment object, MemorySegment key) {
        var mh$ = objc_getAssociatedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getAssociatedObject", object, key);
            }
            return (MemorySegment)mh$.invokeExact(object, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_removeAssociatedObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_removeAssociatedObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static FunctionDescriptor objc_removeAssociatedObjects$descriptor() {
        return objc_removeAssociatedObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static MethodHandle objc_removeAssociatedObjects$handle() {
        return objc_removeAssociatedObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static MemorySegment objc_removeAssociatedObjects$address() {
        return objc_removeAssociatedObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static void objc_removeAssociatedObjects(MemorySegment object) {
        var mh$ = objc_removeAssociatedObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_removeAssociatedObjects", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setHook_getImageName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setHook_getImageName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static FunctionDescriptor objc_setHook_getImageName$descriptor() {
        return objc_setHook_getImageName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MethodHandle objc_setHook_getImageName$handle() {
        return objc_setHook_getImageName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MemorySegment objc_setHook_getImageName$address() {
        return objc_setHook_getImageName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static void objc_setHook_getImageName(MemorySegment newValue, MemorySegment outOldValue) {
        var mh$ = objc_setHook_getImageName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setHook_getImageName", newValue, outOldValue);
            }
            mh$.invokeExact(newValue, outOldValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setHook_getClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setHook_getClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static FunctionDescriptor objc_setHook_getClass$descriptor() {
        return objc_setHook_getClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MethodHandle objc_setHook_getClass$handle() {
        return objc_setHook_getClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MemorySegment objc_setHook_getClass$address() {
        return objc_setHook_getClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static void objc_setHook_getClass(MemorySegment newValue, MemorySegment outOldValue) {
        var mh$ = objc_setHook_getClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setHook_getClass", newValue, outOldValue);
            }
            mh$.invokeExact(newValue, outOldValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_addLoadImageFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_addLoadImageFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static FunctionDescriptor objc_addLoadImageFunc$descriptor() {
        return objc_addLoadImageFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static MethodHandle objc_addLoadImageFunc$handle() {
        return objc_addLoadImageFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static MemorySegment objc_addLoadImageFunc$address() {
        return objc_addLoadImageFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static void objc_addLoadImageFunc(MemorySegment func) {
        var mh$ = objc_addLoadImageFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_addLoadImageFunc", func);
            }
            mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setHook_lazyClassNamer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setHook_lazyClassNamer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static FunctionDescriptor objc_setHook_lazyClassNamer$descriptor() {
        return objc_setHook_lazyClassNamer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static MethodHandle objc_setHook_lazyClassNamer$handle() {
        return objc_setHook_lazyClassNamer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static MemorySegment objc_setHook_lazyClassNamer$address() {
        return objc_setHook_lazyClassNamer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static void objc_setHook_lazyClassNamer(MemorySegment newValue, MemorySegment oldOutValue) {
        var mh$ = objc_setHook_lazyClassNamer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setHook_lazyClassNamer", newValue, oldOutValue);
            }
            mh$.invokeExact(newValue, oldOutValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _objc_realizeClassFromSwift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_objc_realizeClassFromSwift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static FunctionDescriptor _objc_realizeClassFromSwift$descriptor() {
        return _objc_realizeClassFromSwift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static MethodHandle _objc_realizeClassFromSwift$handle() {
        return _objc_realizeClassFromSwift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static MemorySegment _objc_realizeClassFromSwift$address() {
        return _objc_realizeClassFromSwift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static MemorySegment _objc_realizeClassFromSwift(MemorySegment cls, MemorySegment previously) {
        var mh$ = _objc_realizeClassFromSwift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_objc_realizeClassFromSwift", cls, previously);
            }
            return (MemorySegment)mh$.invokeExact(cls, previously);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _objc_flush_caches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_objc_flush_caches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor _objc_flush_caches$descriptor() {
        return _objc_flush_caches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static MethodHandle _objc_flush_caches$handle() {
        return _objc_flush_caches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static MemorySegment _objc_flush_caches$address() {
        return _objc_flush_caches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static void _objc_flush_caches(MemorySegment cls) {
        var mh$ = _objc_flush_caches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_objc_flush_caches", cls);
            }
            mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_lookupMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_lookupMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor class_lookupMethod$descriptor() {
        return class_lookupMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle class_lookupMethod$handle() {
        return class_lookupMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_lookupMethod$address() {
        return class_lookupMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_lookupMethod(MemorySegment cls, MemorySegment sel) {
        var mh$ = class_lookupMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_lookupMethod", cls, sel);
            }
            return (MemorySegment)mh$.invokeExact(cls, sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_respondsToMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_respondsToMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor class_respondsToMethod$descriptor() {
        return class_respondsToMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle class_respondsToMethod$handle() {
        return class_respondsToMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_respondsToMethod$address() {
        return class_respondsToMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static boolean class_respondsToMethod(MemorySegment cls, MemorySegment sel) {
        var mh$ = class_respondsToMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_respondsToMethod", cls, sel);
            }
            return (boolean)mh$.invokeExact(cls, sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_copyFromZone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_copyFromZone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static FunctionDescriptor object_copyFromZone$descriptor() {
        return object_copyFromZone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static MethodHandle object_copyFromZone$handle() {
        return object_copyFromZone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static MemorySegment object_copyFromZone$address() {
        return object_copyFromZone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static MemorySegment object_copyFromZone(MemorySegment anObject, long nBytes, MemorySegment zone) {
        var mh$ = object_copyFromZone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_copyFromZone", anObject, nBytes, zone);
            }
            return (MemorySegment)mh$.invokeExact(anObject, nBytes, zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_createInstanceFromZone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_createInstanceFromZone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static FunctionDescriptor class_createInstanceFromZone$descriptor() {
        return class_createInstanceFromZone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static MethodHandle class_createInstanceFromZone$handle() {
        return class_createInstanceFromZone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static MemorySegment class_createInstanceFromZone$address() {
        return class_createInstanceFromZone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static MemorySegment class_createInstanceFromZone(MemorySegment x0, long idxIvars, MemorySegment zone) {
        var mh$ = class_createInstanceFromZone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_createInstanceFromZone", x0, idxIvars, zone);
            }
            return (MemorySegment)mh$.invokeExact(x0, idxIvars, zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_msgSend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_msgSend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_msgSend()
     * }
     */
    public static FunctionDescriptor objc_msgSend$descriptor() {
        return objc_msgSend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_msgSend()
     * }
     */
    public static MethodHandle objc_msgSend$handle() {
        return objc_msgSend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_msgSend()
     * }
     */
    public static MemorySegment objc_msgSend$address() {
        return objc_msgSend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_msgSend()
     * }
     */
    public static void objc_msgSend() {
        var mh$ = objc_msgSend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_msgSend");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_msgSendSuper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_msgSendSuper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper()
     * }
     */
    public static FunctionDescriptor objc_msgSendSuper$descriptor() {
        return objc_msgSendSuper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper()
     * }
     */
    public static MethodHandle objc_msgSendSuper$handle() {
        return objc_msgSendSuper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper()
     * }
     */
    public static MemorySegment objc_msgSendSuper$address() {
        return objc_msgSendSuper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_msgSendSuper()
     * }
     */
    public static void objc_msgSendSuper() {
        var mh$ = objc_msgSendSuper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_msgSendSuper");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_msgSend_stret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_msgSend_stret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_msgSend_stret()
     * }
     */
    public static FunctionDescriptor objc_msgSend_stret$descriptor() {
        return objc_msgSend_stret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_msgSend_stret()
     * }
     */
    public static MethodHandle objc_msgSend_stret$handle() {
        return objc_msgSend_stret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_msgSend_stret()
     * }
     */
    public static MemorySegment objc_msgSend_stret$address() {
        return objc_msgSend_stret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_msgSend_stret()
     * }
     */
    public static void objc_msgSend_stret() {
        var mh$ = objc_msgSend_stret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_msgSend_stret");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_msgSendSuper_stret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_msgSendSuper_stret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper_stret()
     * }
     */
    public static FunctionDescriptor objc_msgSendSuper_stret$descriptor() {
        return objc_msgSendSuper_stret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper_stret()
     * }
     */
    public static MethodHandle objc_msgSendSuper_stret$handle() {
        return objc_msgSendSuper_stret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper_stret()
     * }
     */
    public static MemorySegment objc_msgSendSuper_stret$address() {
        return objc_msgSendSuper_stret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_msgSendSuper_stret()
     * }
     */
    public static void objc_msgSendSuper_stret() {
        var mh$ = objc_msgSendSuper_stret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_msgSendSuper_stret");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_invoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_invoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_invoke()
     * }
     */
    public static FunctionDescriptor method_invoke$descriptor() {
        return method_invoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_invoke()
     * }
     */
    public static MethodHandle method_invoke$handle() {
        return method_invoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_invoke()
     * }
     */
    public static MemorySegment method_invoke$address() {
        return method_invoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_invoke()
     * }
     */
    public static void method_invoke() {
        var mh$ = method_invoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_invoke");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_invoke_stret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_invoke_stret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_invoke_stret()
     * }
     */
    public static FunctionDescriptor method_invoke_stret$descriptor() {
        return method_invoke_stret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_invoke_stret()
     * }
     */
    public static MethodHandle method_invoke_stret$handle() {
        return method_invoke_stret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_invoke_stret()
     * }
     */
    public static MemorySegment method_invoke_stret$address() {
        return method_invoke_stret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_invoke_stret()
     * }
     */
    public static void method_invoke_stret() {
        var mh$ = method_invoke_stret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_invoke_stret");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _objc_msgForward {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_objc_msgForward");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _objc_msgForward()
     * }
     */
    public static FunctionDescriptor _objc_msgForward$descriptor() {
        return _objc_msgForward.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _objc_msgForward()
     * }
     */
    public static MethodHandle _objc_msgForward$handle() {
        return _objc_msgForward.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _objc_msgForward()
     * }
     */
    public static MemorySegment _objc_msgForward$address() {
        return _objc_msgForward.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _objc_msgForward()
     * }
     */
    public static void _objc_msgForward() {
        var mh$ = _objc_msgForward.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_objc_msgForward");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _objc_msgForward_stret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_objc_msgForward_stret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _objc_msgForward_stret()
     * }
     */
    public static FunctionDescriptor _objc_msgForward_stret$descriptor() {
        return _objc_msgForward_stret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _objc_msgForward_stret()
     * }
     */
    public static MethodHandle _objc_msgForward_stret$handle() {
        return _objc_msgForward_stret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _objc_msgForward_stret()
     * }
     */
    public static MemorySegment _objc_msgForward_stret$address() {
        return _objc_msgForward_stret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _objc_msgForward_stret()
     * }
     */
    public static void _objc_msgForward_stret() {
        var mh$ = _objc_msgForward_stret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_objc_msgForward_stret");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_exception_throw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_exception_throw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_exception_throw(id  _Nonnull exception)
     * }
     */
    public static FunctionDescriptor objc_exception_throw$descriptor() {
        return objc_exception_throw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_exception_throw(id  _Nonnull exception)
     * }
     */
    public static MethodHandle objc_exception_throw$handle() {
        return objc_exception_throw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_exception_throw(id  _Nonnull exception)
     * }
     */
    public static MemorySegment objc_exception_throw$address() {
        return objc_exception_throw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_exception_throw(id  _Nonnull exception)
     * }
     */
    public static void objc_exception_throw(MemorySegment exception) {
        var mh$ = objc_exception_throw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_exception_throw", exception);
            }
            mh$.invokeExact(exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_exception_rethrow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_exception_rethrow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_exception_rethrow()
     * }
     */
    public static FunctionDescriptor objc_exception_rethrow$descriptor() {
        return objc_exception_rethrow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_exception_rethrow()
     * }
     */
    public static MethodHandle objc_exception_rethrow$handle() {
        return objc_exception_rethrow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_exception_rethrow()
     * }
     */
    public static MemorySegment objc_exception_rethrow$address() {
        return objc_exception_rethrow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_exception_rethrow()
     * }
     */
    public static void objc_exception_rethrow() {
        var mh$ = objc_exception_rethrow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_exception_rethrow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_begin_catch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_begin_catch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nonnull objc_begin_catch(void * _Nonnull exc_buf)
     * }
     */
    public static FunctionDescriptor objc_begin_catch$descriptor() {
        return objc_begin_catch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nonnull objc_begin_catch(void * _Nonnull exc_buf)
     * }
     */
    public static MethodHandle objc_begin_catch$handle() {
        return objc_begin_catch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nonnull objc_begin_catch(void * _Nonnull exc_buf)
     * }
     */
    public static MemorySegment objc_begin_catch$address() {
        return objc_begin_catch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nonnull objc_begin_catch(void * _Nonnull exc_buf)
     * }
     */
    public static MemorySegment objc_begin_catch(MemorySegment exc_buf) {
        var mh$ = objc_begin_catch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_begin_catch", exc_buf);
            }
            return (MemorySegment)mh$.invokeExact(exc_buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_end_catch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_end_catch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_end_catch()
     * }
     */
    public static FunctionDescriptor objc_end_catch$descriptor() {
        return objc_end_catch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_end_catch()
     * }
     */
    public static MethodHandle objc_end_catch$handle() {
        return objc_end_catch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_end_catch()
     * }
     */
    public static MemorySegment objc_end_catch$address() {
        return objc_end_catch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_end_catch()
     * }
     */
    public static void objc_end_catch() {
        var mh$ = objc_end_catch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_end_catch");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_terminate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_terminate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_terminate()
     * }
     */
    public static FunctionDescriptor objc_terminate$descriptor() {
        return objc_terminate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_terminate()
     * }
     */
    public static MethodHandle objc_terminate$handle() {
        return objc_terminate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_terminate()
     * }
     */
    public static MemorySegment objc_terminate$address() {
        return objc_terminate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_terminate()
     * }
     */
    public static void objc_terminate() {
        var mh$ = objc_terminate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_terminate");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setExceptionPreprocessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setExceptionPreprocessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_exception_preprocessor  _Nonnull objc_setExceptionPreprocessor(objc_exception_preprocessor  _Nonnull fn)
     * }
     */
    public static FunctionDescriptor objc_setExceptionPreprocessor$descriptor() {
        return objc_setExceptionPreprocessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_exception_preprocessor  _Nonnull objc_setExceptionPreprocessor(objc_exception_preprocessor  _Nonnull fn)
     * }
     */
    public static MethodHandle objc_setExceptionPreprocessor$handle() {
        return objc_setExceptionPreprocessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_exception_preprocessor  _Nonnull objc_setExceptionPreprocessor(objc_exception_preprocessor  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setExceptionPreprocessor$address() {
        return objc_setExceptionPreprocessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_exception_preprocessor  _Nonnull objc_setExceptionPreprocessor(objc_exception_preprocessor  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setExceptionPreprocessor(MemorySegment fn) {
        var mh$ = objc_setExceptionPreprocessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setExceptionPreprocessor", fn);
            }
            return (MemorySegment)mh$.invokeExact(fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setExceptionMatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setExceptionMatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_exception_matcher  _Nonnull objc_setExceptionMatcher(objc_exception_matcher  _Nonnull fn)
     * }
     */
    public static FunctionDescriptor objc_setExceptionMatcher$descriptor() {
        return objc_setExceptionMatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_exception_matcher  _Nonnull objc_setExceptionMatcher(objc_exception_matcher  _Nonnull fn)
     * }
     */
    public static MethodHandle objc_setExceptionMatcher$handle() {
        return objc_setExceptionMatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_exception_matcher  _Nonnull objc_setExceptionMatcher(objc_exception_matcher  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setExceptionMatcher$address() {
        return objc_setExceptionMatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_exception_matcher  _Nonnull objc_setExceptionMatcher(objc_exception_matcher  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setExceptionMatcher(MemorySegment fn) {
        var mh$ = objc_setExceptionMatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setExceptionMatcher", fn);
            }
            return (MemorySegment)mh$.invokeExact(fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setUncaughtExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setUncaughtExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_uncaught_exception_handler  _Nonnull objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler  _Nonnull fn)
     * }
     */
    public static FunctionDescriptor objc_setUncaughtExceptionHandler$descriptor() {
        return objc_setUncaughtExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_uncaught_exception_handler  _Nonnull objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler  _Nonnull fn)
     * }
     */
    public static MethodHandle objc_setUncaughtExceptionHandler$handle() {
        return objc_setUncaughtExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_uncaught_exception_handler  _Nonnull objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setUncaughtExceptionHandler$address() {
        return objc_setUncaughtExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_uncaught_exception_handler  _Nonnull objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setUncaughtExceptionHandler(MemorySegment fn) {
        var mh$ = objc_setUncaughtExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setUncaughtExceptionHandler", fn);
            }
            return (MemorySegment)mh$.invokeExact(fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_addExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_addExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintptr_t objc_addExceptionHandler(objc_exception_handler  _Nonnull fn, void * _Nullable context)
     * }
     */
    public static FunctionDescriptor objc_addExceptionHandler$descriptor() {
        return objc_addExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintptr_t objc_addExceptionHandler(objc_exception_handler  _Nonnull fn, void * _Nullable context)
     * }
     */
    public static MethodHandle objc_addExceptionHandler$handle() {
        return objc_addExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintptr_t objc_addExceptionHandler(objc_exception_handler  _Nonnull fn, void * _Nullable context)
     * }
     */
    public static MemorySegment objc_addExceptionHandler$address() {
        return objc_addExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintptr_t objc_addExceptionHandler(objc_exception_handler  _Nonnull fn, void * _Nullable context)
     * }
     */
    public static long objc_addExceptionHandler(MemorySegment fn, MemorySegment context) {
        var mh$ = objc_addExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_addExceptionHandler", fn, context);
            }
            return (long)mh$.invokeExact(fn, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_removeExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_removeExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_removeExceptionHandler(uintptr_t token)
     * }
     */
    public static FunctionDescriptor objc_removeExceptionHandler$descriptor() {
        return objc_removeExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_removeExceptionHandler(uintptr_t token)
     * }
     */
    public static MethodHandle objc_removeExceptionHandler$handle() {
        return objc_removeExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_removeExceptionHandler(uintptr_t token)
     * }
     */
    public static MemorySegment objc_removeExceptionHandler$address() {
        return objc_removeExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_removeExceptionHandler(uintptr_t token)
     * }
     */
    public static void objc_removeExceptionHandler(long token) {
        var mh$ = objc_removeExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_removeExceptionHandler", token);
            }
            mh$.invokeExact(token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dst, MemorySegment __src, long __len) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dst, __src, __len);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset(MemorySegment __b, int __c, long __len) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __b, __c, __len);
            }
            return (MemorySegment)mh$.invokeExact(__b, __c, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __s1, __s2);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __s1, __s2, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __charset);
            }
            return (MemorySegment)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok(MemorySegment __str, MemorySegment __sep) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __str, __sep);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __s1, __s2, __n);
            }
            return (long)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __str, MemorySegment __sep, MemorySegment __lasts) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __str, __sep, __lasts);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep, __lasts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __strerrbuf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __strerrbuf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __strerrbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s1) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s1);
            }
            return (MemorySegment)mh$.invokeExact(__s1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dst, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dst, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __s1, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __s1, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static long strnlen(MemorySegment __s1, long __n) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __s1, __n);
            }
            return (long)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static FunctionDescriptor memset_s$descriptor() {
        return memset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MethodHandle memset_s$handle() {
        return memset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MemorySegment memset_s$address() {
        return memset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static int memset_s(MemorySegment __s, long __smax, int __c, long __n) {
        var mh$ = memset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_s", __s, __smax, __c, __n);
            }
            return (int)mh$.invokeExact(__s, __smax, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem(MemorySegment __big, long __big_len, MemorySegment __little, long __little_len) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __big, __big_len, __little, __little_len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __big_len, __little, __little_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memset_pattern4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern4$descriptor() {
        return memset_pattern4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern4$handle() {
        return memset_pattern4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern4$address() {
        return memset_pattern4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static void memset_pattern4(MemorySegment __b, MemorySegment __pattern4, long __len) {
        var mh$ = memset_pattern4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern4", __b, __pattern4, __len);
            }
            mh$.invokeExact(__b, __pattern4, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memset_pattern8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern8$descriptor() {
        return memset_pattern8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern8$handle() {
        return memset_pattern8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern8$address() {
        return memset_pattern8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static void memset_pattern8(MemorySegment __b, MemorySegment __pattern8, long __len) {
        var mh$ = memset_pattern8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern8", __b, __pattern8, __len);
            }
            mh$.invokeExact(__b, __pattern8, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memset_pattern16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern16$descriptor() {
        return memset_pattern16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern16$handle() {
        return memset_pattern16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern16$address() {
        return memset_pattern16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static void memset_pattern16(MemorySegment __b, MemorySegment __pattern16, long __len) {
        var mh$ = memset_pattern16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern16", __b, __pattern16, __len);
            }
            mh$.invokeExact(__b, __pattern16, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strnstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static FunctionDescriptor strnstr$descriptor() {
        return strnstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MethodHandle strnstr$handle() {
        return strnstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr$address() {
        return strnstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr(MemorySegment __big, MemorySegment __little, long __len) {
        var mh$ = strnstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnstr", __big, __little, __len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcat(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcpy(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static FunctionDescriptor strmode$descriptor() {
        return strmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MethodHandle strmode$handle() {
        return strmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MemorySegment strmode$address() {
        return strmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static void strmode(int __mode, MemorySegment __bp) {
        var mh$ = strmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strmode", __mode, __bp);
            }
            mh$.invokeExact(__mode, __bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static void swab(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timingsafe_bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("timingsafe_bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static FunctionDescriptor timingsafe_bcmp$descriptor() {
        return timingsafe_bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MethodHandle timingsafe_bcmp$handle() {
        return timingsafe_bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MemorySegment timingsafe_bcmp$address() {
        return timingsafe_bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static int timingsafe_bcmp(MemorySegment __b1, MemorySegment __b2, long __len) {
        var mh$ = timingsafe_bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timingsafe_bcmp", __b1, __b2, __len);
            }
            return (int)mh$.invokeExact(__b1, __b2, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strsignal_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strsignal_r$descriptor() {
        return strsignal_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strsignal_r$handle() {
        return strsignal_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strsignal_r$address() {
        return strsignal_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static int strsignal_r(int __sig, MemorySegment __strsignalbuf, long __buflen) {
        var mh$ = strsignal_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal_r", __sig, __strsignalbuf, __buflen);
            }
            return (int)mh$.invokeExact(__sig, __strsignalbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static int bcmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static void bcopy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static void bzero(MemorySegment x0, long x1) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index(MemorySegment x0, int x1) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex(MemorySegment x0, int x1) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static int ffs(int x0) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static int strcasecmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static int strncasecmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static int ffsl(long x0) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static int ffsll(long x0) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("fls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static FunctionDescriptor fls$descriptor() {
        return fls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MethodHandle fls$handle() {
        return fls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MemorySegment fls$address() {
        return fls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static int fls(int x0) {
        var mh$ = fls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fls", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("flsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static FunctionDescriptor flsl$descriptor() {
        return flsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MethodHandle flsl$handle() {
        return flsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MemorySegment flsl$address() {
        return flsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static int flsl(long x0) {
        var mh$ = flsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("flsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static FunctionDescriptor flsll$descriptor() {
        return flsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MethodHandle flsll$handle() {
        return flsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MemorySegment flsll$address() {
        return flsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static int flsll(long x0) {
        var mh$ = flsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int64_t OSAtomic_int64_aligned64_t
     * }
     */
    public static final OfLong OSAtomic_int64_aligned64_t = ObjCRuntime.C_LONG_LONG;

    private static class OSAtomicAdd32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAdd32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAdd32$descriptor() {
        return OSAtomicAdd32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAdd32$handle() {
        return OSAtomicAdd32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAdd32$address() {
        return OSAtomicAdd32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static int OSAtomicAdd32(int __theAmount, MemorySegment __theValue) {
        var mh$ = OSAtomicAdd32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAdd32", __theAmount, __theValue);
            }
            return (int)mh$.invokeExact(__theAmount, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAdd32Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAdd32Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32Barrier(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAdd32Barrier$descriptor() {
        return OSAtomicAdd32Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32Barrier(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAdd32Barrier$handle() {
        return OSAtomicAdd32Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32Barrier(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAdd32Barrier$address() {
        return OSAtomicAdd32Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32Barrier(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static int OSAtomicAdd32Barrier(int __theAmount, MemorySegment __theValue) {
        var mh$ = OSAtomicAdd32Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAdd32Barrier", __theAmount, __theValue);
            }
            return (int)mh$.invokeExact(__theAmount, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAdd64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAdd64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAdd64$descriptor() {
        return OSAtomicAdd64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAdd64$handle() {
        return OSAtomicAdd64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAdd64$address() {
        return OSAtomicAdd64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static long OSAtomicAdd64(long __theAmount, MemorySegment __theValue) {
        var mh$ = OSAtomicAdd64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAdd64", __theAmount, __theValue);
            }
            return (long)mh$.invokeExact(__theAmount, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAdd64Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAdd64Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64Barrier(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAdd64Barrier$descriptor() {
        return OSAtomicAdd64Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64Barrier(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAdd64Barrier$handle() {
        return OSAtomicAdd64Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64Barrier(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAdd64Barrier$address() {
        return OSAtomicAdd64Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64Barrier(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static long OSAtomicAdd64Barrier(long __theAmount, MemorySegment __theValue) {
        var mh$ = OSAtomicAdd64Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAdd64Barrier", __theAmount, __theValue);
            }
            return (long)mh$.invokeExact(__theAmount, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicOr32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicOr32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicOr32$descriptor() {
        return OSAtomicOr32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicOr32$handle() {
        return OSAtomicOr32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicOr32$address() {
        return OSAtomicOr32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicOr32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicOr32(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicOr32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicOr32", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicOr32Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicOr32Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicOr32Barrier$descriptor() {
        return OSAtomicOr32Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicOr32Barrier$handle() {
        return OSAtomicOr32Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicOr32Barrier$address() {
        return OSAtomicOr32Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicOr32Barrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicOr32Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicOr32Barrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicOr32Orig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicOr32Orig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicOr32Orig$descriptor() {
        return OSAtomicOr32Orig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicOr32Orig$handle() {
        return OSAtomicOr32Orig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicOr32Orig$address() {
        return OSAtomicOr32Orig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicOr32Orig(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicOr32Orig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicOr32Orig", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicOr32OrigBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicOr32OrigBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicOr32OrigBarrier$descriptor() {
        return OSAtomicOr32OrigBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicOr32OrigBarrier$handle() {
        return OSAtomicOr32OrigBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicOr32OrigBarrier$address() {
        return OSAtomicOr32OrigBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicOr32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicOr32OrigBarrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicOr32OrigBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicOr32OrigBarrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAnd32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAnd32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAnd32$descriptor() {
        return OSAtomicAnd32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAnd32$handle() {
        return OSAtomicAnd32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAnd32$address() {
        return OSAtomicAnd32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicAnd32(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicAnd32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAnd32", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAnd32Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAnd32Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAnd32Barrier$descriptor() {
        return OSAtomicAnd32Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAnd32Barrier$handle() {
        return OSAtomicAnd32Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAnd32Barrier$address() {
        return OSAtomicAnd32Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicAnd32Barrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicAnd32Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAnd32Barrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAnd32Orig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAnd32Orig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAnd32Orig$descriptor() {
        return OSAtomicAnd32Orig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAnd32Orig$handle() {
        return OSAtomicAnd32Orig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAnd32Orig$address() {
        return OSAtomicAnd32Orig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicAnd32Orig(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicAnd32Orig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAnd32Orig", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAnd32OrigBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAnd32OrigBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAnd32OrigBarrier$descriptor() {
        return OSAtomicAnd32OrigBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAnd32OrigBarrier$handle() {
        return OSAtomicAnd32OrigBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAnd32OrigBarrier$address() {
        return OSAtomicAnd32OrigBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicAnd32OrigBarrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicAnd32OrigBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAnd32OrigBarrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicXor32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicXor32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicXor32$descriptor() {
        return OSAtomicXor32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicXor32$handle() {
        return OSAtomicXor32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicXor32$address() {
        return OSAtomicXor32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicXor32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicXor32(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicXor32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicXor32", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicXor32Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicXor32Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicXor32Barrier$descriptor() {
        return OSAtomicXor32Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicXor32Barrier$handle() {
        return OSAtomicXor32Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicXor32Barrier$address() {
        return OSAtomicXor32Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicXor32Barrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicXor32Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicXor32Barrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicXor32Orig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicXor32Orig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicXor32Orig$descriptor() {
        return OSAtomicXor32Orig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicXor32Orig$handle() {
        return OSAtomicXor32Orig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicXor32Orig$address() {
        return OSAtomicXor32Orig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicXor32Orig(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicXor32Orig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicXor32Orig", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicXor32OrigBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicXor32OrigBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicXor32OrigBarrier$descriptor() {
        return OSAtomicXor32OrigBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicXor32OrigBarrier$handle() {
        return OSAtomicXor32OrigBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicXor32OrigBarrier$address() {
        return OSAtomicXor32OrigBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicXor32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicXor32OrigBarrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicXor32OrigBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicXor32OrigBarrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwap32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwap32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwap32$descriptor() {
        return OSAtomicCompareAndSwap32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwap32$handle() {
        return OSAtomicCompareAndSwap32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwap32$address() {
        return OSAtomicCompareAndSwap32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwap32(int __oldValue, int __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwap32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwap32", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwap32Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwap32Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32Barrier(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwap32Barrier$descriptor() {
        return OSAtomicCompareAndSwap32Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32Barrier(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwap32Barrier$handle() {
        return OSAtomicCompareAndSwap32Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32Barrier(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwap32Barrier$address() {
        return OSAtomicCompareAndSwap32Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32Barrier(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwap32Barrier(int __oldValue, int __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwap32Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwap32Barrier", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtr(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapPtr$descriptor() {
        return OSAtomicCompareAndSwapPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtr(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapPtr$handle() {
        return OSAtomicCompareAndSwapPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtr(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapPtr$address() {
        return OSAtomicCompareAndSwapPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtr(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapPtr(MemorySegment __oldValue, MemorySegment __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapPtr", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapPtrBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapPtrBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtrBarrier(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapPtrBarrier$descriptor() {
        return OSAtomicCompareAndSwapPtrBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtrBarrier(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapPtrBarrier$handle() {
        return OSAtomicCompareAndSwapPtrBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtrBarrier(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapPtrBarrier$address() {
        return OSAtomicCompareAndSwapPtrBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtrBarrier(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapPtrBarrier(MemorySegment __oldValue, MemorySegment __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapPtrBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapPtrBarrier", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapInt(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapInt$descriptor() {
        return OSAtomicCompareAndSwapInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapInt(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapInt$handle() {
        return OSAtomicCompareAndSwapInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapInt(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapInt$address() {
        return OSAtomicCompareAndSwapInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapInt(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapInt(int __oldValue, int __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapInt", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapIntBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapIntBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapIntBarrier(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapIntBarrier$descriptor() {
        return OSAtomicCompareAndSwapIntBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapIntBarrier(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapIntBarrier$handle() {
        return OSAtomicCompareAndSwapIntBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapIntBarrier(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapIntBarrier$address() {
        return OSAtomicCompareAndSwapIntBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapIntBarrier(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapIntBarrier(int __oldValue, int __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapIntBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapIntBarrier", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLong(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapLong$descriptor() {
        return OSAtomicCompareAndSwapLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLong(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapLong$handle() {
        return OSAtomicCompareAndSwapLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLong(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapLong$address() {
        return OSAtomicCompareAndSwapLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLong(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapLong(long __oldValue, long __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapLong", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapLongBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapLongBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLongBarrier(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapLongBarrier$descriptor() {
        return OSAtomicCompareAndSwapLongBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLongBarrier(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapLongBarrier$handle() {
        return OSAtomicCompareAndSwapLongBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLongBarrier(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapLongBarrier$address() {
        return OSAtomicCompareAndSwapLongBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLongBarrier(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapLongBarrier(long __oldValue, long __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapLongBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapLongBarrier", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwap64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwap64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwap64$descriptor() {
        return OSAtomicCompareAndSwap64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwap64$handle() {
        return OSAtomicCompareAndSwap64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwap64$address() {
        return OSAtomicCompareAndSwap64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwap64(long __oldValue, long __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwap64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwap64", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwap64Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwap64Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64Barrier(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwap64Barrier$descriptor() {
        return OSAtomicCompareAndSwap64Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64Barrier(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwap64Barrier$handle() {
        return OSAtomicCompareAndSwap64Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64Barrier(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwap64Barrier$address() {
        return OSAtomicCompareAndSwap64Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64Barrier(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwap64Barrier(long __oldValue, long __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwap64Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwap64Barrier", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicTestAndSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicTestAndSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSet(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static FunctionDescriptor OSAtomicTestAndSet$descriptor() {
        return OSAtomicTestAndSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSet(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MethodHandle OSAtomicTestAndSet$handle() {
        return OSAtomicTestAndSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSet(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MemorySegment OSAtomicTestAndSet$address() {
        return OSAtomicTestAndSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicTestAndSet(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static boolean OSAtomicTestAndSet(int __n, MemorySegment __theAddress) {
        var mh$ = OSAtomicTestAndSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicTestAndSet", __n, __theAddress);
            }
            return (boolean)mh$.invokeExact(__n, __theAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicTestAndSetBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicTestAndSetBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSetBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static FunctionDescriptor OSAtomicTestAndSetBarrier$descriptor() {
        return OSAtomicTestAndSetBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSetBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MethodHandle OSAtomicTestAndSetBarrier$handle() {
        return OSAtomicTestAndSetBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSetBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MemorySegment OSAtomicTestAndSetBarrier$address() {
        return OSAtomicTestAndSetBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicTestAndSetBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static boolean OSAtomicTestAndSetBarrier(int __n, MemorySegment __theAddress) {
        var mh$ = OSAtomicTestAndSetBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicTestAndSetBarrier", __n, __theAddress);
            }
            return (boolean)mh$.invokeExact(__n, __theAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicTestAndClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicTestAndClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClear(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static FunctionDescriptor OSAtomicTestAndClear$descriptor() {
        return OSAtomicTestAndClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClear(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MethodHandle OSAtomicTestAndClear$handle() {
        return OSAtomicTestAndClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClear(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MemorySegment OSAtomicTestAndClear$address() {
        return OSAtomicTestAndClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicTestAndClear(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static boolean OSAtomicTestAndClear(int __n, MemorySegment __theAddress) {
        var mh$ = OSAtomicTestAndClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicTestAndClear", __n, __theAddress);
            }
            return (boolean)mh$.invokeExact(__n, __theAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicTestAndClearBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicTestAndClearBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClearBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static FunctionDescriptor OSAtomicTestAndClearBarrier$descriptor() {
        return OSAtomicTestAndClearBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClearBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MethodHandle OSAtomicTestAndClearBarrier$handle() {
        return OSAtomicTestAndClearBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClearBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MemorySegment OSAtomicTestAndClearBarrier$address() {
        return OSAtomicTestAndClearBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicTestAndClearBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static boolean OSAtomicTestAndClearBarrier(int __n, MemorySegment __theAddress) {
        var mh$ = OSAtomicTestAndClearBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicTestAndClearBarrier", __n, __theAddress);
            }
            return (boolean)mh$.invokeExact(__n, __theAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSMemoryBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSMemoryBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OSMemoryBarrier()
     * }
     */
    public static FunctionDescriptor OSMemoryBarrier$descriptor() {
        return OSMemoryBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OSMemoryBarrier()
     * }
     */
    public static MethodHandle OSMemoryBarrier$handle() {
        return OSMemoryBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OSMemoryBarrier()
     * }
     */
    public static MemorySegment OSMemoryBarrier$address() {
        return OSMemoryBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OSMemoryBarrier()
     * }
     */
    public static void OSMemoryBarrier() {
        var mh$ = OSMemoryBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSMemoryBarrier");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int32_t OSSpinLock
     * }
     */
    public static final OfInt OSSpinLock = ObjCRuntime.C_INT;

    private static class OSSpinLockTry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSSpinLockTry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSSpinLockTry(volatile OSSpinLock *__lock)
     * }
     */
    public static FunctionDescriptor OSSpinLockTry$descriptor() {
        return OSSpinLockTry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSSpinLockTry(volatile OSSpinLock *__lock)
     * }
     */
    public static MethodHandle OSSpinLockTry$handle() {
        return OSSpinLockTry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSSpinLockTry(volatile OSSpinLock *__lock)
     * }
     */
    public static MemorySegment OSSpinLockTry$address() {
        return OSSpinLockTry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSSpinLockTry(volatile OSSpinLock *__lock)
     * }
     */
    public static boolean OSSpinLockTry(MemorySegment __lock) {
        var mh$ = OSSpinLockTry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSSpinLockTry", __lock);
            }
            return (boolean)mh$.invokeExact(__lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSSpinLockLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSSpinLockLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OSSpinLockLock(volatile OSSpinLock *__lock)
     * }
     */
    public static FunctionDescriptor OSSpinLockLock$descriptor() {
        return OSSpinLockLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OSSpinLockLock(volatile OSSpinLock *__lock)
     * }
     */
    public static MethodHandle OSSpinLockLock$handle() {
        return OSSpinLockLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OSSpinLockLock(volatile OSSpinLock *__lock)
     * }
     */
    public static MemorySegment OSSpinLockLock$address() {
        return OSSpinLockLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OSSpinLockLock(volatile OSSpinLock *__lock)
     * }
     */
    public static void OSSpinLockLock(MemorySegment __lock) {
        var mh$ = OSSpinLockLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSSpinLockLock", __lock);
            }
            mh$.invokeExact(__lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSSpinLockUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSSpinLockUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OSSpinLockUnlock(volatile OSSpinLock *__lock)
     * }
     */
    public static FunctionDescriptor OSSpinLockUnlock$descriptor() {
        return OSSpinLockUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OSSpinLockUnlock(volatile OSSpinLock *__lock)
     * }
     */
    public static MethodHandle OSSpinLockUnlock$handle() {
        return OSSpinLockUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OSSpinLockUnlock(volatile OSSpinLock *__lock)
     * }
     */
    public static MemorySegment OSSpinLockUnlock$address() {
        return OSSpinLockUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OSSpinLockUnlock(volatile OSSpinLock *__lock)
     * }
     */
    public static void OSSpinLockUnlock(MemorySegment __lock) {
        var mh$ = OSSpinLockUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSSpinLockUnlock", __lock);
            }
            mh$.invokeExact(__lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicEnqueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicEnqueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OSAtomicEnqueue(OSQueueHead *__list, void *__new, size_t __offset)
     * }
     */
    public static FunctionDescriptor OSAtomicEnqueue$descriptor() {
        return OSAtomicEnqueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OSAtomicEnqueue(OSQueueHead *__list, void *__new, size_t __offset)
     * }
     */
    public static MethodHandle OSAtomicEnqueue$handle() {
        return OSAtomicEnqueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OSAtomicEnqueue(OSQueueHead *__list, void *__new, size_t __offset)
     * }
     */
    public static MemorySegment OSAtomicEnqueue$address() {
        return OSAtomicEnqueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OSAtomicEnqueue(OSQueueHead *__list, void *__new, size_t __offset)
     * }
     */
    public static void OSAtomicEnqueue(MemorySegment __list, MemorySegment __new, long __offset) {
        var mh$ = OSAtomicEnqueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicEnqueue", __list, __new, __offset);
            }
            mh$.invokeExact(__list, __new, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicDequeue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicDequeue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *OSAtomicDequeue(OSQueueHead *__list, size_t __offset)
     * }
     */
    public static FunctionDescriptor OSAtomicDequeue$descriptor() {
        return OSAtomicDequeue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *OSAtomicDequeue(OSQueueHead *__list, size_t __offset)
     * }
     */
    public static MethodHandle OSAtomicDequeue$handle() {
        return OSAtomicDequeue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *OSAtomicDequeue(OSQueueHead *__list, size_t __offset)
     * }
     */
    public static MemorySegment OSAtomicDequeue$address() {
        return OSAtomicDequeue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *OSAtomicDequeue(OSQueueHead *__list, size_t __offset)
     * }
     */
    public static MemorySegment OSAtomicDequeue(MemorySegment __list, long __offset) {
        var mh$ = OSAtomicDequeue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicDequeue", __list, __offset);
            }
            return (MemorySegment)mh$.invokeExact(__list, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int boolean_t
     * }
     */
    public static final OfInt boolean_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int kern_return_t
     * }
     */
    public static final OfInt kern_return_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t natural_t
     * }
     */
    public static final OfInt natural_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int integer_t
     * }
     */
    public static final OfInt integer_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t vm_offset_t
     * }
     */
    public static final OfLong vm_offset_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t vm_size_t
     * }
     */
    public static final OfLong vm_size_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_address_t
     * }
     */
    public static final OfLong mach_vm_address_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_offset_t
     * }
     */
    public static final OfLong mach_vm_offset_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_size_t
     * }
     */
    public static final OfLong mach_vm_size_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_offset_t
     * }
     */
    public static final OfLong vm_map_offset_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_address_t
     * }
     */
    public static final OfLong vm_map_address_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_size_t
     * }
     */
    public static final OfLong vm_map_size_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_offset_t
     * }
     */
    public static final OfInt vm32_offset_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_address_t
     * }
     */
    public static final OfInt vm32_address_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_size_t
     * }
     */
    public static final OfInt vm32_size_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef vm_offset_t mach_port_context_t
     * }
     */
    public static final OfLong mach_port_context_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_name_t
     * }
     */
    public static final OfInt mach_port_name_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_name_t *mach_port_name_array_t
     * }
     */
    public static final AddressLayout mach_port_name_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_t mach_port_t
     * }
     */
    public static final OfInt mach_port_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t *mach_port_array_t
     * }
     */
    public static final AddressLayout mach_port_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_right_t
     * }
     */
    public static final OfInt mach_port_right_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_type_t
     * }
     */
    public static final OfInt mach_port_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_type_t *mach_port_type_array_t
     * }
     */
    public static final AddressLayout mach_port_type_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_urefs_t
     * }
     */
    public static final OfInt mach_port_urefs_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_port_delta_t
     * }
     */
    public static final OfInt mach_port_delta_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_seqno_t
     * }
     */
    public static final OfInt mach_port_seqno_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_mscount_t
     * }
     */
    public static final OfInt mach_port_mscount_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_msgcount_t
     * }
     */
    public static final OfInt mach_port_msgcount_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_rights_t
     * }
     */
    public static final OfInt mach_port_rights_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_port_srights_t
     * }
     */
    public static final OfInt mach_port_srights_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *mach_port_info_t
     * }
     */
    public static final AddressLayout mach_port_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int mach_port_flavor_t
     * }
     */
    public static final OfInt mach_port_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct mach_service_port_info {
     *     char mspi_string_name[255];
     *     uint8_t mspi_domain_type;
     * } *mach_service_port_info_t
     * }
     */
    public static final AddressLayout mach_service_port_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_port_options_t *mach_port_options_ptr_t
     * }
     */
    public static final AddressLayout mach_port_options_ptr_t = ObjCRuntime.C_POINTER;
    private static final int kGUARD_EXC_DESTROY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_DESTROY = 1
     * }
     */
    public static int kGUARD_EXC_DESTROY() {
        return kGUARD_EXC_DESTROY;
    }
    private static final int kGUARD_EXC_MOD_REFS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS = 2
     * }
     */
    public static int kGUARD_EXC_MOD_REFS() {
        return kGUARD_EXC_MOD_REFS;
    }
    private static final int kGUARD_EXC_INVALID_OPTIONS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_OPTIONS = 3
     * }
     */
    public static int kGUARD_EXC_INVALID_OPTIONS() {
        return kGUARD_EXC_INVALID_OPTIONS;
    }
    private static final int kGUARD_EXC_SET_CONTEXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SET_CONTEXT = 4
     * }
     */
    public static int kGUARD_EXC_SET_CONTEXT() {
        return kGUARD_EXC_SET_CONTEXT;
    }
    private static final int kGUARD_EXC_THREAD_SET_STATE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_THREAD_SET_STATE = 5
     * }
     */
    public static int kGUARD_EXC_THREAD_SET_STATE() {
        return kGUARD_EXC_THREAD_SET_STATE;
    }
    private static final int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = 6
     * }
     */
    public static int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE() {
        return kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE;
    }
    private static final int kGUARD_EXC_UNGUARDED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_UNGUARDED = 8
     * }
     */
    public static int kGUARD_EXC_UNGUARDED() {
        return kGUARD_EXC_UNGUARDED;
    }
    private static final int kGUARD_EXC_INCORRECT_GUARD = (int)16L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INCORRECT_GUARD = 16
     * }
     */
    public static int kGUARD_EXC_INCORRECT_GUARD() {
        return kGUARD_EXC_INCORRECT_GUARD;
    }
    private static final int kGUARD_EXC_IMMOVABLE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE = 32
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE() {
        return kGUARD_EXC_IMMOVABLE;
    }
    private static final int kGUARD_EXC_STRICT_REPLY = (int)64L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_STRICT_REPLY = 64
     * }
     */
    public static int kGUARD_EXC_STRICT_REPLY() {
        return kGUARD_EXC_STRICT_REPLY;
    }
    private static final int kGUARD_EXC_MSG_FILTERED = (int)128L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MSG_FILTERED = 128
     * }
     */
    public static int kGUARD_EXC_MSG_FILTERED() {
        return kGUARD_EXC_MSG_FILTERED;
    }
    private static final int kGUARD_EXC_INVALID_RIGHT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_RIGHT = 256
     * }
     */
    public static int kGUARD_EXC_INVALID_RIGHT() {
        return kGUARD_EXC_INVALID_RIGHT;
    }
    private static final int kGUARD_EXC_INVALID_NAME = (int)512L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_NAME = 512
     * }
     */
    public static int kGUARD_EXC_INVALID_NAME() {
        return kGUARD_EXC_INVALID_NAME;
    }
    private static final int kGUARD_EXC_INVALID_VALUE = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_VALUE = 1024
     * }
     */
    public static int kGUARD_EXC_INVALID_VALUE() {
        return kGUARD_EXC_INVALID_VALUE;
    }
    private static final int kGUARD_EXC_INVALID_ARGUMENT = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_ARGUMENT = 2048
     * }
     */
    public static int kGUARD_EXC_INVALID_ARGUMENT() {
        return kGUARD_EXC_INVALID_ARGUMENT;
    }
    private static final int kGUARD_EXC_RIGHT_EXISTS = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RIGHT_EXISTS = 4096
     * }
     */
    public static int kGUARD_EXC_RIGHT_EXISTS() {
        return kGUARD_EXC_RIGHT_EXISTS;
    }
    private static final int kGUARD_EXC_KERN_NO_SPACE = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_NO_SPACE = 8192
     * }
     */
    public static int kGUARD_EXC_KERN_NO_SPACE() {
        return kGUARD_EXC_KERN_NO_SPACE;
    }
    private static final int kGUARD_EXC_KERN_FAILURE = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_FAILURE = 16384
     * }
     */
    public static int kGUARD_EXC_KERN_FAILURE() {
        return kGUARD_EXC_KERN_FAILURE;
    }
    private static final int kGUARD_EXC_KERN_RESOURCE = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_RESOURCE = 32768
     * }
     */
    public static int kGUARD_EXC_KERN_RESOURCE() {
        return kGUARD_EXC_KERN_RESOURCE;
    }
    private static final int kGUARD_EXC_SEND_INVALID_REPLY = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_REPLY = 65536
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_REPLY() {
        return kGUARD_EXC_SEND_INVALID_REPLY;
    }
    private static final int kGUARD_EXC_SEND_INVALID_VOUCHER = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_VOUCHER = 131072
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_VOUCHER() {
        return kGUARD_EXC_SEND_INVALID_VOUCHER;
    }
    private static final int kGUARD_EXC_SEND_INVALID_RIGHT = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_RIGHT = 262144
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_RIGHT() {
        return kGUARD_EXC_SEND_INVALID_RIGHT;
    }
    private static final int kGUARD_EXC_RCV_INVALID_NAME = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_INVALID_NAME = 524288
     * }
     */
    public static int kGUARD_EXC_RCV_INVALID_NAME() {
        return kGUARD_EXC_RCV_INVALID_NAME;
    }
    private static final int kGUARD_EXC_RCV_GUARDED_DESC = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_GUARDED_DESC = 1048576
     * }
     */
    public static int kGUARD_EXC_RCV_GUARDED_DESC() {
        return kGUARD_EXC_RCV_GUARDED_DESC;
    }
    private static final int kGUARD_EXC_MOD_REFS_NON_FATAL = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS_NON_FATAL = 2097152
     * }
     */
    public static int kGUARD_EXC_MOD_REFS_NON_FATAL() {
        return kGUARD_EXC_MOD_REFS_NON_FATAL;
    }
    private static final int kGUARD_EXC_IMMOVABLE_NON_FATAL = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE_NON_FATAL = 4194304
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE_NON_FATAL() {
        return kGUARD_EXC_IMMOVABLE_NON_FATAL;
    }
    private static final int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = 8388608
     * }
     */
    public static int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS() {
        return kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS;
    }
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_timeout_t
     * }
     */
    public static final OfInt mach_msg_timeout_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_bits_t
     * }
     */
    public static final OfInt mach_msg_bits_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_size_t
     * }
     */
    public static final OfInt mach_msg_size_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_id_t
     * }
     */
    public static final OfInt mach_msg_id_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_priority_t
     * }
     */
    public static final OfInt mach_msg_priority_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_type_name_t
     * }
     */
    public static final OfInt mach_msg_type_name_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_copy_options_t
     * }
     */
    public static final OfInt mach_msg_copy_options_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_guard_flags_t
     * }
     */
    public static final OfInt mach_msg_guard_flags_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_descriptor_type_t
     * }
     */
    public static final OfInt mach_msg_descriptor_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_trailer_type_t
     * }
     */
    public static final OfInt mach_msg_trailer_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_trailer_size_t
     * }
     */
    public static final OfInt mach_msg_trailer_size_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char *mach_msg_trailer_info_t
     * }
     */
    public static final AddressLayout mach_msg_trailer_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int mach_msg_filter_id
     * }
     */
    public static final OfInt mach_msg_filter_id = ObjCRuntime.C_INT;

    private static class KERNEL_SECURITY_TOKEN$constants {
        public static final GroupLayout LAYOUT = security_token_t.layout();
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("KERNEL_SECURITY_TOKEN").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static GroupLayout KERNEL_SECURITY_TOKEN$layout() {
        return KERNEL_SECURITY_TOKEN$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static MemorySegment KERNEL_SECURITY_TOKEN() {
        return KERNEL_SECURITY_TOKEN$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static void KERNEL_SECURITY_TOKEN(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, KERNEL_SECURITY_TOKEN$constants.SEGMENT, 0L, KERNEL_SECURITY_TOKEN$constants.LAYOUT.byteSize());
    }

    private static class KERNEL_AUDIT_TOKEN$constants {
        public static final GroupLayout LAYOUT = audit_token_t.layout();
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("KERNEL_AUDIT_TOKEN").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static GroupLayout KERNEL_AUDIT_TOKEN$layout() {
        return KERNEL_AUDIT_TOKEN$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static MemorySegment KERNEL_AUDIT_TOKEN() {
        return KERNEL_AUDIT_TOKEN$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static void KERNEL_AUDIT_TOKEN(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, KERNEL_AUDIT_TOKEN$constants.SEGMENT, 0L, KERNEL_AUDIT_TOKEN$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_options_t
     * }
     */
    public static final OfInt mach_msg_options_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_type_size_t
     * }
     */
    public static final OfInt mach_msg_type_size_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_type_number_t
     * }
     */
    public static final OfInt mach_msg_type_number_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_option_t
     * }
     */
    public static final OfInt mach_msg_option_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef kern_return_t mach_msg_return_t
     * }
     */
    public static final OfInt mach_msg_return_t = ObjCRuntime.C_INT;

    private static class mach_msg_overwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mach_msg_overwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static FunctionDescriptor mach_msg_overwrite$descriptor() {
        return mach_msg_overwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static MethodHandle mach_msg_overwrite$handle() {
        return mach_msg_overwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static MemorySegment mach_msg_overwrite$address() {
        return mach_msg_overwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static int mach_msg_overwrite(MemorySegment msg, int option, int send_size, int rcv_size, int rcv_name, int timeout, int notify, MemorySegment rcv_msg, int rcv_limit) {
        var mh$ = mach_msg_overwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mach_msg_overwrite", msg, option, send_size, rcv_size, rcv_name, timeout, notify, rcv_msg, rcv_limit);
            }
            return (int)mh$.invokeExact(msg, option, send_size, rcv_size, rcv_name, timeout, notify, rcv_msg, rcv_limit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mach_msg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mach_msg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static FunctionDescriptor mach_msg$descriptor() {
        return mach_msg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static MethodHandle mach_msg$handle() {
        return mach_msg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static MemorySegment mach_msg$address() {
        return mach_msg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static int mach_msg(MemorySegment msg, int option, int send_size, int rcv_size, int rcv_name, int timeout, int notify) {
        var mh$ = mach_msg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mach_msg", msg, option, send_size, rcv_size, rcv_name, timeout, notify);
            }
            return (int)mh$.invokeExact(msg, option, send_size, rcv_size, rcv_name, timeout, notify);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mach_voucher_deallocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mach_voucher_deallocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static FunctionDescriptor mach_voucher_deallocate$descriptor() {
        return mach_voucher_deallocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static MethodHandle mach_voucher_deallocate$handle() {
        return mach_voucher_deallocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static MemorySegment mach_voucher_deallocate$address() {
        return mach_voucher_deallocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static int mach_voucher_deallocate(int voucher) {
        var mh$ = mach_voucher_deallocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mach_voucher_deallocate", voucher);
            }
            return (int)mh$.invokeExact(voucher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct vm_statistics {
     *     natural_t free_count;
     *     natural_t active_count;
     *     natural_t inactive_count;
     *     natural_t wire_count;
     *     natural_t zero_fill_count;
     *     natural_t reactivations;
     *     natural_t pageins;
     *     natural_t pageouts;
     *     natural_t faults;
     *     natural_t cow_faults;
     *     natural_t lookups;
     *     natural_t hits;
     *     natural_t purgeable_count;
     *     natural_t purges;
     *     natural_t speculative_count;
     * } *vm_statistics_t
     * }
     */
    public static final AddressLayout vm_statistics_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vm_statistics64 {
     *     natural_t free_count;
     *     natural_t active_count;
     *     natural_t inactive_count;
     *     natural_t wire_count;
     *     uint64_t zero_fill_count;
     *     uint64_t reactivations;
     *     uint64_t pageins;
     *     uint64_t pageouts;
     *     uint64_t faults;
     *     uint64_t cow_faults;
     *     uint64_t lookups;
     *     uint64_t hits;
     *     uint64_t purges;
     *     natural_t purgeable_count;
     *     natural_t speculative_count;
     *     uint64_t decompressions;
     *     uint64_t compressions;
     *     uint64_t swapins;
     *     uint64_t swapouts;
     *     natural_t compressor_page_count;
     *     natural_t throttled_count;
     *     natural_t external_page_count;
     *     natural_t internal_page_count;
     *     uint64_t total_uncompressed_pages_in_compressor;
     * } *vm_statistics64_t
     * }
     */
    public static final AddressLayout vm_statistics64_t = ObjCRuntime.C_POINTER;

    private static class vm_stats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("vm_stats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * kern_return_t vm_stats(void *info, unsigned int *count)
     * }
     */
    public static FunctionDescriptor vm_stats$descriptor() {
        return vm_stats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * kern_return_t vm_stats(void *info, unsigned int *count)
     * }
     */
    public static MethodHandle vm_stats$handle() {
        return vm_stats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * kern_return_t vm_stats(void *info, unsigned int *count)
     * }
     */
    public static MemorySegment vm_stats$address() {
        return vm_stats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * kern_return_t vm_stats(void *info, unsigned int *count)
     * }
     */
    public static int vm_stats(MemorySegment info, MemorySegment count) {
        var mh$ = vm_stats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vm_stats", info, count);
            }
            return (int)mh$.invokeExact(info, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct vm_extmod_statistics {
     *     int64_t task_for_pid_count;
     *     int64_t task_for_pid_caller_count;
     *     int64_t thread_creation_count;
     *     int64_t thread_creation_caller_count;
     *     int64_t thread_set_state_count;
     *     int64_t thread_set_state_caller_count;
     * } *vm_extmod_statistics_t
     * }
     */
    public static final AddressLayout vm_extmod_statistics_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vm_purgeable_info {
     *     vm_purgeable_stat_t fifo_data[8];
     *     vm_purgeable_stat_t obsolete_data;
     *     vm_purgeable_stat_t lifo_data[8];
     * } *vm_purgeable_info_t
     * }
     */
    public static final AddressLayout vm_purgeable_info_t = ObjCRuntime.C_POINTER;
    private static final int kGUARD_EXC_DEALLOC_GAP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum virtual_memory_guard_exception_codes.kGUARD_EXC_DEALLOC_GAP = 1
     * }
     */
    public static int kGUARD_EXC_DEALLOC_GAP() {
        return kGUARD_EXC_DEALLOC_GAP;
    }
    private static final int kGUARD_EXC_RECLAIM_COPYIO_FAILURE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum virtual_memory_guard_exception_codes.kGUARD_EXC_RECLAIM_COPYIO_FAILURE = 2
     * }
     */
    public static int kGUARD_EXC_RECLAIM_COPYIO_FAILURE() {
        return kGUARD_EXC_RECLAIM_COPYIO_FAILURE;
    }
    private static final int kGUARD_EXC_RECLAIM_INDEX_FAILURE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum virtual_memory_guard_exception_codes.kGUARD_EXC_RECLAIM_INDEX_FAILURE = 4
     * }
     */
    public static int kGUARD_EXC_RECLAIM_INDEX_FAILURE() {
        return kGUARD_EXC_RECLAIM_INDEX_FAILURE;
    }
    private static final int kGUARD_EXC_RECLAIM_DEALLOCATE_FAILURE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum virtual_memory_guard_exception_codes.kGUARD_EXC_RECLAIM_DEALLOCATE_FAILURE = 8
     * }
     */
    public static int kGUARD_EXC_RECLAIM_DEALLOCATE_FAILURE() {
        return kGUARD_EXC_RECLAIM_DEALLOCATE_FAILURE;
    }
    /**
     * {@snippet lang=c :
     * typedef integer_t *host_info_t
     * }
     */
    public static final AddressLayout host_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *host_info64_t
     * }
     */
    public static final AddressLayout host_info64_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t host_flavor_t
     * }
     */
    public static final OfInt host_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct host_can_has_debugger_info {
     *     boolean_t can_has_debugger;
     * } *host_can_has_debugger_info_t
     * }
     */
    public static final AddressLayout host_can_has_debugger_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct host_basic_info {
     *     integer_t max_cpus;
     *     integer_t avail_cpus;
     *     natural_t memory_size;
     *     cpu_type_t cpu_type;
     *     cpu_subtype_t cpu_subtype;
     *     cpu_threadtype_t cpu_threadtype;
     *     integer_t physical_cpu;
     *     integer_t physical_cpu_max;
     *     integer_t logical_cpu;
     *     integer_t logical_cpu_max;
     *     uint64_t max_mem;
     * } *host_basic_info_t
     * }
     */
    public static final AddressLayout host_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct host_sched_info {
     *     integer_t min_timeout;
     *     integer_t min_quantum;
     * } *host_sched_info_t
     * }
     */
    public static final AddressLayout host_sched_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct kernel_resource_sizes {
     *     natural_t task;
     *     natural_t thread;
     *     natural_t port;
     *     natural_t memory_region;
     *     natural_t memory_object;
     * } *kernel_resource_sizes_t
     * }
     */
    public static final AddressLayout kernel_resource_sizes_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct host_priority_info {
     *     integer_t kernel_priority;
     *     integer_t system_priority;
     *     integer_t server_priority;
     *     integer_t user_priority;
     *     integer_t depress_priority;
     *     integer_t idle_priority;
     *     integer_t minimum_priority;
     *     integer_t maximum_priority;
     * } *host_priority_info_t
     * }
     */
    public static final AddressLayout host_priority_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct host_load_info {
     *     integer_t avenrun[3];
     *     integer_t mach_factor[3];
     * } *host_load_info_t
     * }
     */
    public static final AddressLayout host_load_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vm_purgeable_info {
     *     vm_purgeable_stat_t fifo_data[8];
     *     vm_purgeable_stat_t obsolete_data;
     *     vm_purgeable_stat_t lifo_data[8];
     * } *host_purgable_info_t
     * }
     */
    public static final AddressLayout host_purgable_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct host_cpu_load_info {
     *     natural_t cpu_ticks[4];
     * } *host_cpu_load_info_t
     * }
     */
    public static final AddressLayout host_cpu_load_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct host_preferred_user_arch {
     *     cpu_type_t cpu_type;
     *     cpu_subtype_t cpu_subtype;
     * } *host_preferred_user_arch_t
     * }
     */
    public static final AddressLayout host_preferred_user_arch_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int vm_prot_t
     * }
     */
    public static final OfInt vm_prot_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int vm_sync_t
     * }
     */
    public static final OfInt vm_sync_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef vm_offset_t pointer_t
     * }
     */
    public static final OfLong pointer_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef vm_offset_t vm_address_t
     * }
     */
    public static final OfLong vm_address_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t addr64_t
     * }
     */
    public static final OfLong addr64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint32_t reg64_t
     * }
     */
    public static final OfInt reg64_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t ppnum_t
     * }
     */
    public static final OfInt ppnum_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t vm_map_t
     * }
     */
    public static final OfInt vm_map_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t vm_map_read_t
     * }
     */
    public static final OfInt vm_map_read_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t vm_map_inspect_t
     * }
     */
    public static final OfInt vm_map_inspect_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t upl_t
     * }
     */
    public static final OfInt upl_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t vm_named_entry_t
     * }
     */
    public static final OfInt vm_named_entry_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_object_offset_t
     * }
     */
    public static final OfLong vm_object_offset_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_object_size_t
     * }
     */
    public static final OfLong vm_object_size_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct mach_vm_range {
     *     mach_vm_offset_t min_address;
     *     mach_vm_offset_t max_address;
     * } *mach_vm_range_t
     * }
     */
    public static final AddressLayout mach_vm_range_t = ObjCRuntime.C_POINTER;
    private static final int MACH_VM_RANGE_FLAVOR_INVALID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_FLAVOR_INVALID = 0
     * }
     */
    public static int MACH_VM_RANGE_FLAVOR_INVALID() {
        return MACH_VM_RANGE_FLAVOR_INVALID;
    }
    private static final int MACH_VM_RANGE_FLAVOR_V1 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_FLAVOR_V1 = 1
     * }
     */
    public static int MACH_VM_RANGE_FLAVOR_V1() {
        return MACH_VM_RANGE_FLAVOR_V1;
    }
    private static final long MACH_VM_RANGE_NONE = 0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_NONE = 0
     * }
     */
    public static long MACH_VM_RANGE_NONE() {
        return MACH_VM_RANGE_NONE;
    }
    private static final short MACH_VM_RANGE_DEFAULT = (short)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_DEFAULT = 0
     * }
     */
    public static short MACH_VM_RANGE_DEFAULT() {
        return MACH_VM_RANGE_DEFAULT;
    }
    private static final short MACH_VM_RANGE_DATA = (short)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_DATA = 1
     * }
     */
    public static short MACH_VM_RANGE_DATA() {
        return MACH_VM_RANGE_DATA;
    }
    private static final short MACH_VM_RANGE_FIXED = (short)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_FIXED = 2
     * }
     */
    public static short MACH_VM_RANGE_FIXED() {
        return MACH_VM_RANGE_FIXED;
    }
    /**
     * {@snippet lang=c :
     * typedef uint8_t *mach_vm_range_recipes_raw_t
     * }
     */
    public static final AddressLayout mach_vm_range_recipes_raw_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long memory_object_offset_t
     * }
     */
    public static final OfLong memory_object_offset_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long memory_object_size_t
     * }
     */
    public static final OfLong memory_object_size_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef natural_t memory_object_cluster_size_t
     * }
     */
    public static final OfInt memory_object_cluster_size_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t *memory_object_fault_info_t
     * }
     */
    public static final AddressLayout memory_object_fault_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long vm_object_id_t
     * }
     */
    public static final OfLong vm_object_id_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t memory_object_t
     * }
     */
    public static final OfInt memory_object_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t memory_object_control_t
     * }
     */
    public static final OfInt memory_object_control_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef memory_object_t *memory_object_array_t
     * }
     */
    public static final AddressLayout memory_object_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t memory_object_name_t
     * }
     */
    public static final OfInt memory_object_name_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t memory_object_default_t
     * }
     */
    public static final OfInt memory_object_default_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int memory_object_copy_strategy_t
     * }
     */
    public static final OfInt memory_object_copy_strategy_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int memory_object_return_t
     * }
     */
    public static final OfInt memory_object_return_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int *memory_object_info_t
     * }
     */
    public static final AddressLayout memory_object_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int memory_object_flavor_t
     * }
     */
    public static final OfInt memory_object_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct memory_object_behave_info {
     *     memory_object_copy_strategy_t copy_strategy;
     *     boolean_t temporary;
     *     boolean_t invalidate;
     *     boolean_t silent_overwrite;
     *     boolean_t advisory_pageout;
     * } *memory_object_behave_info_t
     * }
     */
    public static final AddressLayout memory_object_behave_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct memory_object_perf_info {
     *     memory_object_cluster_size_t cluster_size;
     *     boolean_t may_cache;
     * } *memory_object_perf_info_t
     * }
     */
    public static final AddressLayout memory_object_perf_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct memory_object_attr_info {
     *     memory_object_copy_strategy_t copy_strategy;
     *     memory_object_cluster_size_t cluster_size;
     *     boolean_t may_cache_object;
     *     boolean_t temporary;
     * } *memory_object_attr_info_t
     * }
     */
    public static final AddressLayout memory_object_attr_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t *thread_state_t
     * }
     */
    public static final AddressLayout thread_state_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int thread_state_flavor_t
     * }
     */
    public static final OfInt thread_state_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef thread_state_flavor_t *thread_state_flavor_array_t
     * }
     */
    public static final AddressLayout thread_state_flavor_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int exception_type_t
     * }
     */
    public static final OfInt exception_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t exception_data_type_t
     * }
     */
    public static final OfInt exception_data_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t mach_exception_data_type_t
     * }
     */
    public static final OfLong mach_exception_data_type_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int exception_behavior_t
     * }
     */
    public static final OfInt exception_behavior_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef exception_data_type_t *exception_data_t
     * }
     */
    public static final AddressLayout exception_data_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_exception_data_type_t *mach_exception_data_t
     * }
     */
    public static final AddressLayout mach_exception_data_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned int exception_mask_t
     * }
     */
    public static final OfInt exception_mask_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef exception_mask_t *exception_mask_array_t
     * }
     */
    public static final AddressLayout exception_mask_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef exception_behavior_t *exception_behavior_array_t
     * }
     */
    public static final AddressLayout exception_behavior_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef thread_state_flavor_t *exception_flavor_array_t
     * }
     */
    public static final AddressLayout exception_flavor_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t *exception_port_array_t
     * }
     */
    public static final AddressLayout exception_port_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ipc_info_port_t *exception_port_info_array_t
     * }
     */
    public static final AddressLayout exception_port_info_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_exception_data_type_t mach_exception_code_t
     * }
     */
    public static final OfLong mach_exception_code_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef mach_exception_data_type_t mach_exception_subcode_t
     * }
     */
    public static final OfLong mach_exception_subcode_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct processor_cpu_stat {
     *     uint32_t irq_ex_cnt;
     *     uint32_t ipi_cnt;
     *     uint32_t timer_cnt;
     *     uint32_t undef_ex_cnt;
     *     uint32_t unaligned_cnt;
     *     uint32_t vfp_cnt;
     *     uint32_t vfp_shortv_cnt;
     *     uint32_t data_ex_cnt;
     *     uint32_t instr_ex_cnt;
     * } *processor_cpu_stat_t
     * }
     */
    public static final AddressLayout processor_cpu_stat_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct processor_cpu_stat64 {
     *     uint64_t irq_ex_cnt;
     *     uint64_t ipi_cnt;
     *     uint64_t timer_cnt;
     *     uint64_t undef_ex_cnt;
     *     uint64_t unaligned_cnt;
     *     uint64_t vfp_cnt;
     *     uint64_t vfp_shortv_cnt;
     *     uint64_t data_ex_cnt;
     *     uint64_t instr_ex_cnt;
     *     uint64_t pmi_cnt;
     * } *processor_cpu_stat64_t
     * }
     */
    public static final AddressLayout processor_cpu_stat64_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *processor_info_t
     * }
     */
    public static final AddressLayout processor_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *processor_info_array_t
     * }
     */
    public static final AddressLayout processor_info_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *processor_set_info_t
     * }
     */
    public static final AddressLayout processor_set_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int processor_flavor_t
     * }
     */
    public static final OfInt processor_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct processor_basic_info {
     *     cpu_type_t cpu_type;
     *     cpu_subtype_t cpu_subtype;
     *     boolean_t running;
     *     int slot_num;
     *     union {
     *         boolean_t is_master;
     *         boolean_t is_main;
     *     };
     * } *processor_basic_info_t
     * }
     */
    public static final AddressLayout processor_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct processor_cpu_load_info {
     *     unsigned int cpu_ticks[4];
     * } *processor_cpu_load_info_t
     * }
     */
    public static final AddressLayout processor_cpu_load_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int processor_set_flavor_t
     * }
     */
    public static final OfInt processor_set_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct processor_set_basic_info {
     *     int processor_count;
     *     int default_policy;
     * } *processor_set_basic_info_t
     * }
     */
    public static final AddressLayout processor_set_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct processor_set_load_info {
     *     int task_count;
     *     int thread_count;
     *     integer_t load_average;
     *     integer_t mach_factor;
     * } *processor_set_load_info_t
     * }
     */
    public static final AddressLayout processor_set_load_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int policy_t
     * }
     */
    public static final OfInt policy_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *policy_info_t
     * }
     */
    public static final AddressLayout policy_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *policy_base_t
     * }
     */
    public static final AddressLayout policy_base_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *policy_limit_t
     * }
     */
    public static final AddressLayout policy_limit_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_timeshare_base {
     *     integer_t base_priority;
     * } *policy_timeshare_base_t
     * }
     */
    public static final AddressLayout policy_timeshare_base_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_timeshare_limit {
     *     integer_t max_priority;
     * } *policy_timeshare_limit_t
     * }
     */
    public static final AddressLayout policy_timeshare_limit_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_timeshare_info {
     *     integer_t max_priority;
     *     integer_t base_priority;
     *     integer_t cur_priority;
     *     boolean_t depressed;
     *     integer_t depress_priority;
     * } *policy_timeshare_info_t
     * }
     */
    public static final AddressLayout policy_timeshare_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_rr_base {
     *     integer_t base_priority;
     *     integer_t quantum;
     * } *policy_rr_base_t
     * }
     */
    public static final AddressLayout policy_rr_base_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_rr_limit {
     *     integer_t max_priority;
     * } *policy_rr_limit_t
     * }
     */
    public static final AddressLayout policy_rr_limit_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_rr_info {
     *     integer_t max_priority;
     *     integer_t base_priority;
     *     integer_t quantum;
     *     boolean_t depressed;
     *     integer_t depress_priority;
     * } *policy_rr_info_t
     * }
     */
    public static final AddressLayout policy_rr_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_fifo_base {
     *     integer_t base_priority;
     * } *policy_fifo_base_t
     * }
     */
    public static final AddressLayout policy_fifo_base_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_fifo_limit {
     *     integer_t max_priority;
     * } *policy_fifo_limit_t
     * }
     */
    public static final AddressLayout policy_fifo_limit_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_fifo_info {
     *     integer_t max_priority;
     *     integer_t base_priority;
     *     boolean_t depressed;
     *     integer_t depress_priority;
     * } *policy_fifo_info_t
     * }
     */
    public static final AddressLayout policy_fifo_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t task_flavor_t
     * }
     */
    public static final OfInt task_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *task_info_t
     * }
     */
    public static final AddressLayout task_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_basic_info_32 {
     *     integer_t suspend_count;
     *     natural_t virtual_size;
     *     natural_t resident_size;
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     policy_t policy;
     * } *task_basic_info_32_t
     * }
     */
    public static final AddressLayout task_basic_info_32_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_basic_info_64 {
     *     integer_t suspend_count;
     *     mach_vm_size_t virtual_size;
     *     mach_vm_size_t resident_size;
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     policy_t policy;
     * } *task_basic_info_64_t
     * }
     */
    public static final AddressLayout task_basic_info_64_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_basic_info {
     *     integer_t suspend_count;
     *     vm_size_t virtual_size;
     *     vm_size_t resident_size;
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     policy_t policy;
     * } *task_basic_info_t
     * }
     */
    public static final AddressLayout task_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_events_info {
     *     integer_t faults;
     *     integer_t pageins;
     *     integer_t cow_faults;
     *     integer_t messages_sent;
     *     integer_t messages_received;
     *     integer_t syscalls_mach;
     *     integer_t syscalls_unix;
     *     integer_t csw;
     * } *task_events_info_t
     * }
     */
    public static final AddressLayout task_events_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_thread_times_info {
     *     time_value_t user_time;
     *     time_value_t system_time;
     * } *task_thread_times_info_t
     * }
     */
    public static final AddressLayout task_thread_times_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_absolutetime_info {
     *     uint64_t total_user;
     *     uint64_t total_system;
     *     uint64_t threads_user;
     *     uint64_t threads_system;
     * } *task_absolutetime_info_t
     * }
     */
    public static final AddressLayout task_absolutetime_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_kernelmemory_info {
     *     uint64_t total_palloc;
     *     uint64_t total_pfree;
     *     uint64_t total_salloc;
     *     uint64_t total_sfree;
     * } *task_kernelmemory_info_t
     * }
     */
    public static final AddressLayout task_kernelmemory_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_affinity_tag_info {
     *     integer_t set_count;
     *     integer_t min;
     *     integer_t max;
     *     integer_t task_count;
     * } *task_affinity_tag_info_t
     * }
     */
    public static final AddressLayout task_affinity_tag_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_dyld_info {
     *     mach_vm_address_t all_image_info_addr;
     *     mach_vm_size_t all_image_info_size;
     *     integer_t all_image_info_format;
     * } *task_dyld_info_t
     * }
     */
    public static final AddressLayout task_dyld_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_basic_info_64_2 {
     *     integer_t suspend_count;
     *     mach_vm_size_t virtual_size;
     *     mach_vm_size_t resident_size;
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     policy_t policy;
     * } *task_basic_info_64_2_t
     * }
     */
    public static final AddressLayout task_basic_info_64_2_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_extmod_info {
     *     unsigned char task_uuid[16];
     *     vm_extmod_statistics_data_t extmod_statistics;
     * } *task_extmod_info_t
     * }
     */
    public static final AddressLayout task_extmod_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct mach_task_basic_info {
     *     mach_vm_size_t virtual_size;
     *     mach_vm_size_t resident_size;
     *     mach_vm_size_t resident_size_max;
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     policy_t policy;
     *     integer_t suspend_count;
     * } *mach_task_basic_info_t
     * }
     */
    public static final AddressLayout mach_task_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_power_info {
     *     uint64_t total_user;
     *     uint64_t total_system;
     *     uint64_t task_interrupt_wakeups;
     *     uint64_t task_platform_idle_wakeups;
     *     uint64_t task_timer_wakeups_bin_1;
     *     uint64_t task_timer_wakeups_bin_2;
     * } *task_power_info_t
     * }
     */
    public static final AddressLayout task_power_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_vm_info {
     *     mach_vm_size_t virtual_size;
     *     integer_t region_count;
     *     integer_t page_size;
     *     mach_vm_size_t resident_size;
     *     mach_vm_size_t resident_size_peak;
     *     mach_vm_size_t device;
     *     mach_vm_size_t device_peak;
     *     mach_vm_size_t internal;
     *     mach_vm_size_t internal_peak;
     *     mach_vm_size_t external;
     *     mach_vm_size_t external_peak;
     *     mach_vm_size_t reusable;
     *     mach_vm_size_t reusable_peak;
     *     mach_vm_size_t purgeable_volatile_pmap;
     *     mach_vm_size_t purgeable_volatile_resident;
     *     mach_vm_size_t purgeable_volatile_virtual;
     *     mach_vm_size_t compressed;
     *     mach_vm_size_t compressed_peak;
     *     mach_vm_size_t compressed_lifetime;
     *     mach_vm_size_t phys_footprint;
     *     mach_vm_address_t min_address;
     *     mach_vm_address_t max_address;
     *     int64_t ledger_phys_footprint_peak;
     *     int64_t ledger_purgeable_nonvolatile;
     *     int64_t ledger_purgeable_novolatile_compressed;
     *     int64_t ledger_purgeable_volatile;
     *     int64_t ledger_purgeable_volatile_compressed;
     *     int64_t ledger_tag_network_nonvolatile;
     *     int64_t ledger_tag_network_nonvolatile_compressed;
     *     int64_t ledger_tag_network_volatile;
     *     int64_t ledger_tag_network_volatile_compressed;
     *     int64_t ledger_tag_media_footprint;
     *     int64_t ledger_tag_media_footprint_compressed;
     *     int64_t ledger_tag_media_nofootprint;
     *     int64_t ledger_tag_media_nofootprint_compressed;
     *     int64_t ledger_tag_graphics_footprint;
     *     int64_t ledger_tag_graphics_footprint_compressed;
     *     int64_t ledger_tag_graphics_nofootprint;
     *     int64_t ledger_tag_graphics_nofootprint_compressed;
     *     int64_t ledger_tag_neural_footprint;
     *     int64_t ledger_tag_neural_footprint_compressed;
     *     int64_t ledger_tag_neural_nofootprint;
     *     int64_t ledger_tag_neural_nofootprint_compressed;
     *     uint64_t limit_bytes_remaining;
     *     integer_t decompressions;
     *     int64_t ledger_swapins;
     *     int64_t ledger_tag_neural_nofootprint_total;
     *     int64_t ledger_tag_neural_nofootprint_peak;
     * } *task_vm_info_t
     * }
     */
    public static final AddressLayout task_vm_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_trace_memory_info {
     *     uint64_t user_memory_address;
     *     uint64_t buffer_size;
     *     uint64_t mailbox_array_size;
     * } *task_trace_memory_info_t
     * }
     */
    public static final AddressLayout task_trace_memory_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_wait_state_info {
     *     uint64_t total_wait_state_time;
     *     uint64_t total_wait_sfi_state_time;
     *     uint32_t _reserved[4];
     * } *task_wait_state_info_t
     * }
     */
    public static final AddressLayout task_wait_state_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef gpu_energy_data *gpu_energy_data_t
     * }
     */
    public static final AddressLayout gpu_energy_data_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_power_info_v2 {
     *     task_power_info_data_t cpu_energy;
     *     gpu_energy_data gpu_energy;
     *     uint64_t task_energy;
     *     uint64_t task_ptime;
     *     uint64_t task_pset_switches;
     * } *task_power_info_v2_t
     * }
     */
    public static final AddressLayout task_power_info_v2_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_flags_info {
     *     uint32_t flags;
     * } *task_flags_info_t
     * }
     */
    public static final AddressLayout task_flags_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef uint32_t task_exc_guard_behavior_t
     * }
     */
    public static final OfInt task_exc_guard_behavior_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t task_corpse_forking_behavior_t
     * }
     */
    public static final OfInt task_corpse_forking_behavior_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t task_inspect_flavor_t
     * }
     */
    public static final OfInt task_inspect_flavor_t = ObjCRuntime.C_INT;
    private static final int TASK_INSPECT_BASIC_COUNTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum task_inspect_flavor.TASK_INSPECT_BASIC_COUNTS = 1
     * }
     */
    public static int TASK_INSPECT_BASIC_COUNTS() {
        return TASK_INSPECT_BASIC_COUNTS;
    }
    /**
     * {@snippet lang=c :
     * typedef struct task_inspect_basic_counts {
     *     uint64_t instructions;
     *     uint64_t cycles;
     * } *task_inspect_basic_counts_t
     * }
     */
    public static final AddressLayout task_inspect_basic_counts_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *task_inspect_info_t
     * }
     */
    public static final AddressLayout task_inspect_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t task_policy_flavor_t
     * }
     */
    public static final OfInt task_policy_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *task_policy_t
     * }
     */
    public static final AddressLayout task_policy_t = ObjCRuntime.C_POINTER;
    private static final int TASK_RENICED = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_RENICED = -1
     * }
     */
    public static int TASK_RENICED() {
        return TASK_RENICED;
    }
    private static final int TASK_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_UNSPECIFIED = 0
     * }
     */
    public static int TASK_UNSPECIFIED() {
        return TASK_UNSPECIFIED;
    }
    private static final int TASK_FOREGROUND_APPLICATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_FOREGROUND_APPLICATION = 1
     * }
     */
    public static int TASK_FOREGROUND_APPLICATION() {
        return TASK_FOREGROUND_APPLICATION;
    }
    private static final int TASK_BACKGROUND_APPLICATION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_BACKGROUND_APPLICATION = 2
     * }
     */
    public static int TASK_BACKGROUND_APPLICATION() {
        return TASK_BACKGROUND_APPLICATION;
    }
    private static final int TASK_CONTROL_APPLICATION = (int)3L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_CONTROL_APPLICATION = 3
     * }
     */
    public static int TASK_CONTROL_APPLICATION() {
        return TASK_CONTROL_APPLICATION;
    }
    private static final int TASK_GRAPHICS_SERVER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_GRAPHICS_SERVER = 4
     * }
     */
    public static int TASK_GRAPHICS_SERVER() {
        return TASK_GRAPHICS_SERVER;
    }
    private static final int TASK_THROTTLE_APPLICATION = (int)5L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_THROTTLE_APPLICATION = 5
     * }
     */
    public static int TASK_THROTTLE_APPLICATION() {
        return TASK_THROTTLE_APPLICATION;
    }
    private static final int TASK_NONUI_APPLICATION = (int)6L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_NONUI_APPLICATION = 6
     * }
     */
    public static int TASK_NONUI_APPLICATION() {
        return TASK_NONUI_APPLICATION;
    }
    private static final int TASK_DEFAULT_APPLICATION = (int)7L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_DEFAULT_APPLICATION = 7
     * }
     */
    public static int TASK_DEFAULT_APPLICATION() {
        return TASK_DEFAULT_APPLICATION;
    }
    private static final int TASK_DARWINBG_APPLICATION = (int)8L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_DARWINBG_APPLICATION = 8
     * }
     */
    public static int TASK_DARWINBG_APPLICATION() {
        return TASK_DARWINBG_APPLICATION;
    }
    /**
     * {@snippet lang=c :
     * typedef struct task_category_policy {
     *     task_role_t role;
     * } *task_category_policy_t
     * }
     */
    public static final AddressLayout task_category_policy_t = ObjCRuntime.C_POINTER;
    private static final int LATENCY_QOS_TIER_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_UNSPECIFIED = 0
     * }
     */
    public static int LATENCY_QOS_TIER_UNSPECIFIED() {
        return LATENCY_QOS_TIER_UNSPECIFIED;
    }
    private static final int LATENCY_QOS_TIER_0 = (int)16711681L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_0 = 16711681
     * }
     */
    public static int LATENCY_QOS_TIER_0() {
        return LATENCY_QOS_TIER_0;
    }
    private static final int LATENCY_QOS_TIER_1 = (int)16711682L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_1 = 16711682
     * }
     */
    public static int LATENCY_QOS_TIER_1() {
        return LATENCY_QOS_TIER_1;
    }
    private static final int LATENCY_QOS_TIER_2 = (int)16711683L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_2 = 16711683
     * }
     */
    public static int LATENCY_QOS_TIER_2() {
        return LATENCY_QOS_TIER_2;
    }
    private static final int LATENCY_QOS_TIER_3 = (int)16711684L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_3 = 16711684
     * }
     */
    public static int LATENCY_QOS_TIER_3() {
        return LATENCY_QOS_TIER_3;
    }
    private static final int LATENCY_QOS_TIER_4 = (int)16711685L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_4 = 16711685
     * }
     */
    public static int LATENCY_QOS_TIER_4() {
        return LATENCY_QOS_TIER_4;
    }
    private static final int LATENCY_QOS_TIER_5 = (int)16711686L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_5 = 16711686
     * }
     */
    public static int LATENCY_QOS_TIER_5() {
        return LATENCY_QOS_TIER_5;
    }
    /**
     * {@snippet lang=c :
     * typedef integer_t task_latency_qos_t
     * }
     */
    public static final OfInt task_latency_qos_t = ObjCRuntime.C_INT;
    private static final int THROUGHPUT_QOS_TIER_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_UNSPECIFIED = 0
     * }
     */
    public static int THROUGHPUT_QOS_TIER_UNSPECIFIED() {
        return THROUGHPUT_QOS_TIER_UNSPECIFIED;
    }
    private static final int THROUGHPUT_QOS_TIER_0 = (int)16646145L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_0 = 16646145
     * }
     */
    public static int THROUGHPUT_QOS_TIER_0() {
        return THROUGHPUT_QOS_TIER_0;
    }
    private static final int THROUGHPUT_QOS_TIER_1 = (int)16646146L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_1 = 16646146
     * }
     */
    public static int THROUGHPUT_QOS_TIER_1() {
        return THROUGHPUT_QOS_TIER_1;
    }
    private static final int THROUGHPUT_QOS_TIER_2 = (int)16646147L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_2 = 16646147
     * }
     */
    public static int THROUGHPUT_QOS_TIER_2() {
        return THROUGHPUT_QOS_TIER_2;
    }
    private static final int THROUGHPUT_QOS_TIER_3 = (int)16646148L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_3 = 16646148
     * }
     */
    public static int THROUGHPUT_QOS_TIER_3() {
        return THROUGHPUT_QOS_TIER_3;
    }
    private static final int THROUGHPUT_QOS_TIER_4 = (int)16646149L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_4 = 16646149
     * }
     */
    public static int THROUGHPUT_QOS_TIER_4() {
        return THROUGHPUT_QOS_TIER_4;
    }
    private static final int THROUGHPUT_QOS_TIER_5 = (int)16646150L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_5 = 16646150
     * }
     */
    public static int THROUGHPUT_QOS_TIER_5() {
        return THROUGHPUT_QOS_TIER_5;
    }
    /**
     * {@snippet lang=c :
     * typedef integer_t task_throughput_qos_t
     * }
     */
    public static final OfInt task_throughput_qos_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct task_qos_policy {
     *     task_latency_qos_t task_latency_qos_tier;
     *     task_throughput_qos_t task_throughput_qos_tier;
     * } *task_qos_policy_t
     * }
     */
    public static final AddressLayout task_qos_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int task_special_port_t
     * }
     */
    public static final OfInt task_special_port_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t thread_flavor_t
     * }
     */
    public static final OfInt thread_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *thread_info_t
     * }
     */
    public static final AddressLayout thread_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_basic_info {
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     integer_t cpu_usage;
     *     policy_t policy;
     *     integer_t run_state;
     *     integer_t flags;
     *     integer_t suspend_count;
     *     integer_t sleep_time;
     * } *thread_basic_info_t
     * }
     */
    public static final AddressLayout thread_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_identifier_info {
     *     uint64_t thread_id;
     *     uint64_t thread_handle;
     *     uint64_t dispatch_qaddr;
     * } *thread_identifier_info_t
     * }
     */
    public static final AddressLayout thread_identifier_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_extended_info {
     *     uint64_t pth_user_time;
     *     uint64_t pth_system_time;
     *     int32_t pth_cpu_usage;
     *     int32_t pth_policy;
     *     int32_t pth_run_state;
     *     int32_t pth_flags;
     *     int32_t pth_sleep_time;
     *     int32_t pth_curpri;
     *     int32_t pth_priority;
     *     int32_t pth_maxpriority;
     *     char pth_name[64];
     * } *thread_extended_info_t
     * }
     */
    public static final AddressLayout thread_extended_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct io_stat_info {
     *     struct io_stat_entry disk_reads;
     *     struct io_stat_entry io_priority[4];
     *     struct io_stat_entry paging;
     *     struct io_stat_entry metadata;
     *     struct io_stat_entry total_io;
     * } *io_stat_info_t
     * }
     */
    public static final AddressLayout io_stat_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t thread_policy_flavor_t
     * }
     */
    public static final OfInt thread_policy_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *thread_policy_t
     * }
     */
    public static final AddressLayout thread_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_standard_policy {
     *     natural_t no_data;
     * } *thread_standard_policy_t
     * }
     */
    public static final AddressLayout thread_standard_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_extended_policy {
     *     boolean_t timeshare;
     * } *thread_extended_policy_t
     * }
     */
    public static final AddressLayout thread_extended_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_time_constraint_policy {
     *     uint32_t period;
     *     uint32_t computation;
     *     uint32_t constraint;
     *     boolean_t preemptible;
     * } *thread_time_constraint_policy_t
     * }
     */
    public static final AddressLayout thread_time_constraint_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_precedence_policy {
     *     integer_t importance;
     * } *thread_precedence_policy_t
     * }
     */
    public static final AddressLayout thread_precedence_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_affinity_policy {
     *     integer_t affinity_tag;
     * } *thread_affinity_policy_t
     * }
     */
    public static final AddressLayout thread_affinity_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_background_policy {
     *     integer_t priority;
     * } *thread_background_policy_t
     * }
     */
    public static final AddressLayout thread_background_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t thread_latency_qos_t
     * }
     */
    public static final OfInt thread_latency_qos_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct thread_latency_qos_policy {
     *     thread_latency_qos_t thread_latency_qos_tier;
     * } *thread_latency_qos_policy_t
     * }
     */
    public static final AddressLayout thread_latency_qos_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t thread_throughput_qos_t
     * }
     */
    public static final OfInt thread_throughput_qos_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct thread_throughput_qos_policy {
     *     thread_throughput_qos_t thread_throughput_qos_tier;
     * } *thread_throughput_qos_policy_t
     * }
     */
    public static final AddressLayout thread_throughput_qos_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int alarm_type_t
     * }
     */
    public static final OfInt alarm_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int sleep_type_t
     * }
     */
    public static final OfInt sleep_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int clock_id_t
     * }
     */
    public static final OfInt clock_id_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int clock_flavor_t
     * }
     */
    public static final OfInt clock_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int *clock_attr_t
     * }
     */
    public static final AddressLayout clock_attr_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int clock_res_t
     * }
     */
    public static final OfInt clock_res_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int vm_machine_attribute_t
     * }
     */
    public static final OfInt vm_machine_attribute_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int vm_machine_attribute_val_t
     * }
     */
    public static final OfInt vm_machine_attribute_val_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int vm_inherit_t
     * }
     */
    public static final OfInt vm_inherit_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int vm_purgable_t
     * }
     */
    public static final OfInt vm_purgable_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int vm_behavior_t
     * }
     */
    public static final OfInt vm_behavior_t = ObjCRuntime.C_INT;

    private static class vm_page_size$constants {
        public static final OfLong LAYOUT = ObjCRuntime.C_LONG;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_page_size").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_size
     * }
     */
    public static OfLong vm_page_size$layout() {
        return vm_page_size$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_size
     * }
     */
    public static MemorySegment vm_page_size$segment() {
        return vm_page_size$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_size
     * }
     */
    public static long vm_page_size() {
        return vm_page_size$constants.SEGMENT.get(vm_page_size$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_size
     * }
     */
    public static void vm_page_size(long varValue) {
        vm_page_size$constants.SEGMENT.set(vm_page_size$constants.LAYOUT, 0L, varValue);
    }

    private static class vm_page_mask$constants {
        public static final OfLong LAYOUT = ObjCRuntime.C_LONG;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_page_mask").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_mask
     * }
     */
    public static OfLong vm_page_mask$layout() {
        return vm_page_mask$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_mask
     * }
     */
    public static MemorySegment vm_page_mask$segment() {
        return vm_page_mask$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_mask
     * }
     */
    public static long vm_page_mask() {
        return vm_page_mask$constants.SEGMENT.get(vm_page_mask$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_mask
     * }
     */
    public static void vm_page_mask(long varValue) {
        vm_page_mask$constants.SEGMENT.set(vm_page_mask$constants.LAYOUT, 0L, varValue);
    }

    private static class vm_page_shift$constants {
        public static final OfInt LAYOUT = ObjCRuntime.C_INT;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_page_shift").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int vm_page_shift
     * }
     */
    public static OfInt vm_page_shift$layout() {
        return vm_page_shift$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int vm_page_shift
     * }
     */
    public static MemorySegment vm_page_shift$segment() {
        return vm_page_shift$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int vm_page_shift
     * }
     */
    public static int vm_page_shift() {
        return vm_page_shift$constants.SEGMENT.get(vm_page_shift$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int vm_page_shift
     * }
     */
    public static void vm_page_shift(int varValue) {
        vm_page_shift$constants.SEGMENT.set(vm_page_shift$constants.LAYOUT, 0L, varValue);
    }

    private static class vm_kernel_page_size$constants {
        public static final OfLong LAYOUT = ObjCRuntime.C_LONG;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_kernel_page_size").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_size
     * }
     */
    public static OfLong vm_kernel_page_size$layout() {
        return vm_kernel_page_size$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_size
     * }
     */
    public static MemorySegment vm_kernel_page_size$segment() {
        return vm_kernel_page_size$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_size
     * }
     */
    public static long vm_kernel_page_size() {
        return vm_kernel_page_size$constants.SEGMENT.get(vm_kernel_page_size$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_size
     * }
     */
    public static void vm_kernel_page_size(long varValue) {
        vm_kernel_page_size$constants.SEGMENT.set(vm_kernel_page_size$constants.LAYOUT, 0L, varValue);
    }

    private static class vm_kernel_page_mask$constants {
        public static final OfLong LAYOUT = ObjCRuntime.C_LONG;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_kernel_page_mask").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_mask
     * }
     */
    public static OfLong vm_kernel_page_mask$layout() {
        return vm_kernel_page_mask$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_mask
     * }
     */
    public static MemorySegment vm_kernel_page_mask$segment() {
        return vm_kernel_page_mask$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_mask
     * }
     */
    public static long vm_kernel_page_mask() {
        return vm_kernel_page_mask$constants.SEGMENT.get(vm_kernel_page_mask$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_mask
     * }
     */
    public static void vm_kernel_page_mask(long varValue) {
        vm_kernel_page_mask$constants.SEGMENT.set(vm_kernel_page_mask$constants.LAYOUT, 0L, varValue);
    }

    private static class vm_kernel_page_shift$constants {
        public static final OfInt LAYOUT = ObjCRuntime.C_INT;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_kernel_page_shift").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int vm_kernel_page_shift
     * }
     */
    public static OfInt vm_kernel_page_shift$layout() {
        return vm_kernel_page_shift$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int vm_kernel_page_shift
     * }
     */
    public static MemorySegment vm_kernel_page_shift$segment() {
        return vm_kernel_page_shift$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int vm_kernel_page_shift
     * }
     */
    public static int vm_kernel_page_shift() {
        return vm_kernel_page_shift$constants.SEGMENT.get(vm_kernel_page_shift$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int vm_kernel_page_shift
     * }
     */
    public static void vm_kernel_page_shift(int varValue) {
        vm_kernel_page_shift$constants.SEGMENT.set(vm_kernel_page_shift$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_object_id_t
     * }
     */
    public static final OfInt vm32_object_id_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int *vm_region_info_t
     * }
     */
    public static final AddressLayout vm_region_info_t = ObjCRuntime.C_POINTER;
}

