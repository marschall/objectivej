// Generated by jextract

package com.github.marschall.objectivej.header;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class ObjCRuntime_1 extends ObjCRuntime_2 {

    ObjCRuntime_1() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t quad_t
     * }
     */
    public static final OfLong quad_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef quad_t *qaddr_t
     * }
     */
    public static final AddressLayout qaddr_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef char *caddr_t
     * }
     */
    public static final AddressLayout caddr_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int32_t daddr_t
     * }
     */
    public static final OfInt daddr_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fixpt_t
     * }
     */
    public static final OfInt fixpt_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blksize_t blksize_t
     * }
     */
    public static final OfInt blksize_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_gid_t gid_t
     * }
     */
    public static final OfInt gid_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t in_addr_t
     * }
     */
    public static final OfInt in_addr_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t in_port_t
     * }
     */
    public static final OfShort in_port_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino_t ino_t
     * }
     */
    public static final OfLong ino_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t ino64_t
     * }
     */
    public static final OfLong ino64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t key_t
     * }
     */
    public static final OfInt key_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t nlink_t
     * }
     */
    public static final OfShort nlink_t = ObjCRuntime.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int32_t segsz_t
     * }
     */
    public static final OfInt segsz_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t swblk_t
     * }
     */
    public static final OfInt swblk_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_clock_t clock_t
     * }
     */
    public static final OfLong clock_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_time_t time_t
     * }
     */
    public static final OfLong time_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_useconds_t useconds_t
     * }
     */
    public static final OfInt useconds_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_suseconds_t suseconds_t
     * }
     */
    public static final OfInt suseconds_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = ObjCRuntime.C_INT;

    private static class __darwin_check_fd_set_overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("__darwin_check_fd_set_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static FunctionDescriptor __darwin_check_fd_set_overflow$descriptor() {
        return __darwin_check_fd_set_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MethodHandle __darwin_check_fd_set_overflow$handle() {
        return __darwin_check_fd_set_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MemorySegment __darwin_check_fd_set_overflow$address() {
        return __darwin_check_fd_set_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static int __darwin_check_fd_set_overflow(int x0, MemorySegment x1, int x2) {
        var mh$ = __darwin_check_fd_set_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__darwin_check_fd_set_overflow", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __int32_t fd_mask
     * }
     */
    public static final OfInt fd_mask = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_t pthread_t
     * }
     */
    public static final AddressLayout pthread_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_key_t pthread_key_t
     * }
     */
    public static final OfLong pthread_key_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfInt fsblkcnt_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfInt fsfilcnt_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct objc_class *Class
     * }
     */
    public static final AddressLayout Class_ = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_object {
     *     OBJC_ISA_AVAILABILITY Class isa;
     * } *id
     * }
     */
    public static final AddressLayout id = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_selector *SEL
     * }
     */
    public static final AddressLayout SEL = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef bool BOOL
     * }
     */
    public static final OfBoolean BOOL = ObjCRuntime.C_BOOL;
    /**
     * {@snippet lang=c :
     * typedef struct _malloc_zone_t {
     *     void *reserved1;
     *     void *reserved2;
     *     size_t (*size)(struct _malloc_zone_t *, const void *);
     *     void *(*malloc)(struct _malloc_zone_t *, size_t);
     *     void *(*calloc)(struct _malloc_zone_t *, size_t, size_t);
     *     void *(*valloc)(struct _malloc_zone_t *, size_t);
     *     void (*free)(struct _malloc_zone_t *, void *);
     *     void *(*realloc)(struct _malloc_zone_t *, void *, size_t);
     *     void (*destroy)(struct _malloc_zone_t *);
     *     const char *zone_name;
     *     unsigned int (*batch_malloc)(struct _malloc_zone_t *, size_t, void **, unsigned int);
     *     void (*batch_free)(struct _malloc_zone_t *, void **, unsigned int);
     *     struct malloc_introspection_t *introspect;
     *     unsigned int version;
     *     void *(*memalign)(struct _malloc_zone_t *, size_t, size_t);
     *     void (*free_definite_size)(struct _malloc_zone_t *, void *, size_t);
     *     size_t (*pressure_relief)(struct _malloc_zone_t *, size_t);
     *     boolean_t (*claimed_address)(struct _malloc_zone_t *, void *);
     *     void (*try_free_default)(struct _malloc_zone_t *, void *);
     *     void *(*malloc_with_options)(struct _malloc_zone_t *, size_t, size_t, uint64_t);
     *     void *(*malloc_type_malloc)(struct _malloc_zone_t *, size_t, malloc_type_id_t);
     *     void *(*malloc_type_calloc)(struct _malloc_zone_t *, size_t, size_t, malloc_type_id_t);
     *     void *(*malloc_type_realloc)(struct _malloc_zone_t *, void *, size_t, malloc_type_id_t);
     *     void *(*malloc_type_memalign)(struct _malloc_zone_t *, size_t, size_t, malloc_type_id_t);
     *     void *(*malloc_type_malloc_with_options)(struct _malloc_zone_t *, size_t, size_t, uint64_t, malloc_type_id_t);
     * } *objc_zone_t
     * }
     */
    public static final AddressLayout objc_zone_t = ObjCRuntime.C_POINTER;

    private static class sel_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor sel_getName$descriptor() {
        return sel_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle sel_getName$handle() {
        return sel_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment sel_getName$address() {
        return sel_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull sel_getName(SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment sel_getName(MemorySegment sel) {
        var mh$ = sel_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_getName", sel);
            }
            return (MemorySegment)mh$.invokeExact(sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_registerName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_registerName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static FunctionDescriptor sel_registerName$descriptor() {
        return sel_registerName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static MethodHandle sel_registerName$handle() {
        return sel_registerName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_registerName$address() {
        return sel_registerName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_registerName(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_registerName(MemorySegment str) {
        var mh$ = sel_registerName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_registerName", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getClassName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getClassName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_getClassName$descriptor() {
        return object_getClassName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_getClassName$handle() {
        return object_getClassName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClassName$address() {
        return object_getClassName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull object_getClassName(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClassName(MemorySegment obj) {
        var mh$ = object_getClassName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getClassName", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getIndexedIvars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getIndexedIvars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_getIndexedIvars$descriptor() {
        return object_getIndexedIvars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_getIndexedIvars$handle() {
        return object_getIndexedIvars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getIndexedIvars$address() {
        return object_getIndexedIvars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable object_getIndexedIvars(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getIndexedIvars(MemorySegment obj) {
        var mh$ = object_getIndexedIvars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getIndexedIvars", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_isMapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_isMapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor sel_isMapped$descriptor() {
        return sel_isMapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle sel_isMapped$handle() {
        return sel_isMapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment sel_isMapped$address() {
        return sel_isMapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL sel_isMapped(SEL  _Nonnull sel)
     * }
     */
    public static boolean sel_isMapped(MemorySegment sel) {
        var mh$ = sel_isMapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_isMapped", sel);
            }
            return (boolean)mh$.invokeExact(sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_getUid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_getUid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static FunctionDescriptor sel_getUid$descriptor() {
        return sel_getUid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static MethodHandle sel_getUid$handle() {
        return sel_getUid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_getUid$address() {
        return sel_getUid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern SEL  _Nonnull sel_getUid(const char * _Nonnull str)
     * }
     */
    public static MemorySegment sel_getUid(MemorySegment str) {
        var mh$ = sel_getUid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_getUid", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef const void *objc_objectptr_t
     * }
     */
    public static final AddressLayout objc_objectptr_t = ObjCRuntime.C_POINTER;

    private static class objc_retainedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_retainedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_retainedObject$descriptor() {
        return objc_retainedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MethodHandle objc_retainedObject$handle() {
        return objc_retainedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_retainedObject$address() {
        return objc_retainedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_retainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_retainedObject(MemorySegment obj) {
        var mh$ = objc_retainedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_retainedObject", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_unretainedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_unretainedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_unretainedObject$descriptor() {
        return objc_unretainedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MethodHandle objc_unretainedObject$handle() {
        return objc_unretainedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedObject$address() {
        return objc_unretainedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_unretainedObject(objc_objectptr_t  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedObject(MemorySegment obj) {
        var mh$ = objc_unretainedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_unretainedObject", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_unretainedPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_unretainedPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_unretainedPointer$descriptor() {
        return objc_unretainedPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static MethodHandle objc_unretainedPointer$handle() {
        return objc_unretainedPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedPointer$address() {
        return objc_unretainedPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_objectptr_t  _Nullable objc_unretainedPointer(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_unretainedPointer(MemorySegment obj) {
        var mh$ = objc_unretainedPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_unretainedPointer", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_method *Method
     * }
     */
    public static final AddressLayout Method = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_ivar *Ivar
     * }
     */
    public static final AddressLayout Ivar = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_category *Category
     * }
     */
    public static final AddressLayout Category = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct objc_property *objc_property_t
     * }
     */
    public static final AddressLayout objc_property_t = ObjCRuntime.C_POINTER;

    private static class object_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static FunctionDescriptor object_copy$descriptor() {
        return object_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static MethodHandle object_copy$handle() {
        return object_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static MemorySegment object_copy$address() {
        return object_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_copy(id  _Nullable obj, size_t size)
     * }
     */
    public static MemorySegment object_copy(MemorySegment obj, long size) {
        var mh$ = object_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_copy", obj, size);
            }
            return (MemorySegment)mh$.invokeExact(obj, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_dispose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_dispose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_dispose$descriptor() {
        return object_dispose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_dispose$handle() {
        return object_dispose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_dispose$address() {
        return object_dispose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_dispose(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_dispose(MemorySegment obj) {
        var mh$ = object_dispose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_dispose", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_getClass$descriptor() {
        return object_getClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_getClass$handle() {
        return object_getClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClass$address() {
        return object_getClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable object_getClass(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_getClass(MemorySegment obj) {
        var mh$ = object_getClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getClass", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static FunctionDescriptor object_setClass$descriptor() {
        return object_setClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static MethodHandle object_setClass$handle() {
        return object_setClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static MemorySegment object_setClass$address() {
        return object_setClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable object_setClass(id  _Nullable obj, Class  _Nonnull cls)
     * }
     */
    public static MemorySegment object_setClass(MemorySegment obj, MemorySegment cls) {
        var mh$ = object_setClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setClass", obj, cls);
            }
            return (MemorySegment)mh$.invokeExact(obj, cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_isClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_isClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor object_isClass$descriptor() {
        return object_isClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static MethodHandle object_isClass$handle() {
        return object_isClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static MemorySegment object_isClass$address() {
        return object_isClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL object_isClass(id  _Nullable obj)
     * }
     */
    public static boolean object_isClass(MemorySegment obj) {
        var mh$ = object_isClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_isClass", obj);
            }
            return (boolean)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getIvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getIvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static FunctionDescriptor object_getIvar$descriptor() {
        return object_getIvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static MethodHandle object_getIvar$handle() {
        return object_getIvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static MemorySegment object_getIvar$address() {
        return object_getIvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_getIvar(id  _Nullable obj, Ivar  _Nonnull ivar)
     * }
     */
    public static MemorySegment object_getIvar(MemorySegment obj, MemorySegment ivar) {
        var mh$ = object_getIvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getIvar", obj, ivar);
            }
            return (MemorySegment)mh$.invokeExact(obj, ivar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setIvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setIvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setIvar$descriptor() {
        return object_setIvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MethodHandle object_setIvar$handle() {
        return object_setIvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MemorySegment object_setIvar$address() {
        return object_setIvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void object_setIvar(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static void object_setIvar(MemorySegment obj, MemorySegment ivar, MemorySegment value) {
        var mh$ = object_setIvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setIvar", obj, ivar, value);
            }
            mh$.invokeExact(obj, ivar, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setIvarWithStrongDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setIvarWithStrongDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setIvarWithStrongDefault$descriptor() {
        return object_setIvarWithStrongDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MethodHandle object_setIvarWithStrongDefault$handle() {
        return object_setIvarWithStrongDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static MemorySegment object_setIvarWithStrongDefault$address() {
        return object_setIvarWithStrongDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void object_setIvarWithStrongDefault(id  _Nullable obj, Ivar  _Nonnull ivar, id  _Nullable value)
     * }
     */
    public static void object_setIvarWithStrongDefault(MemorySegment obj, MemorySegment ivar, MemorySegment value) {
        var mh$ = object_setIvarWithStrongDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setIvarWithStrongDefault", obj, ivar, value);
            }
            mh$.invokeExact(obj, ivar, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setInstanceVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setInstanceVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setInstanceVariable$descriptor() {
        return object_setInstanceVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MethodHandle object_setInstanceVariable$handle() {
        return object_setInstanceVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariable$address() {
        return object_setInstanceVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariable(MemorySegment obj, MemorySegment name, MemorySegment value) {
        var mh$ = object_setInstanceVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setInstanceVariable", obj, name, value);
            }
            return (MemorySegment)mh$.invokeExact(obj, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_setInstanceVariableWithStrongDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_setInstanceVariableWithStrongDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static FunctionDescriptor object_setInstanceVariableWithStrongDefault$descriptor() {
        return object_setInstanceVariableWithStrongDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MethodHandle object_setInstanceVariableWithStrongDefault$handle() {
        return object_setInstanceVariableWithStrongDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariableWithStrongDefault$address() {
        return object_setInstanceVariableWithStrongDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_setInstanceVariableWithStrongDefault(id  _Nullable obj, const char * _Nonnull name, void * _Nullable value)
     * }
     */
    public static MemorySegment object_setInstanceVariableWithStrongDefault(MemorySegment obj, MemorySegment name, MemorySegment value) {
        var mh$ = object_setInstanceVariableWithStrongDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_setInstanceVariableWithStrongDefault", obj, name, value);
            }
            return (MemorySegment)mh$.invokeExact(obj, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_getInstanceVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_getInstanceVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static FunctionDescriptor object_getInstanceVariable$descriptor() {
        return object_getInstanceVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static MethodHandle object_getInstanceVariable$handle() {
        return object_getInstanceVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static MemorySegment object_getInstanceVariable$address() {
        return object_getInstanceVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable object_getInstanceVariable(id  _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)
     * }
     */
    public static MemorySegment object_getInstanceVariable(MemorySegment obj, MemorySegment name, MemorySegment outValue) {
        var mh$ = object_getInstanceVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_getInstanceVariable", obj, name, outValue);
            }
            return (MemorySegment)mh$.invokeExact(obj, name, outValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getClass$descriptor() {
        return objc_getClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getClass$handle() {
        return objc_getClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getClass$address() {
        return objc_getClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getClass(MemorySegment name) {
        var mh$ = objc_getClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getMetaClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getMetaClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getMetaClass$descriptor() {
        return objc_getMetaClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getMetaClass$handle() {
        return objc_getMetaClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getMetaClass$address() {
        return objc_getMetaClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_getMetaClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getMetaClass(MemorySegment name) {
        var mh$ = objc_getMetaClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getMetaClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_lookUpClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_lookUpClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_lookUpClass$descriptor() {
        return objc_lookUpClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_lookUpClass$handle() {
        return objc_lookUpClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_lookUpClass$address() {
        return objc_lookUpClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_lookUpClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_lookUpClass(MemorySegment name) {
        var mh$ = objc_lookUpClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_lookUpClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getRequiredClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getRequiredClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getRequiredClass$descriptor() {
        return objc_getRequiredClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getRequiredClass$handle() {
        return objc_getRequiredClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getRequiredClass$address() {
        return objc_getRequiredClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getRequiredClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getRequiredClass(MemorySegment name) {
        var mh$ = objc_getRequiredClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getRequiredClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getClassList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getClassList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static FunctionDescriptor objc_getClassList$descriptor() {
        return objc_getClassList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static MethodHandle objc_getClassList$handle() {
        return objc_getClassList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static MemorySegment objc_getClassList$address() {
        return objc_getClassList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int objc_getClassList(Class  _Nonnull * _Nullable buffer, int bufferCount)
     * }
     */
    public static int objc_getClassList(MemorySegment buffer, int bufferCount) {
        var mh$ = objc_getClassList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getClassList", buffer, bufferCount);
            }
            return (int)mh$.invokeExact(buffer, bufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyClassList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyClassList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyClassList$descriptor() {
        return objc_copyClassList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyClassList$handle() {
        return objc_copyClassList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassList$address() {
        return objc_copyClassList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassList(MemorySegment outCount) {
        var mh$ = objc_copyClassList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyClassList", outCount);
            }
            return (MemorySegment)mh$.invokeExact(outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_enumerateClasses {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_enumerateClasses");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static FunctionDescriptor objc_enumerateClasses$descriptor() {
        return objc_enumerateClasses.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static MethodHandle objc_enumerateClasses$handle() {
        return objc_enumerateClasses.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static MemorySegment objc_enumerateClasses$address() {
        return objc_enumerateClasses.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_enumerateClasses(const void * _Nullable image, const char * _Nullable namePrefix, Protocol * _Nullable conformingTo, Class  _Nullable subclassing, OBJC_NOESCAPE void (^block)(Class _Nonnull, BOOL * _Nonnull))
     * }
     */
    public static void objc_enumerateClasses(MemorySegment image, MemorySegment namePrefix, MemorySegment conformingTo, MemorySegment subclassing, MemorySegment block) {
        var mh$ = objc_enumerateClasses.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_enumerateClasses", image, namePrefix, conformingTo, subclassing, block);
            }
            mh$.invokeExact(image, namePrefix, conformingTo, subclassing, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getName$descriptor() {
        return class_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getName$handle() {
        return class_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getName$address() {
        return class_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull class_getName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getName(MemorySegment cls) {
        var mh$ = class_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getName", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_isMetaClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_isMetaClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_isMetaClass$descriptor() {
        return class_isMetaClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_isMetaClass$handle() {
        return class_isMetaClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_isMetaClass$address() {
        return class_isMetaClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_isMetaClass(Class  _Nullable cls)
     * }
     */
    public static boolean class_isMetaClass(MemorySegment cls) {
        var mh$ = class_isMetaClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_isMetaClass", cls);
            }
            return (boolean)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getSuperclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getSuperclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getSuperclass$descriptor() {
        return class_getSuperclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getSuperclass$handle() {
        return class_getSuperclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getSuperclass$address() {
        return class_getSuperclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable class_getSuperclass(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getSuperclass(MemorySegment cls) {
        var mh$ = class_getSuperclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getSuperclass", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setSuperclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setSuperclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static FunctionDescriptor class_setSuperclass$descriptor() {
        return class_setSuperclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static MethodHandle class_setSuperclass$handle() {
        return class_setSuperclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static MemorySegment class_setSuperclass$address() {
        return class_setSuperclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull class_setSuperclass(Class  _Nonnull cls, Class  _Nonnull newSuper)
     * }
     */
    public static MemorySegment class_setSuperclass(MemorySegment cls, MemorySegment newSuper) {
        var mh$ = class_setSuperclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setSuperclass", cls, newSuper);
            }
            return (MemorySegment)mh$.invokeExact(cls, newSuper);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getVersion$descriptor() {
        return class_getVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getVersion$handle() {
        return class_getVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getVersion$address() {
        return class_getVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int class_getVersion(Class  _Nullable cls)
     * }
     */
    public static int class_getVersion(MemorySegment cls) {
        var mh$ = class_getVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getVersion", cls);
            }
            return (int)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static FunctionDescriptor class_setVersion$descriptor() {
        return class_setVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static MethodHandle class_setVersion$handle() {
        return class_setVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static MemorySegment class_setVersion$address() {
        return class_setVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_setVersion(Class  _Nullable cls, int version)
     * }
     */
    public static void class_setVersion(MemorySegment cls, int version) {
        var mh$ = class_setVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setVersion", cls, version);
            }
            mh$.invokeExact(cls, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getInstanceSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getInstanceSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getInstanceSize$descriptor() {
        return class_getInstanceSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getInstanceSize$handle() {
        return class_getInstanceSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getInstanceSize$address() {
        return class_getInstanceSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t class_getInstanceSize(Class  _Nullable cls)
     * }
     */
    public static long class_getInstanceSize(MemorySegment cls) {
        var mh$ = class_getInstanceSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getInstanceSize", cls);
            }
            return (long)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getInstanceVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getInstanceVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getInstanceVariable$descriptor() {
        return class_getInstanceVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MethodHandle class_getInstanceVariable$handle() {
        return class_getInstanceVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceVariable$address() {
        return class_getInstanceVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getInstanceVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceVariable(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getInstanceVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getInstanceVariable", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getClassVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getClassVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getClassVariable$descriptor() {
        return class_getClassVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MethodHandle class_getClassVariable$handle() {
        return class_getClassVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassVariable$address() {
        return class_getClassVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nullable class_getClassVariable(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassVariable(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getClassVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getClassVariable", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyIvarList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyIvarList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyIvarList$descriptor() {
        return class_copyIvarList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyIvarList$handle() {
        return class_copyIvarList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyIvarList$address() {
        return class_copyIvarList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Ivar  _Nonnull * _Nullable class_copyIvarList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyIvarList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyIvarList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyIvarList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getInstanceMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getInstanceMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getInstanceMethod$descriptor() {
        return class_getInstanceMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getInstanceMethod$handle() {
        return class_getInstanceMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceMethod$address() {
        return class_getInstanceMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Method  _Nullable class_getInstanceMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getInstanceMethod(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getInstanceMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getInstanceMethod", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getClassMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getClassMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getClassMethod$descriptor() {
        return class_getClassMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getClassMethod$handle() {
        return class_getClassMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassMethod$address() {
        return class_getClassMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Method  _Nullable class_getClassMethod(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getClassMethod(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getClassMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getClassMethod", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getMethodImplementation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getMethodImplementation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getMethodImplementation$descriptor() {
        return class_getMethodImplementation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getMethodImplementation$handle() {
        return class_getMethodImplementation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation$address() {
        return class_getMethodImplementation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getMethodImplementation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getMethodImplementation", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getMethodImplementation_stret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getMethodImplementation_stret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getMethodImplementation_stret$descriptor() {
        return class_getMethodImplementation_stret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MethodHandle class_getMethodImplementation_stret$handle() {
        return class_getMethodImplementation_stret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation_stret$address() {
        return class_getMethodImplementation_stret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_getMethodImplementation_stret(Class  _Nullable cls, SEL  _Nonnull name)
     * }
     */
    public static MemorySegment class_getMethodImplementation_stret(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getMethodImplementation_stret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getMethodImplementation_stret", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_respondsToSelector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_respondsToSelector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor class_respondsToSelector$descriptor() {
        return class_respondsToSelector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle class_respondsToSelector$handle() {
        return class_respondsToSelector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_respondsToSelector$address() {
        return class_respondsToSelector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_respondsToSelector(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static boolean class_respondsToSelector(MemorySegment cls, MemorySegment sel) {
        var mh$ = class_respondsToSelector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_respondsToSelector", cls, sel);
            }
            return (boolean)mh$.invokeExact(cls, sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyMethodList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyMethodList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyMethodList$descriptor() {
        return class_copyMethodList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyMethodList$handle() {
        return class_copyMethodList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyMethodList$address() {
        return class_copyMethodList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Method  _Nonnull * _Nullable class_copyMethodList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyMethodList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyMethodList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyMethodList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_conformsToProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_conformsToProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static FunctionDescriptor class_conformsToProtocol$descriptor() {
        return class_conformsToProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static MethodHandle class_conformsToProtocol$handle() {
        return class_conformsToProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static MemorySegment class_conformsToProtocol$address() {
        return class_conformsToProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_conformsToProtocol(Class  _Nullable cls, Protocol * _Nullable protocol)
     * }
     */
    public static boolean class_conformsToProtocol(MemorySegment cls, MemorySegment protocol) {
        var mh$ = class_conformsToProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_conformsToProtocol", cls, protocol);
            }
            return (boolean)mh$.invokeExact(cls, protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyProtocolList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyProtocolList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyProtocolList$descriptor() {
        return class_copyProtocolList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyProtocolList$handle() {
        return class_copyProtocolList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyProtocolList$address() {
        return class_copyProtocolList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable class_copyProtocolList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyProtocolList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyProtocolList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyProtocolList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor class_getProperty$descriptor() {
        return class_getProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MethodHandle class_getProperty$handle() {
        return class_getProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getProperty$address() {
        return class_getProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable class_getProperty(Class  _Nullable cls, const char * _Nonnull name)
     * }
     */
    public static MemorySegment class_getProperty(MemorySegment cls, MemorySegment name) {
        var mh$ = class_getProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getProperty", cls, name);
            }
            return (MemorySegment)mh$.invokeExact(cls, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_copyPropertyList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_copyPropertyList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor class_copyPropertyList$descriptor() {
        return class_copyPropertyList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle class_copyPropertyList$handle() {
        return class_copyPropertyList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyPropertyList$address() {
        return class_copyPropertyList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable class_copyPropertyList(Class  _Nullable cls, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment class_copyPropertyList(MemorySegment cls, MemorySegment outCount) {
        var mh$ = class_copyPropertyList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_copyPropertyList", cls, outCount);
            }
            return (MemorySegment)mh$.invokeExact(cls, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getIvarLayout$descriptor() {
        return class_getIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getIvarLayout$handle() {
        return class_getIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getIvarLayout$address() {
        return class_getIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getIvarLayout(MemorySegment cls) {
        var mh$ = class_getIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getIvarLayout", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getWeakIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getWeakIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getWeakIvarLayout$descriptor() {
        return class_getWeakIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getWeakIvarLayout$handle() {
        return class_getWeakIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getWeakIvarLayout$address() {
        return class_getWeakIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const uint8_t * _Nullable class_getWeakIvarLayout(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getWeakIvarLayout(MemorySegment cls) {
        var mh$ = class_getWeakIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getWeakIvarLayout", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static FunctionDescriptor class_addMethod$descriptor() {
        return class_addMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MethodHandle class_addMethod$handle() {
        return class_addMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_addMethod$address() {
        return class_addMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static boolean class_addMethod(MemorySegment cls, MemorySegment name, MemorySegment imp, MemorySegment types) {
        var mh$ = class_addMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addMethod", cls, name, imp, types);
            }
            return (boolean)mh$.invokeExact(cls, name, imp, types);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_replaceMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_replaceMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static FunctionDescriptor class_replaceMethod$descriptor() {
        return class_replaceMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MethodHandle class_replaceMethod$handle() {
        return class_replaceMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_replaceMethod$address() {
        return class_replaceMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_replaceMethod(Class  _Nullable cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_replaceMethod(MemorySegment cls, MemorySegment name, MemorySegment imp, MemorySegment types) {
        var mh$ = class_replaceMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_replaceMethod", cls, name, imp, types);
            }
            return (MemorySegment)mh$.invokeExact(cls, name, imp, types);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addIvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_CHAR,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addIvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static FunctionDescriptor class_addIvar$descriptor() {
        return class_addIvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static MethodHandle class_addIvar$handle() {
        return class_addIvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static MemorySegment class_addIvar$address() {
        return class_addIvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addIvar(Class  _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types)
     * }
     */
    public static boolean class_addIvar(MemorySegment cls, MemorySegment name, long size, byte alignment, MemorySegment types) {
        var mh$ = class_addIvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addIvar", cls, name, size, alignment, types);
            }
            return (boolean)mh$.invokeExact(cls, name, size, alignment, types);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static FunctionDescriptor class_addProtocol$descriptor() {
        return class_addProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static MethodHandle class_addProtocol$handle() {
        return class_addProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static MemorySegment class_addProtocol$address() {
        return class_addProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addProtocol(Class  _Nullable cls, Protocol * _Nonnull protocol)
     * }
     */
    public static boolean class_addProtocol(MemorySegment cls, MemorySegment protocol) {
        var mh$ = class_addProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addProtocol", cls, protocol);
            }
            return (boolean)mh$.invokeExact(cls, protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_addProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_addProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static FunctionDescriptor class_addProperty$descriptor() {
        return class_addProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MethodHandle class_addProperty$handle() {
        return class_addProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MemorySegment class_addProperty$address() {
        return class_addProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_addProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static boolean class_addProperty(MemorySegment cls, MemorySegment name, MemorySegment attributes, int attributeCount) {
        var mh$ = class_addProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_addProperty", cls, name, attributes, attributeCount);
            }
            return (boolean)mh$.invokeExact(cls, name, attributes, attributeCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_replaceProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_replaceProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static FunctionDescriptor class_replaceProperty$descriptor() {
        return class_replaceProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MethodHandle class_replaceProperty$handle() {
        return class_replaceProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static MemorySegment class_replaceProperty$address() {
        return class_replaceProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_replaceProperty(Class  _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)
     * }
     */
    public static void class_replaceProperty(MemorySegment cls, MemorySegment name, MemorySegment attributes, int attributeCount) {
        var mh$ = class_replaceProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_replaceProperty", cls, name, attributes, attributeCount);
            }
            mh$.invokeExact(cls, name, attributes, attributeCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static FunctionDescriptor class_setIvarLayout$descriptor() {
        return class_setIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MethodHandle class_setIvarLayout$handle() {
        return class_setIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MemorySegment class_setIvarLayout$address() {
        return class_setIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_setIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static void class_setIvarLayout(MemorySegment cls, MemorySegment layout) {
        var mh$ = class_setIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setIvarLayout", cls, layout);
            }
            mh$.invokeExact(cls, layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_setWeakIvarLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_setWeakIvarLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static FunctionDescriptor class_setWeakIvarLayout$descriptor() {
        return class_setWeakIvarLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MethodHandle class_setWeakIvarLayout$handle() {
        return class_setWeakIvarLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static MemorySegment class_setWeakIvarLayout$address() {
        return class_setWeakIvarLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void class_setWeakIvarLayout(Class  _Nullable cls, const uint8_t * _Nullable layout)
     * }
     */
    public static void class_setWeakIvarLayout(MemorySegment cls, MemorySegment layout) {
        var mh$ = class_setWeakIvarLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_setWeakIvarLayout", cls, layout);
            }
            mh$.invokeExact(cls, layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getFutureClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getFutureClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getFutureClass$descriptor() {
        return objc_getFutureClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getFutureClass$handle() {
        return objc_getFutureClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getFutureClass$address() {
        return objc_getFutureClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_getFutureClass(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getFutureClass(MemorySegment name) {
        var mh$ = objc_getFutureClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getFutureClass", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_createInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_createInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static FunctionDescriptor class_createInstance$descriptor() {
        return class_createInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static MethodHandle class_createInstance$handle() {
        return class_createInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static MemorySegment class_createInstance$address() {
        return class_createInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstance(Class  _Nullable cls, size_t extraBytes)
     * }
     */
    public static MemorySegment class_createInstance(MemorySegment cls, long extraBytes) {
        var mh$ = class_createInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_createInstance", cls, extraBytes);
            }
            return (MemorySegment)mh$.invokeExact(cls, extraBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_constructInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_constructInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static FunctionDescriptor objc_constructInstance$descriptor() {
        return objc_constructInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static MethodHandle objc_constructInstance$handle() {
        return objc_constructInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static MemorySegment objc_constructInstance$address() {
        return objc_constructInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_constructInstance(Class  _Nullable cls, void * _Nullable bytes)
     * }
     */
    public static MemorySegment objc_constructInstance(MemorySegment cls, MemorySegment bytes) {
        var mh$ = objc_constructInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_constructInstance", cls, bytes);
            }
            return (MemorySegment)mh$.invokeExact(cls, bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_destructInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_destructInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_destructInstance$descriptor() {
        return objc_destructInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static MethodHandle objc_destructInstance$handle() {
        return objc_destructInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_destructInstance$address() {
        return objc_destructInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable objc_destructInstance(id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_destructInstance(MemorySegment obj) {
        var mh$ = objc_destructInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_destructInstance", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_allocateClassPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_allocateClassPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static FunctionDescriptor objc_allocateClassPair$descriptor() {
        return objc_allocateClassPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MethodHandle objc_allocateClassPair$handle() {
        return objc_allocateClassPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_allocateClassPair$address() {
        return objc_allocateClassPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable objc_allocateClassPair(Class  _Nullable superclass, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_allocateClassPair(MemorySegment superclass, MemorySegment name, long extraBytes) {
        var mh$ = objc_allocateClassPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_allocateClassPair", superclass, name, extraBytes);
            }
            return (MemorySegment)mh$.invokeExact(superclass, name, extraBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_registerClassPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_registerClassPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static FunctionDescriptor objc_registerClassPair$descriptor() {
        return objc_registerClassPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static MethodHandle objc_registerClassPair$handle() {
        return objc_registerClassPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static MemorySegment objc_registerClassPair$address() {
        return objc_registerClassPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_registerClassPair(Class  _Nonnull cls)
     * }
     */
    public static void objc_registerClassPair(MemorySegment cls) {
        var mh$ = objc_registerClassPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_registerClassPair", cls);
            }
            mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_duplicateClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_duplicateClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static FunctionDescriptor objc_duplicateClass$descriptor() {
        return objc_duplicateClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MethodHandle objc_duplicateClass$handle() {
        return objc_duplicateClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_duplicateClass$address() {
        return objc_duplicateClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nonnull objc_duplicateClass(Class  _Nonnull original, const char * _Nonnull name, size_t extraBytes)
     * }
     */
    public static MemorySegment objc_duplicateClass(MemorySegment original, MemorySegment name, long extraBytes) {
        var mh$ = objc_duplicateClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_duplicateClass", original, name, extraBytes);
            }
            return (MemorySegment)mh$.invokeExact(original, name, extraBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_disposeClassPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_disposeClassPair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static FunctionDescriptor objc_disposeClassPair$descriptor() {
        return objc_disposeClassPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static MethodHandle objc_disposeClassPair$handle() {
        return objc_disposeClassPair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static MemorySegment objc_disposeClassPair$address() {
        return objc_disposeClassPair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_disposeClassPair(Class  _Nonnull cls)
     * }
     */
    public static void objc_disposeClassPair(MemorySegment cls) {
        var mh$ = objc_disposeClassPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_disposeClassPair", cls);
            }
            mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getName$descriptor() {
        return method_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getName$handle() {
        return method_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getName$address() {
        return method_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern SEL  _Nonnull method_getName(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getName(MemorySegment m) {
        var mh$ = method_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getName", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getImplementation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getImplementation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getImplementation$descriptor() {
        return method_getImplementation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getImplementation$handle() {
        return method_getImplementation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getImplementation$address() {
        return method_getImplementation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_getImplementation(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getImplementation(MemorySegment m) {
        var mh$ = method_getImplementation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getImplementation", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getTypeEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getTypeEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getTypeEncoding$descriptor() {
        return method_getTypeEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getTypeEncoding$handle() {
        return method_getTypeEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getTypeEncoding$address() {
        return method_getTypeEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable method_getTypeEncoding(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getTypeEncoding(MemorySegment m) {
        var mh$ = method_getTypeEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getTypeEncoding", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getNumberOfArguments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getNumberOfArguments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getNumberOfArguments$descriptor() {
        return method_getNumberOfArguments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getNumberOfArguments$handle() {
        return method_getNumberOfArguments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getNumberOfArguments$address() {
        return method_getNumberOfArguments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int method_getNumberOfArguments(Method  _Nonnull m)
     * }
     */
    public static int method_getNumberOfArguments(MemorySegment m) {
        var mh$ = method_getNumberOfArguments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getNumberOfArguments", m);
            }
            return (int)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_copyReturnType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_copyReturnType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_copyReturnType$descriptor() {
        return method_copyReturnType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_copyReturnType$handle() {
        return method_copyReturnType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_copyReturnType$address() {
        return method_copyReturnType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char * _Nonnull method_copyReturnType(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_copyReturnType(MemorySegment m) {
        var mh$ = method_copyReturnType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_copyReturnType", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_copyArgumentType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_copyArgumentType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static FunctionDescriptor method_copyArgumentType$descriptor() {
        return method_copyArgumentType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static MethodHandle method_copyArgumentType$handle() {
        return method_copyArgumentType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static MemorySegment method_copyArgumentType$address() {
        return method_copyArgumentType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char * _Nullable method_copyArgumentType(Method  _Nonnull m, unsigned int index)
     * }
     */
    public static MemorySegment method_copyArgumentType(MemorySegment m, int index) {
        var mh$ = method_copyArgumentType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_copyArgumentType", m, index);
            }
            return (MemorySegment)mh$.invokeExact(m, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getReturnType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getReturnType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static FunctionDescriptor method_getReturnType$descriptor() {
        return method_getReturnType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static MethodHandle method_getReturnType$handle() {
        return method_getReturnType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static MemorySegment method_getReturnType$address() {
        return method_getReturnType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_getReturnType(Method  _Nonnull m, char * _Nonnull dst, size_t dst_len)
     * }
     */
    public static void method_getReturnType(MemorySegment m, MemorySegment dst, long dst_len) {
        var mh$ = method_getReturnType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getReturnType", m, dst, dst_len);
            }
            mh$.invokeExact(m, dst, dst_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getArgumentType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getArgumentType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static FunctionDescriptor method_getArgumentType$descriptor() {
        return method_getArgumentType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static MethodHandle method_getArgumentType$handle() {
        return method_getArgumentType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static MemorySegment method_getArgumentType$address() {
        return method_getArgumentType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_getArgumentType(Method  _Nonnull m, unsigned int index, char * _Nullable dst, size_t dst_len)
     * }
     */
    public static void method_getArgumentType(MemorySegment m, int index, MemorySegment dst, long dst_len) {
        var mh$ = method_getArgumentType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getArgumentType", m, index, dst, dst_len);
            }
            mh$.invokeExact(m, index, dst, dst_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_getDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_getDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static FunctionDescriptor method_getDescription$descriptor() {
        return method_getDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static MethodHandle method_getDescription$handle() {
        return method_getDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getDescription$address() {
        return method_getDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nonnull method_getDescription(Method  _Nonnull m)
     * }
     */
    public static MemorySegment method_getDescription(MemorySegment m) {
        var mh$ = method_getDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_getDescription", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_setImplementation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_setImplementation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static FunctionDescriptor method_setImplementation$descriptor() {
        return method_setImplementation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static MethodHandle method_setImplementation$handle() {
        return method_setImplementation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static MemorySegment method_setImplementation$address() {
        return method_setImplementation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nonnull method_setImplementation(Method  _Nonnull m, IMP  _Nonnull imp)
     * }
     */
    public static MemorySegment method_setImplementation(MemorySegment m, MemorySegment imp) {
        var mh$ = method_setImplementation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_setImplementation", m, imp);
            }
            return (MemorySegment)mh$.invokeExact(m, imp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_exchangeImplementations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_exchangeImplementations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static FunctionDescriptor method_exchangeImplementations$descriptor() {
        return method_exchangeImplementations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static MethodHandle method_exchangeImplementations$handle() {
        return method_exchangeImplementations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static MemorySegment method_exchangeImplementations$address() {
        return method_exchangeImplementations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_exchangeImplementations(Method  _Nonnull m1, Method  _Nonnull m2)
     * }
     */
    public static void method_exchangeImplementations(MemorySegment m1, MemorySegment m2) {
        var mh$ = method_exchangeImplementations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_exchangeImplementations", m1, m2);
            }
            mh$.invokeExact(m1, m2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ivar_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ivar_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static FunctionDescriptor ivar_getName$descriptor() {
        return ivar_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static MethodHandle ivar_getName$handle() {
        return ivar_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getName$address() {
        return ivar_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getName(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getName(MemorySegment v) {
        var mh$ = ivar_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ivar_getName", v);
            }
            return (MemorySegment)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ivar_getTypeEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ivar_getTypeEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static FunctionDescriptor ivar_getTypeEncoding$descriptor() {
        return ivar_getTypeEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static MethodHandle ivar_getTypeEncoding$handle() {
        return ivar_getTypeEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getTypeEncoding$address() {
        return ivar_getTypeEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable ivar_getTypeEncoding(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getTypeEncoding(MemorySegment v) {
        var mh$ = ivar_getTypeEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ivar_getTypeEncoding", v);
            }
            return (MemorySegment)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ivar_getOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("ivar_getOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static FunctionDescriptor ivar_getOffset$descriptor() {
        return ivar_getOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static MethodHandle ivar_getOffset$handle() {
        return ivar_getOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static MemorySegment ivar_getOffset$address() {
        return ivar_getOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ptrdiff_t ivar_getOffset(Ivar  _Nonnull v)
     * }
     */
    public static long ivar_getOffset(MemorySegment v) {
        var mh$ = ivar_getOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ivar_getOffset", v);
            }
            return (long)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static FunctionDescriptor property_getName$descriptor() {
        return property_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static MethodHandle property_getName$handle() {
        return property_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getName$address() {
        return property_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull property_getName(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getName(MemorySegment property) {
        var mh$ = property_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_getName", property);
            }
            return (MemorySegment)mh$.invokeExact(property);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_getAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_getAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static FunctionDescriptor property_getAttributes$descriptor() {
        return property_getAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static MethodHandle property_getAttributes$handle() {
        return property_getAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getAttributes$address() {
        return property_getAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable property_getAttributes(objc_property_t  _Nonnull property)
     * }
     */
    public static MemorySegment property_getAttributes(MemorySegment property) {
        var mh$ = property_getAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_getAttributes", property);
            }
            return (MemorySegment)mh$.invokeExact(property);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_copyAttributeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_copyAttributeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor property_copyAttributeList$descriptor() {
        return property_copyAttributeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle property_copyAttributeList$handle() {
        return property_copyAttributeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment property_copyAttributeList$address() {
        return property_copyAttributeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t  _Nonnull property, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment property_copyAttributeList(MemorySegment property, MemorySegment outCount) {
        var mh$ = property_copyAttributeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_copyAttributeList", property, outCount);
            }
            return (MemorySegment)mh$.invokeExact(property, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class property_copyAttributeValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("property_copyAttributeValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static FunctionDescriptor property_copyAttributeValue$descriptor() {
        return property_copyAttributeValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static MethodHandle property_copyAttributeValue$handle() {
        return property_copyAttributeValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static MemorySegment property_copyAttributeValue$address() {
        return property_copyAttributeValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char * _Nullable property_copyAttributeValue(objc_property_t  _Nonnull property, const char * _Nonnull attributeName)
     * }
     */
    public static MemorySegment property_copyAttributeValue(MemorySegment property, MemorySegment attributeName) {
        var mh$ = property_copyAttributeValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("property_copyAttributeValue", property, attributeName);
            }
            return (MemorySegment)mh$.invokeExact(property, attributeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_getProtocol$descriptor() {
        return objc_getProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_getProtocol$handle() {
        return objc_getProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getProtocol$address() {
        return objc_getProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_getProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_getProtocol(MemorySegment name) {
        var mh$ = objc_getProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getProtocol", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyProtocolList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyProtocolList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyProtocolList$descriptor() {
        return objc_copyProtocolList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyProtocolList$handle() {
        return objc_copyProtocolList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyProtocolList$address() {
        return objc_copyProtocolList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyProtocolList(MemorySegment outCount) {
        var mh$ = objc_copyProtocolList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyProtocolList", outCount);
            }
            return (MemorySegment)mh$.invokeExact(outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_conformsToProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_conformsToProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static FunctionDescriptor protocol_conformsToProtocol$descriptor() {
        return protocol_conformsToProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MethodHandle protocol_conformsToProtocol$handle() {
        return protocol_conformsToProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MemorySegment protocol_conformsToProtocol$address() {
        return protocol_conformsToProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static boolean protocol_conformsToProtocol(MemorySegment proto, MemorySegment other) {
        var mh$ = protocol_conformsToProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_conformsToProtocol", proto, other);
            }
            return (boolean)mh$.invokeExact(proto, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_isEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_isEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static FunctionDescriptor protocol_isEqual$descriptor() {
        return protocol_isEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MethodHandle protocol_isEqual$handle() {
        return protocol_isEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static MemorySegment protocol_isEqual$address() {
        return protocol_isEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other)
     * }
     */
    public static boolean protocol_isEqual(MemorySegment proto, MemorySegment other) {
        var mh$ = protocol_isEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_isEqual", proto, other);
            }
            return (boolean)mh$.invokeExact(proto, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_getName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_getName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static FunctionDescriptor protocol_getName$descriptor() {
        return protocol_getName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static MethodHandle protocol_getName$handle() {
        return protocol_getName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static MemorySegment protocol_getName$address() {
        return protocol_getName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull protocol_getName(Protocol * _Nonnull proto)
     * }
     */
    public static MemorySegment protocol_getName(MemorySegment proto) {
        var mh$ = protocol_getName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_getName", proto);
            }
            return (MemorySegment)mh$.invokeExact(proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_getMethodDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            objc_method_description.layout(),
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_getMethodDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static FunctionDescriptor protocol_getMethodDescription$descriptor() {
        return protocol_getMethodDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MethodHandle protocol_getMethodDescription$handle() {
        return protocol_getMethodDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MemorySegment protocol_getMethodDescription$address() {
        return protocol_getMethodDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MemorySegment protocol_getMethodDescription(SegmentAllocator allocator, MemorySegment proto, MemorySegment aSel, boolean isRequiredMethod, boolean isInstanceMethod) {
        var mh$ = protocol_getMethodDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_getMethodDescription", allocator, proto, aSel, isRequiredMethod, isInstanceMethod);
            }
            return (MemorySegment)mh$.invokeExact(allocator, proto, aSel, isRequiredMethod, isInstanceMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyMethodDescriptionList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyMethodDescriptionList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor protocol_copyMethodDescriptionList$descriptor() {
        return protocol_copyMethodDescriptionList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle protocol_copyMethodDescriptionList$handle() {
        return protocol_copyMethodDescriptionList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyMethodDescriptionList$address() {
        return protocol_copyMethodDescriptionList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyMethodDescriptionList(MemorySegment proto, boolean isRequiredMethod, boolean isInstanceMethod, MemorySegment outCount) {
        var mh$ = protocol_copyMethodDescriptionList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyMethodDescriptionList", proto, isRequiredMethod, isInstanceMethod, outCount);
            }
            return (MemorySegment)mh$.invokeExact(proto, isRequiredMethod, isInstanceMethod, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_getProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_getProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static FunctionDescriptor protocol_getProperty$descriptor() {
        return protocol_getProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MethodHandle protocol_getProperty$handle() {
        return protocol_getProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_getProperty$address() {
        return protocol_getProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nullable protocol_getProperty(Protocol * _Nonnull proto, const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_getProperty(MemorySegment proto, MemorySegment name, boolean isRequiredProperty, boolean isInstanceProperty) {
        var mh$ = protocol_getProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_getProperty", proto, name, isRequiredProperty, isInstanceProperty);
            }
            return (MemorySegment)mh$.invokeExact(proto, name, isRequiredProperty, isInstanceProperty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyPropertyList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyPropertyList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor protocol_copyPropertyList$descriptor() {
        return protocol_copyPropertyList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle protocol_copyPropertyList$handle() {
        return protocol_copyPropertyList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyPropertyList$address() {
        return protocol_copyPropertyList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyPropertyList(MemorySegment proto, MemorySegment outCount) {
        var mh$ = protocol_copyPropertyList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyPropertyList", proto, outCount);
            }
            return (MemorySegment)mh$.invokeExact(proto, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyPropertyList2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyPropertyList2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static FunctionDescriptor protocol_copyPropertyList2$descriptor() {
        return protocol_copyPropertyList2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MethodHandle protocol_copyPropertyList2$handle() {
        return protocol_copyPropertyList2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_copyPropertyList2$address() {
        return protocol_copyPropertyList2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_property_t  _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto, unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_copyPropertyList2(MemorySegment proto, MemorySegment outCount, boolean isRequiredProperty, boolean isInstanceProperty) {
        var mh$ = protocol_copyPropertyList2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyPropertyList2", proto, outCount, isRequiredProperty, isInstanceProperty);
            }
            return (MemorySegment)mh$.invokeExact(proto, outCount, isRequiredProperty, isInstanceProperty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_copyProtocolList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_copyProtocolList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor protocol_copyProtocolList$descriptor() {
        return protocol_copyProtocolList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle protocol_copyProtocolList$handle() {
        return protocol_copyProtocolList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyProtocolList$address() {
        return protocol_copyProtocolList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment protocol_copyProtocolList(MemorySegment proto, MemorySegment outCount) {
        var mh$ = protocol_copyProtocolList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_copyProtocolList", proto, outCount);
            }
            return (MemorySegment)mh$.invokeExact(proto, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_allocateProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_allocateProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static FunctionDescriptor objc_allocateProtocol$descriptor() {
        return objc_allocateProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static MethodHandle objc_allocateProtocol$handle() {
        return objc_allocateProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_allocateProtocol$address() {
        return objc_allocateProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name)
     * }
     */
    public static MemorySegment objc_allocateProtocol(MemorySegment name) {
        var mh$ = objc_allocateProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_allocateProtocol", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_registerProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_registerProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static FunctionDescriptor objc_registerProtocol$descriptor() {
        return objc_registerProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static MethodHandle objc_registerProtocol$handle() {
        return objc_registerProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static MemorySegment objc_registerProtocol$address() {
        return objc_registerProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_registerProtocol(Protocol * _Nonnull proto)
     * }
     */
    public static void objc_registerProtocol(MemorySegment proto) {
        var mh$ = objc_registerProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_registerProtocol", proto);
            }
            mh$.invokeExact(proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_addMethodDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_addMethodDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static FunctionDescriptor protocol_addMethodDescription$descriptor() {
        return protocol_addMethodDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MethodHandle protocol_addMethodDescription$handle() {
        return protocol_addMethodDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static MemorySegment protocol_addMethodDescription$address() {
        return protocol_addMethodDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL  _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod)
     * }
     */
    public static void protocol_addMethodDescription(MemorySegment proto, MemorySegment name, MemorySegment types, boolean isRequiredMethod, boolean isInstanceMethod) {
        var mh$ = protocol_addMethodDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_addMethodDescription", proto, name, types, isRequiredMethod, isInstanceMethod);
            }
            mh$.invokeExact(proto, name, types, isRequiredMethod, isInstanceMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_addProtocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_addProtocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static FunctionDescriptor protocol_addProtocol$descriptor() {
        return protocol_addProtocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static MethodHandle protocol_addProtocol$handle() {
        return protocol_addProtocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static MemorySegment protocol_addProtocol$address() {
        return protocol_addProtocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition)
     * }
     */
    public static void protocol_addProtocol(MemorySegment proto, MemorySegment addition) {
        var mh$ = protocol_addProtocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_addProtocol", proto, addition);
            }
            mh$.invokeExact(proto, addition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class protocol_addProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_BOOL
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("protocol_addProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static FunctionDescriptor protocol_addProperty$descriptor() {
        return protocol_addProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MethodHandle protocol_addProperty$handle() {
        return protocol_addProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static MemorySegment protocol_addProperty$address() {
        return protocol_addProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty)
     * }
     */
    public static void protocol_addProperty(MemorySegment proto, MemorySegment name, MemorySegment attributes, int attributeCount, boolean isRequiredProperty, boolean isInstanceProperty) {
        var mh$ = protocol_addProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("protocol_addProperty", proto, name, attributes, attributeCount, isRequiredProperty, isInstanceProperty);
            }
            mh$.invokeExact(proto, name, attributes, attributeCount, isRequiredProperty, isInstanceProperty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyImageNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyImageNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyImageNames$descriptor() {
        return objc_copyImageNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyImageNames$handle() {
        return objc_copyImageNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyImageNames$address() {
        return objc_copyImageNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyImageNames(MemorySegment outCount) {
        var mh$ = objc_copyImageNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyImageNames", outCount);
            }
            return (MemorySegment)mh$.invokeExact(outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_getImageName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_getImageName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor class_getImageName$descriptor() {
        return class_getImageName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static MethodHandle class_getImageName$handle() {
        return class_getImageName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getImageName$address() {
        return class_getImageName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nullable class_getImageName(Class  _Nullable cls)
     * }
     */
    public static MemorySegment class_getImageName(MemorySegment cls) {
        var mh$ = class_getImageName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_getImageName", cls);
            }
            return (MemorySegment)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_copyClassNamesForImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_copyClassNamesForImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static FunctionDescriptor objc_copyClassNamesForImage$descriptor() {
        return objc_copyClassNamesForImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static MethodHandle objc_copyClassNamesForImage$handle() {
        return objc_copyClassNamesForImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassNamesForImage$address() {
        return objc_copyClassNamesForImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount)
     * }
     */
    public static MemorySegment objc_copyClassNamesForImage(MemorySegment image, MemorySegment outCount) {
        var mh$ = objc_copyClassNamesForImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_copyClassNamesForImage", image, outCount);
            }
            return (MemorySegment)mh$.invokeExact(image, outCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sel_isEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("sel_isEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static FunctionDescriptor sel_isEqual$descriptor() {
        return sel_isEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static MethodHandle sel_isEqual$handle() {
        return sel_isEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static MemorySegment sel_isEqual$address() {
        return sel_isEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL sel_isEqual(SEL  _Nonnull lhs, SEL  _Nonnull rhs)
     * }
     */
    public static boolean sel_isEqual(MemorySegment lhs, MemorySegment rhs) {
        var mh$ = sel_isEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sel_isEqual", lhs, rhs);
            }
            return (boolean)mh$.invokeExact(lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_enumerationMutation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_enumerationMutation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static FunctionDescriptor objc_enumerationMutation$descriptor() {
        return objc_enumerationMutation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static MethodHandle objc_enumerationMutation$handle() {
        return objc_enumerationMutation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static MemorySegment objc_enumerationMutation$address() {
        return objc_enumerationMutation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_enumerationMutation(id  _Nonnull obj)
     * }
     */
    public static void objc_enumerationMutation(MemorySegment obj) {
        var mh$ = objc_enumerationMutation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_enumerationMutation", obj);
            }
            mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setEnumerationMutationHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setEnumerationMutationHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static FunctionDescriptor objc_setEnumerationMutationHandler$descriptor() {
        return objc_setEnumerationMutationHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static MethodHandle objc_setEnumerationMutationHandler$handle() {
        return objc_setEnumerationMutationHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static MemorySegment objc_setEnumerationMutationHandler$address() {
        return objc_setEnumerationMutationHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setEnumerationMutationHandler(void (* _Nullable handler)(id _Nonnull))
     * }
     */
    public static void objc_setEnumerationMutationHandler(MemorySegment handler) {
        var mh$ = objc_setEnumerationMutationHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setEnumerationMutationHandler", handler);
            }
            mh$.invokeExact(handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setForwardHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setForwardHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static FunctionDescriptor objc_setForwardHandler$descriptor() {
        return objc_setForwardHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static MethodHandle objc_setForwardHandler$handle() {
        return objc_setForwardHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static MemorySegment objc_setForwardHandler$address() {
        return objc_setForwardHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret)
     * }
     */
    public static void objc_setForwardHandler(MemorySegment fwd, MemorySegment fwd_stret) {
        var mh$ = objc_setForwardHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setForwardHandler", fwd, fwd_stret);
            }
            mh$.invokeExact(fwd, fwd_stret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imp_implementationWithBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("imp_implementationWithBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static FunctionDescriptor imp_implementationWithBlock$descriptor() {
        return imp_implementationWithBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static MethodHandle imp_implementationWithBlock$handle() {
        return imp_implementationWithBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static MemorySegment imp_implementationWithBlock$address() {
        return imp_implementationWithBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nonnull imp_implementationWithBlock(id  _Nonnull block)
     * }
     */
    public static MemorySegment imp_implementationWithBlock(MemorySegment block) {
        var mh$ = imp_implementationWithBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imp_implementationWithBlock", block);
            }
            return (MemorySegment)mh$.invokeExact(block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imp_getBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("imp_getBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static FunctionDescriptor imp_getBlock$descriptor() {
        return imp_getBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MethodHandle imp_getBlock$handle() {
        return imp_getBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MemorySegment imp_getBlock$address() {
        return imp_getBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable imp_getBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MemorySegment imp_getBlock(MemorySegment anImp) {
        var mh$ = imp_getBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imp_getBlock", anImp);
            }
            return (MemorySegment)mh$.invokeExact(anImp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imp_removeBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("imp_removeBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static FunctionDescriptor imp_removeBlock$descriptor() {
        return imp_removeBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MethodHandle imp_removeBlock$handle() {
        return imp_removeBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static MemorySegment imp_removeBlock$address() {
        return imp_removeBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL imp_removeBlock(IMP  _Nonnull anImp)
     * }
     */
    public static boolean imp_removeBlock(MemorySegment anImp) {
        var mh$ = imp_removeBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imp_removeBlock", anImp);
            }
            return (boolean)mh$.invokeExact(anImp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_loadWeak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_loadWeak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static FunctionDescriptor objc_loadWeak$descriptor() {
        return objc_loadWeak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static MethodHandle objc_loadWeak$handle() {
        return objc_loadWeak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static MemorySegment objc_loadWeak$address() {
        return objc_loadWeak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_loadWeak(id  _Nullable * _Nonnull location)
     * }
     */
    public static MemorySegment objc_loadWeak(MemorySegment location) {
        var mh$ = objc_loadWeak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_loadWeak", location);
            }
            return (MemorySegment)mh$.invokeExact(location);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_storeWeak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_storeWeak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static FunctionDescriptor objc_storeWeak$descriptor() {
        return objc_storeWeak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static MethodHandle objc_storeWeak$handle() {
        return objc_storeWeak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_storeWeak$address() {
        return objc_storeWeak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_storeWeak(id  _Nullable * _Nonnull location, id  _Nullable obj)
     * }
     */
    public static MemorySegment objc_storeWeak(MemorySegment location, MemorySegment obj) {
        var mh$ = objc_storeWeak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_storeWeak", location, obj);
            }
            return (MemorySegment)mh$.invokeExact(location, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uintptr_t objc_AssociationPolicy
     * }
     */
    public static final OfLong objc_AssociationPolicy = ObjCRuntime.C_LONG;
    private static final int OBJC_ASSOCIATION_ASSIGN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_ASSIGN = 0
     * }
     */
    public static int OBJC_ASSOCIATION_ASSIGN() {
        return OBJC_ASSOCIATION_ASSIGN;
    }
    private static final int OBJC_ASSOCIATION_RETAIN_NONATOMIC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1
     * }
     */
    public static int OBJC_ASSOCIATION_RETAIN_NONATOMIC() {
        return OBJC_ASSOCIATION_RETAIN_NONATOMIC;
    }
    private static final int OBJC_ASSOCIATION_COPY_NONATOMIC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_COPY_NONATOMIC = 3
     * }
     */
    public static int OBJC_ASSOCIATION_COPY_NONATOMIC() {
        return OBJC_ASSOCIATION_COPY_NONATOMIC;
    }
    private static final int OBJC_ASSOCIATION_RETAIN = (int)769L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_RETAIN = 769
     * }
     */
    public static int OBJC_ASSOCIATION_RETAIN() {
        return OBJC_ASSOCIATION_RETAIN;
    }
    private static final int OBJC_ASSOCIATION_COPY = (int)771L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_ASSOCIATION_COPY = 771
     * }
     */
    public static int OBJC_ASSOCIATION_COPY() {
        return OBJC_ASSOCIATION_COPY;
    }

    private static class objc_setAssociatedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setAssociatedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static FunctionDescriptor objc_setAssociatedObject$descriptor() {
        return objc_setAssociatedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static MethodHandle objc_setAssociatedObject$handle() {
        return objc_setAssociatedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static MemorySegment objc_setAssociatedObject$address() {
        return objc_setAssociatedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setAssociatedObject(id  _Nonnull object, const void * _Nonnull key, id  _Nullable value, objc_AssociationPolicy policy)
     * }
     */
    public static void objc_setAssociatedObject(MemorySegment object, MemorySegment key, MemorySegment value, long policy) {
        var mh$ = objc_setAssociatedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setAssociatedObject", object, key, value, policy);
            }
            mh$.invokeExact(object, key, value, policy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_getAssociatedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_getAssociatedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static FunctionDescriptor objc_getAssociatedObject$descriptor() {
        return objc_getAssociatedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static MethodHandle objc_getAssociatedObject$handle() {
        return objc_getAssociatedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static MemorySegment objc_getAssociatedObject$address() {
        return objc_getAssociatedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable objc_getAssociatedObject(id  _Nonnull object, const void * _Nonnull key)
     * }
     */
    public static MemorySegment objc_getAssociatedObject(MemorySegment object, MemorySegment key) {
        var mh$ = objc_getAssociatedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_getAssociatedObject", object, key);
            }
            return (MemorySegment)mh$.invokeExact(object, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_removeAssociatedObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_removeAssociatedObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static FunctionDescriptor objc_removeAssociatedObjects$descriptor() {
        return objc_removeAssociatedObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static MethodHandle objc_removeAssociatedObjects$handle() {
        return objc_removeAssociatedObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static MemorySegment objc_removeAssociatedObjects$address() {
        return objc_removeAssociatedObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_removeAssociatedObjects(id  _Nonnull object)
     * }
     */
    public static void objc_removeAssociatedObjects(MemorySegment object) {
        var mh$ = objc_removeAssociatedObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_removeAssociatedObjects", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setHook_getImageName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setHook_getImageName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static FunctionDescriptor objc_setHook_getImageName$descriptor() {
        return objc_setHook_getImageName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MethodHandle objc_setHook_getImageName$handle() {
        return objc_setHook_getImageName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MemorySegment objc_setHook_getImageName$address() {
        return objc_setHook_getImageName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setHook_getImageName(objc_hook_getImageName  _Nonnull newValue, objc_hook_getImageName  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static void objc_setHook_getImageName(MemorySegment newValue, MemorySegment outOldValue) {
        var mh$ = objc_setHook_getImageName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setHook_getImageName", newValue, outOldValue);
            }
            mh$.invokeExact(newValue, outOldValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setHook_getClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setHook_getClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static FunctionDescriptor objc_setHook_getClass$descriptor() {
        return objc_setHook_getClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MethodHandle objc_setHook_getClass$handle() {
        return objc_setHook_getClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static MemorySegment objc_setHook_getClass$address() {
        return objc_setHook_getClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setHook_getClass(objc_hook_getClass  _Nonnull newValue, objc_hook_getClass  _Nullable * _Nonnull outOldValue)
     * }
     */
    public static void objc_setHook_getClass(MemorySegment newValue, MemorySegment outOldValue) {
        var mh$ = objc_setHook_getClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setHook_getClass", newValue, outOldValue);
            }
            mh$.invokeExact(newValue, outOldValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_addLoadImageFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_addLoadImageFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static FunctionDescriptor objc_addLoadImageFunc$descriptor() {
        return objc_addLoadImageFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static MethodHandle objc_addLoadImageFunc$handle() {
        return objc_addLoadImageFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static MemorySegment objc_addLoadImageFunc$address() {
        return objc_addLoadImageFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_addLoadImageFunc(objc_func_loadImage  _Nonnull func)
     * }
     */
    public static void objc_addLoadImageFunc(MemorySegment func) {
        var mh$ = objc_addLoadImageFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_addLoadImageFunc", func);
            }
            mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setHook_lazyClassNamer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setHook_lazyClassNamer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static FunctionDescriptor objc_setHook_lazyClassNamer$descriptor() {
        return objc_setHook_lazyClassNamer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static MethodHandle objc_setHook_lazyClassNamer$handle() {
        return objc_setHook_lazyClassNamer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static MemorySegment objc_setHook_lazyClassNamer$address() {
        return objc_setHook_lazyClassNamer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_setHook_lazyClassNamer(objc_hook_lazyClassNamer  _Nonnull newValue, objc_hook_lazyClassNamer  _Nonnull * _Nonnull oldOutValue)
     * }
     */
    public static void objc_setHook_lazyClassNamer(MemorySegment newValue, MemorySegment oldOutValue) {
        var mh$ = objc_setHook_lazyClassNamer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setHook_lazyClassNamer", newValue, oldOutValue);
            }
            mh$.invokeExact(newValue, oldOutValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _objc_realizeClassFromSwift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_objc_realizeClassFromSwift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static FunctionDescriptor _objc_realizeClassFromSwift$descriptor() {
        return _objc_realizeClassFromSwift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static MethodHandle _objc_realizeClassFromSwift$handle() {
        return _objc_realizeClassFromSwift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static MemorySegment _objc_realizeClassFromSwift$address() {
        return _objc_realizeClassFromSwift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Class  _Nullable _objc_realizeClassFromSwift(Class  _Nullable cls, void * _Nullable previously)
     * }
     */
    public static MemorySegment _objc_realizeClassFromSwift(MemorySegment cls, MemorySegment previously) {
        var mh$ = _objc_realizeClassFromSwift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_objc_realizeClassFromSwift", cls, previously);
            }
            return (MemorySegment)mh$.invokeExact(cls, previously);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _objc_flush_caches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_objc_flush_caches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static FunctionDescriptor _objc_flush_caches$descriptor() {
        return _objc_flush_caches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static MethodHandle _objc_flush_caches$handle() {
        return _objc_flush_caches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static MemorySegment _objc_flush_caches$address() {
        return _objc_flush_caches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _objc_flush_caches(Class  _Nullable cls)
     * }
     */
    public static void _objc_flush_caches(MemorySegment cls) {
        var mh$ = _objc_flush_caches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_objc_flush_caches", cls);
            }
            mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_lookupMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_lookupMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor class_lookupMethod$descriptor() {
        return class_lookupMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle class_lookupMethod$handle() {
        return class_lookupMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_lookupMethod$address() {
        return class_lookupMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern IMP  _Nullable class_lookupMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_lookupMethod(MemorySegment cls, MemorySegment sel) {
        var mh$ = class_lookupMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_lookupMethod", cls, sel);
            }
            return (MemorySegment)mh$.invokeExact(cls, sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_respondsToMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_respondsToMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static FunctionDescriptor class_respondsToMethod$descriptor() {
        return class_respondsToMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MethodHandle class_respondsToMethod$handle() {
        return class_respondsToMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static MemorySegment class_respondsToMethod$address() {
        return class_respondsToMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern BOOL class_respondsToMethod(Class  _Nullable cls, SEL  _Nonnull sel)
     * }
     */
    public static boolean class_respondsToMethod(MemorySegment cls, MemorySegment sel) {
        var mh$ = class_respondsToMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_respondsToMethod", cls, sel);
            }
            return (boolean)mh$.invokeExact(cls, sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class object_copyFromZone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("object_copyFromZone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static FunctionDescriptor object_copyFromZone$descriptor() {
        return object_copyFromZone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static MethodHandle object_copyFromZone$handle() {
        return object_copyFromZone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static MemorySegment object_copyFromZone$address() {
        return object_copyFromZone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable object_copyFromZone(id  _Nullable anObject, size_t nBytes, __unused void *zone)
     * }
     */
    public static MemorySegment object_copyFromZone(MemorySegment anObject, long nBytes, MemorySegment zone) {
        var mh$ = object_copyFromZone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("object_copyFromZone", anObject, nBytes, zone);
            }
            return (MemorySegment)mh$.invokeExact(anObject, nBytes, zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class class_createInstanceFromZone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("class_createInstanceFromZone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static FunctionDescriptor class_createInstanceFromZone$descriptor() {
        return class_createInstanceFromZone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static MethodHandle class_createInstanceFromZone$handle() {
        return class_createInstanceFromZone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static MemorySegment class_createInstanceFromZone$address() {
        return class_createInstanceFromZone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nullable class_createInstanceFromZone(Class _Nullable, size_t idxIvars, __unused void *zone)
     * }
     */
    public static MemorySegment class_createInstanceFromZone(MemorySegment x0, long idxIvars, MemorySegment zone) {
        var mh$ = class_createInstanceFromZone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("class_createInstanceFromZone", x0, idxIvars, zone);
            }
            return (MemorySegment)mh$.invokeExact(x0, idxIvars, zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_msgSend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_msgSend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_msgSend()
     * }
     */
    public static FunctionDescriptor objc_msgSend$descriptor() {
        return objc_msgSend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_msgSend()
     * }
     */
    public static MethodHandle objc_msgSend$handle() {
        return objc_msgSend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_msgSend()
     * }
     */
    public static MemorySegment objc_msgSend$address() {
        return objc_msgSend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_msgSend()
     * }
     */
    public static void objc_msgSend() {
        var mh$ = objc_msgSend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_msgSend");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_msgSendSuper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_msgSendSuper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper()
     * }
     */
    public static FunctionDescriptor objc_msgSendSuper$descriptor() {
        return objc_msgSendSuper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper()
     * }
     */
    public static MethodHandle objc_msgSendSuper$handle() {
        return objc_msgSendSuper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper()
     * }
     */
    public static MemorySegment objc_msgSendSuper$address() {
        return objc_msgSendSuper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_msgSendSuper()
     * }
     */
    public static void objc_msgSendSuper() {
        var mh$ = objc_msgSendSuper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_msgSendSuper");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_msgSend_stret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_msgSend_stret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_msgSend_stret()
     * }
     */
    public static FunctionDescriptor objc_msgSend_stret$descriptor() {
        return objc_msgSend_stret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_msgSend_stret()
     * }
     */
    public static MethodHandle objc_msgSend_stret$handle() {
        return objc_msgSend_stret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_msgSend_stret()
     * }
     */
    public static MemorySegment objc_msgSend_stret$address() {
        return objc_msgSend_stret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_msgSend_stret()
     * }
     */
    public static void objc_msgSend_stret() {
        var mh$ = objc_msgSend_stret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_msgSend_stret");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_msgSendSuper_stret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_msgSendSuper_stret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper_stret()
     * }
     */
    public static FunctionDescriptor objc_msgSendSuper_stret$descriptor() {
        return objc_msgSendSuper_stret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper_stret()
     * }
     */
    public static MethodHandle objc_msgSendSuper_stret$handle() {
        return objc_msgSendSuper_stret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_msgSendSuper_stret()
     * }
     */
    public static MemorySegment objc_msgSendSuper_stret$address() {
        return objc_msgSendSuper_stret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_msgSendSuper_stret()
     * }
     */
    public static void objc_msgSendSuper_stret() {
        var mh$ = objc_msgSendSuper_stret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_msgSendSuper_stret");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_invoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_invoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_invoke()
     * }
     */
    public static FunctionDescriptor method_invoke$descriptor() {
        return method_invoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_invoke()
     * }
     */
    public static MethodHandle method_invoke$handle() {
        return method_invoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_invoke()
     * }
     */
    public static MemorySegment method_invoke$address() {
        return method_invoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_invoke()
     * }
     */
    public static void method_invoke() {
        var mh$ = method_invoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_invoke");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class method_invoke_stret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("method_invoke_stret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void method_invoke_stret()
     * }
     */
    public static FunctionDescriptor method_invoke_stret$descriptor() {
        return method_invoke_stret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void method_invoke_stret()
     * }
     */
    public static MethodHandle method_invoke_stret$handle() {
        return method_invoke_stret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void method_invoke_stret()
     * }
     */
    public static MemorySegment method_invoke_stret$address() {
        return method_invoke_stret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void method_invoke_stret()
     * }
     */
    public static void method_invoke_stret() {
        var mh$ = method_invoke_stret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("method_invoke_stret");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _objc_msgForward {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_objc_msgForward");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _objc_msgForward()
     * }
     */
    public static FunctionDescriptor _objc_msgForward$descriptor() {
        return _objc_msgForward.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _objc_msgForward()
     * }
     */
    public static MethodHandle _objc_msgForward$handle() {
        return _objc_msgForward.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _objc_msgForward()
     * }
     */
    public static MemorySegment _objc_msgForward$address() {
        return _objc_msgForward.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _objc_msgForward()
     * }
     */
    public static void _objc_msgForward() {
        var mh$ = _objc_msgForward.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_objc_msgForward");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _objc_msgForward_stret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("_objc_msgForward_stret");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _objc_msgForward_stret()
     * }
     */
    public static FunctionDescriptor _objc_msgForward_stret$descriptor() {
        return _objc_msgForward_stret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _objc_msgForward_stret()
     * }
     */
    public static MethodHandle _objc_msgForward_stret$handle() {
        return _objc_msgForward_stret.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _objc_msgForward_stret()
     * }
     */
    public static MemorySegment _objc_msgForward_stret$address() {
        return _objc_msgForward_stret.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _objc_msgForward_stret()
     * }
     */
    public static void _objc_msgForward_stret() {
        var mh$ = _objc_msgForward_stret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_objc_msgForward_stret");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_exception_throw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_exception_throw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_exception_throw(id  _Nonnull exception)
     * }
     */
    public static FunctionDescriptor objc_exception_throw$descriptor() {
        return objc_exception_throw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_exception_throw(id  _Nonnull exception)
     * }
     */
    public static MethodHandle objc_exception_throw$handle() {
        return objc_exception_throw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_exception_throw(id  _Nonnull exception)
     * }
     */
    public static MemorySegment objc_exception_throw$address() {
        return objc_exception_throw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_exception_throw(id  _Nonnull exception)
     * }
     */
    public static void objc_exception_throw(MemorySegment exception) {
        var mh$ = objc_exception_throw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_exception_throw", exception);
            }
            mh$.invokeExact(exception);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_exception_rethrow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_exception_rethrow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_exception_rethrow()
     * }
     */
    public static FunctionDescriptor objc_exception_rethrow$descriptor() {
        return objc_exception_rethrow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_exception_rethrow()
     * }
     */
    public static MethodHandle objc_exception_rethrow$handle() {
        return objc_exception_rethrow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_exception_rethrow()
     * }
     */
    public static MemorySegment objc_exception_rethrow$address() {
        return objc_exception_rethrow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_exception_rethrow()
     * }
     */
    public static void objc_exception_rethrow() {
        var mh$ = objc_exception_rethrow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_exception_rethrow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_begin_catch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_begin_catch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern id  _Nonnull objc_begin_catch(void * _Nonnull exc_buf)
     * }
     */
    public static FunctionDescriptor objc_begin_catch$descriptor() {
        return objc_begin_catch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern id  _Nonnull objc_begin_catch(void * _Nonnull exc_buf)
     * }
     */
    public static MethodHandle objc_begin_catch$handle() {
        return objc_begin_catch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern id  _Nonnull objc_begin_catch(void * _Nonnull exc_buf)
     * }
     */
    public static MemorySegment objc_begin_catch$address() {
        return objc_begin_catch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern id  _Nonnull objc_begin_catch(void * _Nonnull exc_buf)
     * }
     */
    public static MemorySegment objc_begin_catch(MemorySegment exc_buf) {
        var mh$ = objc_begin_catch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_begin_catch", exc_buf);
            }
            return (MemorySegment)mh$.invokeExact(exc_buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_end_catch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_end_catch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_end_catch()
     * }
     */
    public static FunctionDescriptor objc_end_catch$descriptor() {
        return objc_end_catch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_end_catch()
     * }
     */
    public static MethodHandle objc_end_catch$handle() {
        return objc_end_catch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_end_catch()
     * }
     */
    public static MemorySegment objc_end_catch$address() {
        return objc_end_catch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_end_catch()
     * }
     */
    public static void objc_end_catch() {
        var mh$ = objc_end_catch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_end_catch");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_terminate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_terminate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_terminate()
     * }
     */
    public static FunctionDescriptor objc_terminate$descriptor() {
        return objc_terminate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_terminate()
     * }
     */
    public static MethodHandle objc_terminate$handle() {
        return objc_terminate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_terminate()
     * }
     */
    public static MemorySegment objc_terminate$address() {
        return objc_terminate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_terminate()
     * }
     */
    public static void objc_terminate() {
        var mh$ = objc_terminate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_terminate");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setExceptionPreprocessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setExceptionPreprocessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_exception_preprocessor  _Nonnull objc_setExceptionPreprocessor(objc_exception_preprocessor  _Nonnull fn)
     * }
     */
    public static FunctionDescriptor objc_setExceptionPreprocessor$descriptor() {
        return objc_setExceptionPreprocessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_exception_preprocessor  _Nonnull objc_setExceptionPreprocessor(objc_exception_preprocessor  _Nonnull fn)
     * }
     */
    public static MethodHandle objc_setExceptionPreprocessor$handle() {
        return objc_setExceptionPreprocessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_exception_preprocessor  _Nonnull objc_setExceptionPreprocessor(objc_exception_preprocessor  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setExceptionPreprocessor$address() {
        return objc_setExceptionPreprocessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_exception_preprocessor  _Nonnull objc_setExceptionPreprocessor(objc_exception_preprocessor  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setExceptionPreprocessor(MemorySegment fn) {
        var mh$ = objc_setExceptionPreprocessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setExceptionPreprocessor", fn);
            }
            return (MemorySegment)mh$.invokeExact(fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setExceptionMatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setExceptionMatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_exception_matcher  _Nonnull objc_setExceptionMatcher(objc_exception_matcher  _Nonnull fn)
     * }
     */
    public static FunctionDescriptor objc_setExceptionMatcher$descriptor() {
        return objc_setExceptionMatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_exception_matcher  _Nonnull objc_setExceptionMatcher(objc_exception_matcher  _Nonnull fn)
     * }
     */
    public static MethodHandle objc_setExceptionMatcher$handle() {
        return objc_setExceptionMatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_exception_matcher  _Nonnull objc_setExceptionMatcher(objc_exception_matcher  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setExceptionMatcher$address() {
        return objc_setExceptionMatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_exception_matcher  _Nonnull objc_setExceptionMatcher(objc_exception_matcher  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setExceptionMatcher(MemorySegment fn) {
        var mh$ = objc_setExceptionMatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setExceptionMatcher", fn);
            }
            return (MemorySegment)mh$.invokeExact(fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_setUncaughtExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_setUncaughtExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern objc_uncaught_exception_handler  _Nonnull objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler  _Nonnull fn)
     * }
     */
    public static FunctionDescriptor objc_setUncaughtExceptionHandler$descriptor() {
        return objc_setUncaughtExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern objc_uncaught_exception_handler  _Nonnull objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler  _Nonnull fn)
     * }
     */
    public static MethodHandle objc_setUncaughtExceptionHandler$handle() {
        return objc_setUncaughtExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern objc_uncaught_exception_handler  _Nonnull objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setUncaughtExceptionHandler$address() {
        return objc_setUncaughtExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern objc_uncaught_exception_handler  _Nonnull objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler  _Nonnull fn)
     * }
     */
    public static MemorySegment objc_setUncaughtExceptionHandler(MemorySegment fn) {
        var mh$ = objc_setUncaughtExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_setUncaughtExceptionHandler", fn);
            }
            return (MemorySegment)mh$.invokeExact(fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_addExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_addExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintptr_t objc_addExceptionHandler(objc_exception_handler  _Nonnull fn, void * _Nullable context)
     * }
     */
    public static FunctionDescriptor objc_addExceptionHandler$descriptor() {
        return objc_addExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintptr_t objc_addExceptionHandler(objc_exception_handler  _Nonnull fn, void * _Nullable context)
     * }
     */
    public static MethodHandle objc_addExceptionHandler$handle() {
        return objc_addExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintptr_t objc_addExceptionHandler(objc_exception_handler  _Nonnull fn, void * _Nullable context)
     * }
     */
    public static MemorySegment objc_addExceptionHandler$address() {
        return objc_addExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintptr_t objc_addExceptionHandler(objc_exception_handler  _Nonnull fn, void * _Nullable context)
     * }
     */
    public static long objc_addExceptionHandler(MemorySegment fn, MemorySegment context) {
        var mh$ = objc_addExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_addExceptionHandler", fn, context);
            }
            return (long)mh$.invokeExact(fn, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_removeExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_removeExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void objc_removeExceptionHandler(uintptr_t token)
     * }
     */
    public static FunctionDescriptor objc_removeExceptionHandler$descriptor() {
        return objc_removeExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void objc_removeExceptionHandler(uintptr_t token)
     * }
     */
    public static MethodHandle objc_removeExceptionHandler$handle() {
        return objc_removeExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void objc_removeExceptionHandler(uintptr_t token)
     * }
     */
    public static MemorySegment objc_removeExceptionHandler$address() {
        return objc_removeExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void objc_removeExceptionHandler(uintptr_t token)
     * }
     */
    public static void objc_removeExceptionHandler(long token) {
        var mh$ = objc_removeExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_removeExceptionHandler", token);
            }
            mh$.invokeExact(token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dst, MemorySegment __src, long __len) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dst, __src, __len);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset(MemorySegment __b, int __c, long __len) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __b, __c, __len);
            }
            return (MemorySegment)mh$.invokeExact(__b, __c, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __s1, __s2);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __s1, __s2, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __charset);
            }
            return (MemorySegment)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok(MemorySegment __str, MemorySegment __sep) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __str, __sep);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __s1, __s2, __n);
            }
            return (long)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __str, MemorySegment __sep, MemorySegment __lasts) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __str, __sep, __lasts);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep, __lasts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __strerrbuf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __strerrbuf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __strerrbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s1) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s1);
            }
            return (MemorySegment)mh$.invokeExact(__s1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dst, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dst, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __s1, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __s1, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static long strnlen(MemorySegment __s1, long __n) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __s1, __n);
            }
            return (long)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static FunctionDescriptor memset_s$descriptor() {
        return memset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MethodHandle memset_s$handle() {
        return memset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MemorySegment memset_s$address() {
        return memset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static int memset_s(MemorySegment __s, long __smax, int __c, long __n) {
        var mh$ = memset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_s", __s, __smax, __c, __n);
            }
            return (int)mh$.invokeExact(__s, __smax, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem(MemorySegment __big, long __big_len, MemorySegment __little, long __little_len) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __big, __big_len, __little, __little_len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __big_len, __little, __little_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memset_pattern4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern4$descriptor() {
        return memset_pattern4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern4$handle() {
        return memset_pattern4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern4$address() {
        return memset_pattern4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static void memset_pattern4(MemorySegment __b, MemorySegment __pattern4, long __len) {
        var mh$ = memset_pattern4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern4", __b, __pattern4, __len);
            }
            mh$.invokeExact(__b, __pattern4, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memset_pattern8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern8$descriptor() {
        return memset_pattern8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern8$handle() {
        return memset_pattern8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern8$address() {
        return memset_pattern8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static void memset_pattern8(MemorySegment __b, MemorySegment __pattern8, long __len) {
        var mh$ = memset_pattern8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern8", __b, __pattern8, __len);
            }
            mh$.invokeExact(__b, __pattern8, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("memset_pattern16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern16$descriptor() {
        return memset_pattern16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern16$handle() {
        return memset_pattern16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern16$address() {
        return memset_pattern16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static void memset_pattern16(MemorySegment __b, MemorySegment __pattern16, long __len) {
        var mh$ = memset_pattern16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern16", __b, __pattern16, __len);
            }
            mh$.invokeExact(__b, __pattern16, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strnstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static FunctionDescriptor strnstr$descriptor() {
        return strnstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MethodHandle strnstr$handle() {
        return strnstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr$address() {
        return strnstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr(MemorySegment __big, MemorySegment __little, long __len) {
        var mh$ = strnstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnstr", __big, __little, __len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcat(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcpy(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static FunctionDescriptor strmode$descriptor() {
        return strmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MethodHandle strmode$handle() {
        return strmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MemorySegment strmode$address() {
        return strmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static void strmode(int __mode, MemorySegment __bp) {
        var mh$ = strmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strmode", __mode, __bp);
            }
            mh$.invokeExact(__mode, __bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static void swab(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timingsafe_bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("timingsafe_bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static FunctionDescriptor timingsafe_bcmp$descriptor() {
        return timingsafe_bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MethodHandle timingsafe_bcmp$handle() {
        return timingsafe_bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MemorySegment timingsafe_bcmp$address() {
        return timingsafe_bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static int timingsafe_bcmp(MemorySegment __b1, MemorySegment __b2, long __len) {
        var mh$ = timingsafe_bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timingsafe_bcmp", __b1, __b2, __len);
            }
            return (int)mh$.invokeExact(__b1, __b2, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("strsignal_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strsignal_r$descriptor() {
        return strsignal_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strsignal_r$handle() {
        return strsignal_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strsignal_r$address() {
        return strsignal_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static int strsignal_r(int __sig, MemorySegment __strsignalbuf, long __buflen) {
        var mh$ = strsignal_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal_r", __sig, __strsignalbuf, __buflen);
            }
            return (int)mh$.invokeExact(__sig, __strsignalbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int64_t OSAtomic_int64_aligned64_t
     * }
     */
    public static final OfLong OSAtomic_int64_aligned64_t = ObjCRuntime.C_LONG_LONG;

    private static class OSAtomicAdd32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAdd32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAdd32$descriptor() {
        return OSAtomicAdd32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAdd32$handle() {
        return OSAtomicAdd32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAdd32$address() {
        return OSAtomicAdd32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static int OSAtomicAdd32(int __theAmount, MemorySegment __theValue) {
        var mh$ = OSAtomicAdd32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAdd32", __theAmount, __theValue);
            }
            return (int)mh$.invokeExact(__theAmount, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAdd32Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAdd32Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32Barrier(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAdd32Barrier$descriptor() {
        return OSAtomicAdd32Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32Barrier(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAdd32Barrier$handle() {
        return OSAtomicAdd32Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32Barrier(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAdd32Barrier$address() {
        return OSAtomicAdd32Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAdd32Barrier(int32_t __theAmount, volatile int32_t *__theValue)
     * }
     */
    public static int OSAtomicAdd32Barrier(int __theAmount, MemorySegment __theValue) {
        var mh$ = OSAtomicAdd32Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAdd32Barrier", __theAmount, __theValue);
            }
            return (int)mh$.invokeExact(__theAmount, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAdd64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAdd64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAdd64$descriptor() {
        return OSAtomicAdd64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAdd64$handle() {
        return OSAtomicAdd64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAdd64$address() {
        return OSAtomicAdd64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static long OSAtomicAdd64(long __theAmount, MemorySegment __theValue) {
        var mh$ = OSAtomicAdd64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAdd64", __theAmount, __theValue);
            }
            return (long)mh$.invokeExact(__theAmount, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAdd64Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAdd64Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64Barrier(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAdd64Barrier$descriptor() {
        return OSAtomicAdd64Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64Barrier(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAdd64Barrier$handle() {
        return OSAtomicAdd64Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64Barrier(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAdd64Barrier$address() {
        return OSAtomicAdd64Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t OSAtomicAdd64Barrier(int64_t __theAmount, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static long OSAtomicAdd64Barrier(long __theAmount, MemorySegment __theValue) {
        var mh$ = OSAtomicAdd64Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAdd64Barrier", __theAmount, __theValue);
            }
            return (long)mh$.invokeExact(__theAmount, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicOr32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicOr32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicOr32$descriptor() {
        return OSAtomicOr32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicOr32$handle() {
        return OSAtomicOr32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicOr32$address() {
        return OSAtomicOr32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicOr32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicOr32(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicOr32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicOr32", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicOr32Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicOr32Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicOr32Barrier$descriptor() {
        return OSAtomicOr32Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicOr32Barrier$handle() {
        return OSAtomicOr32Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicOr32Barrier$address() {
        return OSAtomicOr32Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicOr32Barrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicOr32Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicOr32Barrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicOr32Orig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicOr32Orig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicOr32Orig$descriptor() {
        return OSAtomicOr32Orig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicOr32Orig$handle() {
        return OSAtomicOr32Orig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicOr32Orig$address() {
        return OSAtomicOr32Orig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicOr32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicOr32Orig(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicOr32Orig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicOr32Orig", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicOr32OrigBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicOr32OrigBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicOr32OrigBarrier$descriptor() {
        return OSAtomicOr32OrigBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicOr32OrigBarrier$handle() {
        return OSAtomicOr32OrigBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicOr32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicOr32OrigBarrier$address() {
        return OSAtomicOr32OrigBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicOr32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicOr32OrigBarrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicOr32OrigBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicOr32OrigBarrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAnd32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAnd32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAnd32$descriptor() {
        return OSAtomicAnd32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAnd32$handle() {
        return OSAtomicAnd32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAnd32$address() {
        return OSAtomicAnd32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicAnd32(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicAnd32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAnd32", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAnd32Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAnd32Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAnd32Barrier$descriptor() {
        return OSAtomicAnd32Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAnd32Barrier$handle() {
        return OSAtomicAnd32Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAnd32Barrier$address() {
        return OSAtomicAnd32Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicAnd32Barrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicAnd32Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAnd32Barrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAnd32Orig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAnd32Orig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAnd32Orig$descriptor() {
        return OSAtomicAnd32Orig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAnd32Orig$handle() {
        return OSAtomicAnd32Orig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAnd32Orig$address() {
        return OSAtomicAnd32Orig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicAnd32Orig(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicAnd32Orig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAnd32Orig", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicAnd32OrigBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicAnd32OrigBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicAnd32OrigBarrier$descriptor() {
        return OSAtomicAnd32OrigBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicAnd32OrigBarrier$handle() {
        return OSAtomicAnd32OrigBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicAnd32OrigBarrier$address() {
        return OSAtomicAnd32OrigBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicAnd32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicAnd32OrigBarrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicAnd32OrigBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicAnd32OrigBarrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicXor32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicXor32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicXor32$descriptor() {
        return OSAtomicXor32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicXor32$handle() {
        return OSAtomicXor32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicXor32$address() {
        return OSAtomicXor32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicXor32(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicXor32(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicXor32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicXor32", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicXor32Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicXor32Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicXor32Barrier$descriptor() {
        return OSAtomicXor32Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicXor32Barrier$handle() {
        return OSAtomicXor32Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicXor32Barrier$address() {
        return OSAtomicXor32Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Barrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicXor32Barrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicXor32Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicXor32Barrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicXor32Orig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicXor32Orig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicXor32Orig$descriptor() {
        return OSAtomicXor32Orig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicXor32Orig$handle() {
        return OSAtomicXor32Orig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicXor32Orig$address() {
        return OSAtomicXor32Orig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicXor32Orig(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicXor32Orig(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicXor32Orig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicXor32Orig", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicXor32OrigBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicXor32OrigBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicXor32OrigBarrier$descriptor() {
        return OSAtomicXor32OrigBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicXor32OrigBarrier$handle() {
        return OSAtomicXor32OrigBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t OSAtomicXor32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicXor32OrigBarrier$address() {
        return OSAtomicXor32OrigBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t OSAtomicXor32OrigBarrier(uint32_t __theMask, volatile uint32_t *__theValue)
     * }
     */
    public static int OSAtomicXor32OrigBarrier(int __theMask, MemorySegment __theValue) {
        var mh$ = OSAtomicXor32OrigBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicXor32OrigBarrier", __theMask, __theValue);
            }
            return (int)mh$.invokeExact(__theMask, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwap32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwap32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwap32$descriptor() {
        return OSAtomicCompareAndSwap32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwap32$handle() {
        return OSAtomicCompareAndSwap32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwap32$address() {
        return OSAtomicCompareAndSwap32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwap32(int __oldValue, int __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwap32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwap32", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwap32Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwap32Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32Barrier(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwap32Barrier$descriptor() {
        return OSAtomicCompareAndSwap32Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32Barrier(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwap32Barrier$handle() {
        return OSAtomicCompareAndSwap32Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32Barrier(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwap32Barrier$address() {
        return OSAtomicCompareAndSwap32Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap32Barrier(int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwap32Barrier(int __oldValue, int __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwap32Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwap32Barrier", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtr(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapPtr$descriptor() {
        return OSAtomicCompareAndSwapPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtr(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapPtr$handle() {
        return OSAtomicCompareAndSwapPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtr(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapPtr$address() {
        return OSAtomicCompareAndSwapPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtr(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapPtr(MemorySegment __oldValue, MemorySegment __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapPtr", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapPtrBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapPtrBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtrBarrier(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapPtrBarrier$descriptor() {
        return OSAtomicCompareAndSwapPtrBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtrBarrier(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapPtrBarrier$handle() {
        return OSAtomicCompareAndSwapPtrBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtrBarrier(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapPtrBarrier$address() {
        return OSAtomicCompareAndSwapPtrBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapPtrBarrier(void *__oldValue, void *__newValue, void *volatile *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapPtrBarrier(MemorySegment __oldValue, MemorySegment __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapPtrBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapPtrBarrier", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapInt(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapInt$descriptor() {
        return OSAtomicCompareAndSwapInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapInt(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapInt$handle() {
        return OSAtomicCompareAndSwapInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapInt(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapInt$address() {
        return OSAtomicCompareAndSwapInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapInt(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapInt(int __oldValue, int __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapInt", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapIntBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapIntBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapIntBarrier(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapIntBarrier$descriptor() {
        return OSAtomicCompareAndSwapIntBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapIntBarrier(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapIntBarrier$handle() {
        return OSAtomicCompareAndSwapIntBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapIntBarrier(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapIntBarrier$address() {
        return OSAtomicCompareAndSwapIntBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapIntBarrier(int __oldValue, int __newValue, volatile int *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapIntBarrier(int __oldValue, int __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapIntBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapIntBarrier", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLong(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapLong$descriptor() {
        return OSAtomicCompareAndSwapLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLong(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapLong$handle() {
        return OSAtomicCompareAndSwapLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLong(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapLong$address() {
        return OSAtomicCompareAndSwapLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLong(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapLong(long __oldValue, long __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapLong", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwapLongBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwapLongBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLongBarrier(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwapLongBarrier$descriptor() {
        return OSAtomicCompareAndSwapLongBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLongBarrier(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwapLongBarrier$handle() {
        return OSAtomicCompareAndSwapLongBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLongBarrier(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwapLongBarrier$address() {
        return OSAtomicCompareAndSwapLongBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwapLongBarrier(long __oldValue, long __newValue, volatile long *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwapLongBarrier(long __oldValue, long __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwapLongBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwapLongBarrier", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwap64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwap64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwap64$descriptor() {
        return OSAtomicCompareAndSwap64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwap64$handle() {
        return OSAtomicCompareAndSwap64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwap64$address() {
        return OSAtomicCompareAndSwap64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwap64(long __oldValue, long __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwap64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwap64", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicCompareAndSwap64Barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_LONG_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicCompareAndSwap64Barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64Barrier(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static FunctionDescriptor OSAtomicCompareAndSwap64Barrier$descriptor() {
        return OSAtomicCompareAndSwap64Barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64Barrier(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MethodHandle OSAtomicCompareAndSwap64Barrier$handle() {
        return OSAtomicCompareAndSwap64Barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64Barrier(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static MemorySegment OSAtomicCompareAndSwap64Barrier$address() {
        return OSAtomicCompareAndSwap64Barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicCompareAndSwap64Barrier(int64_t __oldValue, int64_t __newValue, volatile OSAtomic_int64_aligned64_t *__theValue)
     * }
     */
    public static boolean OSAtomicCompareAndSwap64Barrier(long __oldValue, long __newValue, MemorySegment __theValue) {
        var mh$ = OSAtomicCompareAndSwap64Barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicCompareAndSwap64Barrier", __oldValue, __newValue, __theValue);
            }
            return (boolean)mh$.invokeExact(__oldValue, __newValue, __theValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicTestAndSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicTestAndSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSet(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static FunctionDescriptor OSAtomicTestAndSet$descriptor() {
        return OSAtomicTestAndSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSet(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MethodHandle OSAtomicTestAndSet$handle() {
        return OSAtomicTestAndSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSet(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MemorySegment OSAtomicTestAndSet$address() {
        return OSAtomicTestAndSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicTestAndSet(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static boolean OSAtomicTestAndSet(int __n, MemorySegment __theAddress) {
        var mh$ = OSAtomicTestAndSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicTestAndSet", __n, __theAddress);
            }
            return (boolean)mh$.invokeExact(__n, __theAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicTestAndSetBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicTestAndSetBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSetBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static FunctionDescriptor OSAtomicTestAndSetBarrier$descriptor() {
        return OSAtomicTestAndSetBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSetBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MethodHandle OSAtomicTestAndSetBarrier$handle() {
        return OSAtomicTestAndSetBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndSetBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MemorySegment OSAtomicTestAndSetBarrier$address() {
        return OSAtomicTestAndSetBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicTestAndSetBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static boolean OSAtomicTestAndSetBarrier(int __n, MemorySegment __theAddress) {
        var mh$ = OSAtomicTestAndSetBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicTestAndSetBarrier", __n, __theAddress);
            }
            return (boolean)mh$.invokeExact(__n, __theAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicTestAndClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicTestAndClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClear(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static FunctionDescriptor OSAtomicTestAndClear$descriptor() {
        return OSAtomicTestAndClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClear(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MethodHandle OSAtomicTestAndClear$handle() {
        return OSAtomicTestAndClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClear(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MemorySegment OSAtomicTestAndClear$address() {
        return OSAtomicTestAndClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicTestAndClear(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static boolean OSAtomicTestAndClear(int __n, MemorySegment __theAddress) {
        var mh$ = OSAtomicTestAndClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicTestAndClear", __n, __theAddress);
            }
            return (boolean)mh$.invokeExact(__n, __theAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicTestAndClearBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicTestAndClearBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClearBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static FunctionDescriptor OSAtomicTestAndClearBarrier$descriptor() {
        return OSAtomicTestAndClearBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClearBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MethodHandle OSAtomicTestAndClearBarrier$handle() {
        return OSAtomicTestAndClearBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSAtomicTestAndClearBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static MemorySegment OSAtomicTestAndClearBarrier$address() {
        return OSAtomicTestAndClearBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSAtomicTestAndClearBarrier(uint32_t __n, volatile void *__theAddress)
     * }
     */
    public static boolean OSAtomicTestAndClearBarrier(int __n, MemorySegment __theAddress) {
        var mh$ = OSAtomicTestAndClearBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicTestAndClearBarrier", __n, __theAddress);
            }
            return (boolean)mh$.invokeExact(__n, __theAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSMemoryBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSMemoryBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OSMemoryBarrier()
     * }
     */
    public static FunctionDescriptor OSMemoryBarrier$descriptor() {
        return OSMemoryBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OSMemoryBarrier()
     * }
     */
    public static MethodHandle OSMemoryBarrier$handle() {
        return OSMemoryBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OSMemoryBarrier()
     * }
     */
    public static MemorySegment OSMemoryBarrier$address() {
        return OSMemoryBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OSMemoryBarrier()
     * }
     */
    public static void OSMemoryBarrier() {
        var mh$ = OSMemoryBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSMemoryBarrier");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int32_t OSSpinLock
     * }
     */
    public static final OfInt OSSpinLock = ObjCRuntime.C_INT;

    private static class OSSpinLockTry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_BOOL,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSSpinLockTry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool OSSpinLockTry(volatile OSSpinLock *__lock)
     * }
     */
    public static FunctionDescriptor OSSpinLockTry$descriptor() {
        return OSSpinLockTry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool OSSpinLockTry(volatile OSSpinLock *__lock)
     * }
     */
    public static MethodHandle OSSpinLockTry$handle() {
        return OSSpinLockTry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool OSSpinLockTry(volatile OSSpinLock *__lock)
     * }
     */
    public static MemorySegment OSSpinLockTry$address() {
        return OSSpinLockTry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool OSSpinLockTry(volatile OSSpinLock *__lock)
     * }
     */
    public static boolean OSSpinLockTry(MemorySegment __lock) {
        var mh$ = OSSpinLockTry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSSpinLockTry", __lock);
            }
            return (boolean)mh$.invokeExact(__lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSSpinLockLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSSpinLockLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OSSpinLockLock(volatile OSSpinLock *__lock)
     * }
     */
    public static FunctionDescriptor OSSpinLockLock$descriptor() {
        return OSSpinLockLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OSSpinLockLock(volatile OSSpinLock *__lock)
     * }
     */
    public static MethodHandle OSSpinLockLock$handle() {
        return OSSpinLockLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OSSpinLockLock(volatile OSSpinLock *__lock)
     * }
     */
    public static MemorySegment OSSpinLockLock$address() {
        return OSSpinLockLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OSSpinLockLock(volatile OSSpinLock *__lock)
     * }
     */
    public static void OSSpinLockLock(MemorySegment __lock) {
        var mh$ = OSSpinLockLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSSpinLockLock", __lock);
            }
            mh$.invokeExact(__lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSSpinLockUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSSpinLockUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OSSpinLockUnlock(volatile OSSpinLock *__lock)
     * }
     */
    public static FunctionDescriptor OSSpinLockUnlock$descriptor() {
        return OSSpinLockUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OSSpinLockUnlock(volatile OSSpinLock *__lock)
     * }
     */
    public static MethodHandle OSSpinLockUnlock$handle() {
        return OSSpinLockUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OSSpinLockUnlock(volatile OSSpinLock *__lock)
     * }
     */
    public static MemorySegment OSSpinLockUnlock$address() {
        return OSSpinLockUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OSSpinLockUnlock(volatile OSSpinLock *__lock)
     * }
     */
    public static void OSSpinLockUnlock(MemorySegment __lock) {
        var mh$ = OSSpinLockUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSSpinLockUnlock", __lock);
            }
            mh$.invokeExact(__lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicEnqueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicEnqueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OSAtomicEnqueue(OSQueueHead *__list, void *__new, size_t __offset)
     * }
     */
    public static FunctionDescriptor OSAtomicEnqueue$descriptor() {
        return OSAtomicEnqueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OSAtomicEnqueue(OSQueueHead *__list, void *__new, size_t __offset)
     * }
     */
    public static MethodHandle OSAtomicEnqueue$handle() {
        return OSAtomicEnqueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OSAtomicEnqueue(OSQueueHead *__list, void *__new, size_t __offset)
     * }
     */
    public static MemorySegment OSAtomicEnqueue$address() {
        return OSAtomicEnqueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OSAtomicEnqueue(OSQueueHead *__list, void *__new, size_t __offset)
     * }
     */
    public static void OSAtomicEnqueue(MemorySegment __list, MemorySegment __new, long __offset) {
        var mh$ = OSAtomicEnqueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicEnqueue", __list, __new, __offset);
            }
            mh$.invokeExact(__list, __new, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OSAtomicDequeue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("OSAtomicDequeue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *OSAtomicDequeue(OSQueueHead *__list, size_t __offset)
     * }
     */
    public static FunctionDescriptor OSAtomicDequeue$descriptor() {
        return OSAtomicDequeue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *OSAtomicDequeue(OSQueueHead *__list, size_t __offset)
     * }
     */
    public static MethodHandle OSAtomicDequeue$handle() {
        return OSAtomicDequeue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *OSAtomicDequeue(OSQueueHead *__list, size_t __offset)
     * }
     */
    public static MemorySegment OSAtomicDequeue$address() {
        return OSAtomicDequeue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *OSAtomicDequeue(OSQueueHead *__list, size_t __offset)
     * }
     */
    public static MemorySegment OSAtomicDequeue(MemorySegment __list, long __offset) {
        var mh$ = OSAtomicDequeue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OSAtomicDequeue", __list, __offset);
            }
            return (MemorySegment)mh$.invokeExact(__list, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int boolean_t
     * }
     */
    public static final OfInt boolean_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int kern_return_t
     * }
     */
    public static final OfInt kern_return_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_name_t
     * }
     */
    public static final OfInt mach_port_name_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_name_t *mach_port_name_array_t
     * }
     */
    public static final AddressLayout mach_port_name_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_t mach_port_t
     * }
     */
    public static final OfInt mach_port_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t *mach_port_array_t
     * }
     */
    public static final AddressLayout mach_port_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_right_t
     * }
     */
    public static final OfInt mach_port_right_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_type_t
     * }
     */
    public static final OfInt mach_port_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_type_t *mach_port_type_array_t
     * }
     */
    public static final AddressLayout mach_port_type_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_urefs_t
     * }
     */
    public static final OfInt mach_port_urefs_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_port_delta_t
     * }
     */
    public static final OfInt mach_port_delta_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_seqno_t
     * }
     */
    public static final OfInt mach_port_seqno_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_mscount_t
     * }
     */
    public static final OfInt mach_port_mscount_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_msgcount_t
     * }
     */
    public static final OfInt mach_port_msgcount_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_rights_t
     * }
     */
    public static final OfInt mach_port_rights_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_port_srights_t
     * }
     */
    public static final OfInt mach_port_srights_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *mach_port_info_t
     * }
     */
    public static final AddressLayout mach_port_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int mach_port_flavor_t
     * }
     */
    public static final OfInt mach_port_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct mach_service_port_info {
     *     char mspi_string_name[255];
     *     uint8_t mspi_domain_type;
     * } *mach_service_port_info_t
     * }
     */
    public static final AddressLayout mach_service_port_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_port_options_t *mach_port_options_ptr_t
     * }
     */
    public static final AddressLayout mach_port_options_ptr_t = ObjCRuntime.C_POINTER;
    private static final int kGUARD_EXC_DESTROY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_DESTROY = 1
     * }
     */
    public static int kGUARD_EXC_DESTROY() {
        return kGUARD_EXC_DESTROY;
    }
    private static final int kGUARD_EXC_MOD_REFS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS = 2
     * }
     */
    public static int kGUARD_EXC_MOD_REFS() {
        return kGUARD_EXC_MOD_REFS;
    }
    private static final int kGUARD_EXC_INVALID_OPTIONS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_OPTIONS = 3
     * }
     */
    public static int kGUARD_EXC_INVALID_OPTIONS() {
        return kGUARD_EXC_INVALID_OPTIONS;
    }
    private static final int kGUARD_EXC_SET_CONTEXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SET_CONTEXT = 4
     * }
     */
    public static int kGUARD_EXC_SET_CONTEXT() {
        return kGUARD_EXC_SET_CONTEXT;
    }
    private static final int kGUARD_EXC_THREAD_SET_STATE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_THREAD_SET_STATE = 5
     * }
     */
    public static int kGUARD_EXC_THREAD_SET_STATE() {
        return kGUARD_EXC_THREAD_SET_STATE;
    }
    private static final int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = 6
     * }
     */
    public static int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE() {
        return kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE;
    }
    private static final int kGUARD_EXC_UNGUARDED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_UNGUARDED = 8
     * }
     */
    public static int kGUARD_EXC_UNGUARDED() {
        return kGUARD_EXC_UNGUARDED;
    }
    private static final int kGUARD_EXC_INCORRECT_GUARD = (int)16L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INCORRECT_GUARD = 16
     * }
     */
    public static int kGUARD_EXC_INCORRECT_GUARD() {
        return kGUARD_EXC_INCORRECT_GUARD;
    }
    private static final int kGUARD_EXC_IMMOVABLE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE = 32
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE() {
        return kGUARD_EXC_IMMOVABLE;
    }
    private static final int kGUARD_EXC_STRICT_REPLY = (int)64L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_STRICT_REPLY = 64
     * }
     */
    public static int kGUARD_EXC_STRICT_REPLY() {
        return kGUARD_EXC_STRICT_REPLY;
    }
    private static final int kGUARD_EXC_MSG_FILTERED = (int)128L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MSG_FILTERED = 128
     * }
     */
    public static int kGUARD_EXC_MSG_FILTERED() {
        return kGUARD_EXC_MSG_FILTERED;
    }
    private static final int kGUARD_EXC_INVALID_RIGHT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_RIGHT = 256
     * }
     */
    public static int kGUARD_EXC_INVALID_RIGHT() {
        return kGUARD_EXC_INVALID_RIGHT;
    }
    private static final int kGUARD_EXC_INVALID_NAME = (int)512L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_NAME = 512
     * }
     */
    public static int kGUARD_EXC_INVALID_NAME() {
        return kGUARD_EXC_INVALID_NAME;
    }
    private static final int kGUARD_EXC_INVALID_VALUE = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_VALUE = 1024
     * }
     */
    public static int kGUARD_EXC_INVALID_VALUE() {
        return kGUARD_EXC_INVALID_VALUE;
    }
    private static final int kGUARD_EXC_INVALID_ARGUMENT = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_ARGUMENT = 2048
     * }
     */
    public static int kGUARD_EXC_INVALID_ARGUMENT() {
        return kGUARD_EXC_INVALID_ARGUMENT;
    }
    private static final int kGUARD_EXC_RIGHT_EXISTS = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RIGHT_EXISTS = 4096
     * }
     */
    public static int kGUARD_EXC_RIGHT_EXISTS() {
        return kGUARD_EXC_RIGHT_EXISTS;
    }
    private static final int kGUARD_EXC_KERN_NO_SPACE = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_NO_SPACE = 8192
     * }
     */
    public static int kGUARD_EXC_KERN_NO_SPACE() {
        return kGUARD_EXC_KERN_NO_SPACE;
    }
    private static final int kGUARD_EXC_KERN_FAILURE = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_FAILURE = 16384
     * }
     */
    public static int kGUARD_EXC_KERN_FAILURE() {
        return kGUARD_EXC_KERN_FAILURE;
    }
    private static final int kGUARD_EXC_KERN_RESOURCE = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_RESOURCE = 32768
     * }
     */
    public static int kGUARD_EXC_KERN_RESOURCE() {
        return kGUARD_EXC_KERN_RESOURCE;
    }
    private static final int kGUARD_EXC_SEND_INVALID_REPLY = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_REPLY = 65536
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_REPLY() {
        return kGUARD_EXC_SEND_INVALID_REPLY;
    }
    private static final int kGUARD_EXC_SEND_INVALID_VOUCHER = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_VOUCHER = 131072
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_VOUCHER() {
        return kGUARD_EXC_SEND_INVALID_VOUCHER;
    }
    private static final int kGUARD_EXC_SEND_INVALID_RIGHT = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_RIGHT = 262144
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_RIGHT() {
        return kGUARD_EXC_SEND_INVALID_RIGHT;
    }
    private static final int kGUARD_EXC_RCV_INVALID_NAME = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_INVALID_NAME = 524288
     * }
     */
    public static int kGUARD_EXC_RCV_INVALID_NAME() {
        return kGUARD_EXC_RCV_INVALID_NAME;
    }
    private static final int kGUARD_EXC_RCV_GUARDED_DESC = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_GUARDED_DESC = 1048576
     * }
     */
    public static int kGUARD_EXC_RCV_GUARDED_DESC() {
        return kGUARD_EXC_RCV_GUARDED_DESC;
    }
    private static final int kGUARD_EXC_MOD_REFS_NON_FATAL = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS_NON_FATAL = 2097152
     * }
     */
    public static int kGUARD_EXC_MOD_REFS_NON_FATAL() {
        return kGUARD_EXC_MOD_REFS_NON_FATAL;
    }
    private static final int kGUARD_EXC_IMMOVABLE_NON_FATAL = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE_NON_FATAL = 4194304
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE_NON_FATAL() {
        return kGUARD_EXC_IMMOVABLE_NON_FATAL;
    }
    private static final int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = 8388608
     * }
     */
    public static int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS() {
        return kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS;
    }
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_timeout_t
     * }
     */
    public static final OfInt mach_msg_timeout_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_bits_t
     * }
     */
    public static final OfInt mach_msg_bits_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_size_t
     * }
     */
    public static final OfInt mach_msg_size_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_id_t
     * }
     */
    public static final OfInt mach_msg_id_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_priority_t
     * }
     */
    public static final OfInt mach_msg_priority_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_type_name_t
     * }
     */
    public static final OfInt mach_msg_type_name_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_copy_options_t
     * }
     */
    public static final OfInt mach_msg_copy_options_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_guard_flags_t
     * }
     */
    public static final OfInt mach_msg_guard_flags_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_descriptor_type_t
     * }
     */
    public static final OfInt mach_msg_descriptor_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_trailer_type_t
     * }
     */
    public static final OfInt mach_msg_trailer_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_trailer_size_t
     * }
     */
    public static final OfInt mach_msg_trailer_size_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char *mach_msg_trailer_info_t
     * }
     */
    public static final AddressLayout mach_msg_trailer_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int mach_msg_filter_id
     * }
     */
    public static final OfInt mach_msg_filter_id = ObjCRuntime.C_INT;

    private static class KERNEL_SECURITY_TOKEN$constants {
        public static final GroupLayout LAYOUT = security_token_t.layout();
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("KERNEL_SECURITY_TOKEN").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static GroupLayout KERNEL_SECURITY_TOKEN$layout() {
        return KERNEL_SECURITY_TOKEN$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static MemorySegment KERNEL_SECURITY_TOKEN() {
        return KERNEL_SECURITY_TOKEN$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static void KERNEL_SECURITY_TOKEN(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, KERNEL_SECURITY_TOKEN$constants.SEGMENT, 0L, KERNEL_SECURITY_TOKEN$constants.LAYOUT.byteSize());
    }

    private static class KERNEL_AUDIT_TOKEN$constants {
        public static final GroupLayout LAYOUT = audit_token_t.layout();
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("KERNEL_AUDIT_TOKEN").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static GroupLayout KERNEL_AUDIT_TOKEN$layout() {
        return KERNEL_AUDIT_TOKEN$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static MemorySegment KERNEL_AUDIT_TOKEN() {
        return KERNEL_AUDIT_TOKEN$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static void KERNEL_AUDIT_TOKEN(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, KERNEL_AUDIT_TOKEN$constants.SEGMENT, 0L, KERNEL_AUDIT_TOKEN$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_options_t
     * }
     */
    public static final OfInt mach_msg_options_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_type_size_t
     * }
     */
    public static final OfInt mach_msg_type_size_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_type_number_t
     * }
     */
    public static final OfInt mach_msg_type_number_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_option_t
     * }
     */
    public static final OfInt mach_msg_option_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef kern_return_t mach_msg_return_t
     * }
     */
    public static final OfInt mach_msg_return_t = ObjCRuntime.C_INT;

    private static class mach_msg_overwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mach_msg_overwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static FunctionDescriptor mach_msg_overwrite$descriptor() {
        return mach_msg_overwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static MethodHandle mach_msg_overwrite$handle() {
        return mach_msg_overwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static MemorySegment mach_msg_overwrite$address() {
        return mach_msg_overwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static int mach_msg_overwrite(MemorySegment msg, int option, int send_size, int rcv_size, int rcv_name, int timeout, int notify, MemorySegment rcv_msg, int rcv_limit) {
        var mh$ = mach_msg_overwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mach_msg_overwrite", msg, option, send_size, rcv_size, rcv_name, timeout, notify, rcv_msg, rcv_limit);
            }
            return (int)mh$.invokeExact(msg, option, send_size, rcv_size, rcv_name, timeout, notify, rcv_msg, rcv_limit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mach_msg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mach_msg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static FunctionDescriptor mach_msg$descriptor() {
        return mach_msg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static MethodHandle mach_msg$handle() {
        return mach_msg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static MemorySegment mach_msg$address() {
        return mach_msg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static int mach_msg(MemorySegment msg, int option, int send_size, int rcv_size, int rcv_name, int timeout, int notify) {
        var mh$ = mach_msg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mach_msg", msg, option, send_size, rcv_size, rcv_name, timeout, notify);
            }
            return (int)mh$.invokeExact(msg, option, send_size, rcv_size, rcv_name, timeout, notify);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mach_voucher_deallocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("mach_voucher_deallocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static FunctionDescriptor mach_voucher_deallocate$descriptor() {
        return mach_voucher_deallocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static MethodHandle mach_voucher_deallocate$handle() {
        return mach_voucher_deallocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static MemorySegment mach_voucher_deallocate$address() {
        return mach_voucher_deallocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static int mach_voucher_deallocate(int voucher) {
        var mh$ = mach_voucher_deallocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mach_voucher_deallocate", voucher);
            }
            return (int)mh$.invokeExact(voucher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct vm_statistics {
     *     natural_t free_count;
     *     natural_t active_count;
     *     natural_t inactive_count;
     *     natural_t wire_count;
     *     natural_t zero_fill_count;
     *     natural_t reactivations;
     *     natural_t pageins;
     *     natural_t pageouts;
     *     natural_t faults;
     *     natural_t cow_faults;
     *     natural_t lookups;
     *     natural_t hits;
     *     natural_t purgeable_count;
     *     natural_t purges;
     *     natural_t speculative_count;
     * } *vm_statistics_t
     * }
     */
    public static final AddressLayout vm_statistics_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vm_statistics64 {
     *     natural_t free_count;
     *     natural_t active_count;
     *     natural_t inactive_count;
     *     natural_t wire_count;
     *     uint64_t zero_fill_count;
     *     uint64_t reactivations;
     *     uint64_t pageins;
     *     uint64_t pageouts;
     *     uint64_t faults;
     *     uint64_t cow_faults;
     *     uint64_t lookups;
     *     uint64_t hits;
     *     uint64_t purges;
     *     natural_t purgeable_count;
     *     natural_t speculative_count;
     *     uint64_t decompressions;
     *     uint64_t compressions;
     *     uint64_t swapins;
     *     uint64_t swapouts;
     *     natural_t compressor_page_count;
     *     natural_t throttled_count;
     *     natural_t external_page_count;
     *     natural_t internal_page_count;
     *     uint64_t total_uncompressed_pages_in_compressor;
     * } *vm_statistics64_t
     * }
     */
    public static final AddressLayout vm_statistics64_t = ObjCRuntime.C_POINTER;

    private static class vm_stats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("vm_stats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * kern_return_t vm_stats(void *info, unsigned int *count)
     * }
     */
    public static FunctionDescriptor vm_stats$descriptor() {
        return vm_stats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * kern_return_t vm_stats(void *info, unsigned int *count)
     * }
     */
    public static MethodHandle vm_stats$handle() {
        return vm_stats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * kern_return_t vm_stats(void *info, unsigned int *count)
     * }
     */
    public static MemorySegment vm_stats$address() {
        return vm_stats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * kern_return_t vm_stats(void *info, unsigned int *count)
     * }
     */
    public static int vm_stats(MemorySegment info, MemorySegment count) {
        var mh$ = vm_stats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vm_stats", info, count);
            }
            return (int)mh$.invokeExact(info, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct vm_extmod_statistics {
     *     int64_t task_for_pid_count;
     *     int64_t task_for_pid_caller_count;
     *     int64_t thread_creation_count;
     *     int64_t thread_creation_caller_count;
     *     int64_t thread_set_state_count;
     *     int64_t thread_set_state_caller_count;
     * } *vm_extmod_statistics_t
     * }
     */
    public static final AddressLayout vm_extmod_statistics_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vm_purgeable_info {
     *     vm_purgeable_stat_t fifo_data[8];
     *     vm_purgeable_stat_t obsolete_data;
     *     vm_purgeable_stat_t lifo_data[8];
     * } *vm_purgeable_info_t
     * }
     */
    public static final AddressLayout vm_purgeable_info_t = ObjCRuntime.C_POINTER;
    private static final int kGUARD_EXC_DEALLOC_GAP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum virtual_memory_guard_exception_codes.kGUARD_EXC_DEALLOC_GAP = 1
     * }
     */
    public static int kGUARD_EXC_DEALLOC_GAP() {
        return kGUARD_EXC_DEALLOC_GAP;
    }
    private static final int kGUARD_EXC_RECLAIM_COPYIO_FAILURE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum virtual_memory_guard_exception_codes.kGUARD_EXC_RECLAIM_COPYIO_FAILURE = 2
     * }
     */
    public static int kGUARD_EXC_RECLAIM_COPYIO_FAILURE() {
        return kGUARD_EXC_RECLAIM_COPYIO_FAILURE;
    }
    private static final int kGUARD_EXC_RECLAIM_INDEX_FAILURE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum virtual_memory_guard_exception_codes.kGUARD_EXC_RECLAIM_INDEX_FAILURE = 4
     * }
     */
    public static int kGUARD_EXC_RECLAIM_INDEX_FAILURE() {
        return kGUARD_EXC_RECLAIM_INDEX_FAILURE;
    }
    private static final int kGUARD_EXC_RECLAIM_DEALLOCATE_FAILURE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum virtual_memory_guard_exception_codes.kGUARD_EXC_RECLAIM_DEALLOCATE_FAILURE = 8
     * }
     */
    public static int kGUARD_EXC_RECLAIM_DEALLOCATE_FAILURE() {
        return kGUARD_EXC_RECLAIM_DEALLOCATE_FAILURE;
    }
    /**
     * {@snippet lang=c :
     * typedef int vm_prot_t
     * }
     */
    public static final OfInt vm_prot_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int vm_sync_t
     * }
     */
    public static final OfInt vm_sync_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef vm_offset_t pointer_t
     * }
     */
    public static final OfLong pointer_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef vm_offset_t vm_address_t
     * }
     */
    public static final OfLong vm_address_t = ObjCRuntime.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t addr64_t
     * }
     */
    public static final OfLong addr64_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint32_t reg64_t
     * }
     */
    public static final OfInt reg64_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t ppnum_t
     * }
     */
    public static final OfInt ppnum_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t vm_map_t
     * }
     */
    public static final OfInt vm_map_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t vm_map_read_t
     * }
     */
    public static final OfInt vm_map_read_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t vm_map_inspect_t
     * }
     */
    public static final OfInt vm_map_inspect_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t upl_t
     * }
     */
    public static final OfInt upl_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t vm_named_entry_t
     * }
     */
    public static final OfInt vm_named_entry_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_object_offset_t
     * }
     */
    public static final OfLong vm_object_offset_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_object_size_t
     * }
     */
    public static final OfLong vm_object_size_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct mach_vm_range {
     *     mach_vm_offset_t min_address;
     *     mach_vm_offset_t max_address;
     * } *mach_vm_range_t
     * }
     */
    public static final AddressLayout mach_vm_range_t = ObjCRuntime.C_POINTER;
    private static final int MACH_VM_RANGE_FLAVOR_INVALID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_FLAVOR_INVALID = 0
     * }
     */
    public static int MACH_VM_RANGE_FLAVOR_INVALID() {
        return MACH_VM_RANGE_FLAVOR_INVALID;
    }
    private static final int MACH_VM_RANGE_FLAVOR_V1 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_FLAVOR_V1 = 1
     * }
     */
    public static int MACH_VM_RANGE_FLAVOR_V1() {
        return MACH_VM_RANGE_FLAVOR_V1;
    }
    private static final long MACH_VM_RANGE_NONE = 0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_NONE = 0
     * }
     */
    public static long MACH_VM_RANGE_NONE() {
        return MACH_VM_RANGE_NONE;
    }
    private static final short MACH_VM_RANGE_DEFAULT = (short)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_DEFAULT = 0
     * }
     */
    public static short MACH_VM_RANGE_DEFAULT() {
        return MACH_VM_RANGE_DEFAULT;
    }
    private static final short MACH_VM_RANGE_DATA = (short)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_DATA = 1
     * }
     */
    public static short MACH_VM_RANGE_DATA() {
        return MACH_VM_RANGE_DATA;
    }
    private static final short MACH_VM_RANGE_FIXED = (short)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MACH_VM_RANGE_FIXED = 2
     * }
     */
    public static short MACH_VM_RANGE_FIXED() {
        return MACH_VM_RANGE_FIXED;
    }
    /**
     * {@snippet lang=c :
     * typedef uint8_t *mach_vm_range_recipes_raw_t
     * }
     */
    public static final AddressLayout mach_vm_range_recipes_raw_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long memory_object_offset_t
     * }
     */
    public static final OfLong memory_object_offset_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long memory_object_size_t
     * }
     */
    public static final OfLong memory_object_size_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef natural_t memory_object_cluster_size_t
     * }
     */
    public static final OfInt memory_object_cluster_size_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t *memory_object_fault_info_t
     * }
     */
    public static final AddressLayout memory_object_fault_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long vm_object_id_t
     * }
     */
    public static final OfLong vm_object_id_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t memory_object_t
     * }
     */
    public static final OfInt memory_object_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t memory_object_control_t
     * }
     */
    public static final OfInt memory_object_control_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef memory_object_t *memory_object_array_t
     * }
     */
    public static final AddressLayout memory_object_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t memory_object_name_t
     * }
     */
    public static final OfInt memory_object_name_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t memory_object_default_t
     * }
     */
    public static final OfInt memory_object_default_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int memory_object_copy_strategy_t
     * }
     */
    public static final OfInt memory_object_copy_strategy_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int memory_object_return_t
     * }
     */
    public static final OfInt memory_object_return_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int *memory_object_info_t
     * }
     */
    public static final AddressLayout memory_object_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int memory_object_flavor_t
     * }
     */
    public static final OfInt memory_object_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct memory_object_behave_info {
     *     memory_object_copy_strategy_t copy_strategy;
     *     boolean_t temporary;
     *     boolean_t invalidate;
     *     boolean_t silent_overwrite;
     *     boolean_t advisory_pageout;
     * } *memory_object_behave_info_t
     * }
     */
    public static final AddressLayout memory_object_behave_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct memory_object_perf_info {
     *     memory_object_cluster_size_t cluster_size;
     *     boolean_t may_cache;
     * } *memory_object_perf_info_t
     * }
     */
    public static final AddressLayout memory_object_perf_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct memory_object_attr_info {
     *     memory_object_copy_strategy_t copy_strategy;
     *     memory_object_cluster_size_t cluster_size;
     *     boolean_t may_cache_object;
     *     boolean_t temporary;
     * } *memory_object_attr_info_t
     * }
     */
    public static final AddressLayout memory_object_attr_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t *thread_state_t
     * }
     */
    public static final AddressLayout thread_state_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int thread_state_flavor_t
     * }
     */
    public static final OfInt thread_state_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef thread_state_flavor_t *thread_state_flavor_array_t
     * }
     */
    public static final AddressLayout thread_state_flavor_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int exception_type_t
     * }
     */
    public static final OfInt exception_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t exception_data_type_t
     * }
     */
    public static final OfInt exception_data_type_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t mach_exception_data_type_t
     * }
     */
    public static final OfLong mach_exception_data_type_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int exception_behavior_t
     * }
     */
    public static final OfInt exception_behavior_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef exception_data_type_t *exception_data_t
     * }
     */
    public static final AddressLayout exception_data_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_exception_data_type_t *mach_exception_data_t
     * }
     */
    public static final AddressLayout mach_exception_data_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned int exception_mask_t
     * }
     */
    public static final OfInt exception_mask_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef exception_mask_t *exception_mask_array_t
     * }
     */
    public static final AddressLayout exception_mask_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef exception_behavior_t *exception_behavior_array_t
     * }
     */
    public static final AddressLayout exception_behavior_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef thread_state_flavor_t *exception_flavor_array_t
     * }
     */
    public static final AddressLayout exception_flavor_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t *exception_port_array_t
     * }
     */
    public static final AddressLayout exception_port_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ipc_info_port_t *exception_port_info_array_t
     * }
     */
    public static final AddressLayout exception_port_info_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_exception_data_type_t mach_exception_code_t
     * }
     */
    public static final OfLong mach_exception_code_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef mach_exception_data_type_t mach_exception_subcode_t
     * }
     */
    public static final OfLong mach_exception_subcode_t = ObjCRuntime.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct processor_cpu_stat {
     *     uint32_t irq_ex_cnt;
     *     uint32_t ipi_cnt;
     *     uint32_t timer_cnt;
     *     uint32_t undef_ex_cnt;
     *     uint32_t unaligned_cnt;
     *     uint32_t vfp_cnt;
     *     uint32_t vfp_shortv_cnt;
     *     uint32_t data_ex_cnt;
     *     uint32_t instr_ex_cnt;
     * } *processor_cpu_stat_t
     * }
     */
    public static final AddressLayout processor_cpu_stat_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct processor_cpu_stat64 {
     *     uint64_t irq_ex_cnt;
     *     uint64_t ipi_cnt;
     *     uint64_t timer_cnt;
     *     uint64_t undef_ex_cnt;
     *     uint64_t unaligned_cnt;
     *     uint64_t vfp_cnt;
     *     uint64_t vfp_shortv_cnt;
     *     uint64_t data_ex_cnt;
     *     uint64_t instr_ex_cnt;
     *     uint64_t pmi_cnt;
     * } *processor_cpu_stat64_t
     * }
     */
    public static final AddressLayout processor_cpu_stat64_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *processor_info_t
     * }
     */
    public static final AddressLayout processor_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *processor_info_array_t
     * }
     */
    public static final AddressLayout processor_info_array_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *processor_set_info_t
     * }
     */
    public static final AddressLayout processor_set_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int processor_flavor_t
     * }
     */
    public static final OfInt processor_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct processor_basic_info {
     *     cpu_type_t cpu_type;
     *     cpu_subtype_t cpu_subtype;
     *     boolean_t running;
     *     int slot_num;
     *     union {
     *         boolean_t is_master;
     *         boolean_t is_main;
     *     };
     * } *processor_basic_info_t
     * }
     */
    public static final AddressLayout processor_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct processor_cpu_load_info {
     *     unsigned int cpu_ticks[4];
     * } *processor_cpu_load_info_t
     * }
     */
    public static final AddressLayout processor_cpu_load_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int processor_set_flavor_t
     * }
     */
    public static final OfInt processor_set_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct processor_set_basic_info {
     *     int processor_count;
     *     int default_policy;
     * } *processor_set_basic_info_t
     * }
     */
    public static final AddressLayout processor_set_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct processor_set_load_info {
     *     int task_count;
     *     int thread_count;
     *     integer_t load_average;
     *     integer_t mach_factor;
     * } *processor_set_load_info_t
     * }
     */
    public static final AddressLayout processor_set_load_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int policy_t
     * }
     */
    public static final OfInt policy_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *policy_info_t
     * }
     */
    public static final AddressLayout policy_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *policy_base_t
     * }
     */
    public static final AddressLayout policy_base_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *policy_limit_t
     * }
     */
    public static final AddressLayout policy_limit_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_timeshare_base {
     *     integer_t base_priority;
     * } *policy_timeshare_base_t
     * }
     */
    public static final AddressLayout policy_timeshare_base_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_timeshare_limit {
     *     integer_t max_priority;
     * } *policy_timeshare_limit_t
     * }
     */
    public static final AddressLayout policy_timeshare_limit_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_timeshare_info {
     *     integer_t max_priority;
     *     integer_t base_priority;
     *     integer_t cur_priority;
     *     boolean_t depressed;
     *     integer_t depress_priority;
     * } *policy_timeshare_info_t
     * }
     */
    public static final AddressLayout policy_timeshare_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_rr_base {
     *     integer_t base_priority;
     *     integer_t quantum;
     * } *policy_rr_base_t
     * }
     */
    public static final AddressLayout policy_rr_base_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_rr_limit {
     *     integer_t max_priority;
     * } *policy_rr_limit_t
     * }
     */
    public static final AddressLayout policy_rr_limit_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_rr_info {
     *     integer_t max_priority;
     *     integer_t base_priority;
     *     integer_t quantum;
     *     boolean_t depressed;
     *     integer_t depress_priority;
     * } *policy_rr_info_t
     * }
     */
    public static final AddressLayout policy_rr_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_fifo_base {
     *     integer_t base_priority;
     * } *policy_fifo_base_t
     * }
     */
    public static final AddressLayout policy_fifo_base_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_fifo_limit {
     *     integer_t max_priority;
     * } *policy_fifo_limit_t
     * }
     */
    public static final AddressLayout policy_fifo_limit_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct policy_fifo_info {
     *     integer_t max_priority;
     *     integer_t base_priority;
     *     boolean_t depressed;
     *     integer_t depress_priority;
     * } *policy_fifo_info_t
     * }
     */
    public static final AddressLayout policy_fifo_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t task_flavor_t
     * }
     */
    public static final OfInt task_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *task_info_t
     * }
     */
    public static final AddressLayout task_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_basic_info_32 {
     *     integer_t suspend_count;
     *     natural_t virtual_size;
     *     natural_t resident_size;
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     policy_t policy;
     * } *task_basic_info_32_t
     * }
     */
    public static final AddressLayout task_basic_info_32_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_basic_info_64 {
     *     integer_t suspend_count;
     *     mach_vm_size_t virtual_size;
     *     mach_vm_size_t resident_size;
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     policy_t policy;
     * } *task_basic_info_64_t
     * }
     */
    public static final AddressLayout task_basic_info_64_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_basic_info {
     *     integer_t suspend_count;
     *     vm_size_t virtual_size;
     *     vm_size_t resident_size;
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     policy_t policy;
     * } *task_basic_info_t
     * }
     */
    public static final AddressLayout task_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_events_info {
     *     integer_t faults;
     *     integer_t pageins;
     *     integer_t cow_faults;
     *     integer_t messages_sent;
     *     integer_t messages_received;
     *     integer_t syscalls_mach;
     *     integer_t syscalls_unix;
     *     integer_t csw;
     * } *task_events_info_t
     * }
     */
    public static final AddressLayout task_events_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_thread_times_info {
     *     time_value_t user_time;
     *     time_value_t system_time;
     * } *task_thread_times_info_t
     * }
     */
    public static final AddressLayout task_thread_times_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_absolutetime_info {
     *     uint64_t total_user;
     *     uint64_t total_system;
     *     uint64_t threads_user;
     *     uint64_t threads_system;
     * } *task_absolutetime_info_t
     * }
     */
    public static final AddressLayout task_absolutetime_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_kernelmemory_info {
     *     uint64_t total_palloc;
     *     uint64_t total_pfree;
     *     uint64_t total_salloc;
     *     uint64_t total_sfree;
     * } *task_kernelmemory_info_t
     * }
     */
    public static final AddressLayout task_kernelmemory_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_affinity_tag_info {
     *     integer_t set_count;
     *     integer_t min;
     *     integer_t max;
     *     integer_t task_count;
     * } *task_affinity_tag_info_t
     * }
     */
    public static final AddressLayout task_affinity_tag_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_dyld_info {
     *     mach_vm_address_t all_image_info_addr;
     *     mach_vm_size_t all_image_info_size;
     *     integer_t all_image_info_format;
     * } *task_dyld_info_t
     * }
     */
    public static final AddressLayout task_dyld_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_basic_info_64_2 {
     *     integer_t suspend_count;
     *     mach_vm_size_t virtual_size;
     *     mach_vm_size_t resident_size;
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     policy_t policy;
     * } *task_basic_info_64_2_t
     * }
     */
    public static final AddressLayout task_basic_info_64_2_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_extmod_info {
     *     unsigned char task_uuid[16];
     *     vm_extmod_statistics_data_t extmod_statistics;
     * } *task_extmod_info_t
     * }
     */
    public static final AddressLayout task_extmod_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct mach_task_basic_info {
     *     mach_vm_size_t virtual_size;
     *     mach_vm_size_t resident_size;
     *     mach_vm_size_t resident_size_max;
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     policy_t policy;
     *     integer_t suspend_count;
     * } *mach_task_basic_info_t
     * }
     */
    public static final AddressLayout mach_task_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_power_info {
     *     uint64_t total_user;
     *     uint64_t total_system;
     *     uint64_t task_interrupt_wakeups;
     *     uint64_t task_platform_idle_wakeups;
     *     uint64_t task_timer_wakeups_bin_1;
     *     uint64_t task_timer_wakeups_bin_2;
     * } *task_power_info_t
     * }
     */
    public static final AddressLayout task_power_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_vm_info {
     *     mach_vm_size_t virtual_size;
     *     integer_t region_count;
     *     integer_t page_size;
     *     mach_vm_size_t resident_size;
     *     mach_vm_size_t resident_size_peak;
     *     mach_vm_size_t device;
     *     mach_vm_size_t device_peak;
     *     mach_vm_size_t internal;
     *     mach_vm_size_t internal_peak;
     *     mach_vm_size_t external;
     *     mach_vm_size_t external_peak;
     *     mach_vm_size_t reusable;
     *     mach_vm_size_t reusable_peak;
     *     mach_vm_size_t purgeable_volatile_pmap;
     *     mach_vm_size_t purgeable_volatile_resident;
     *     mach_vm_size_t purgeable_volatile_virtual;
     *     mach_vm_size_t compressed;
     *     mach_vm_size_t compressed_peak;
     *     mach_vm_size_t compressed_lifetime;
     *     mach_vm_size_t phys_footprint;
     *     mach_vm_address_t min_address;
     *     mach_vm_address_t max_address;
     *     int64_t ledger_phys_footprint_peak;
     *     int64_t ledger_purgeable_nonvolatile;
     *     int64_t ledger_purgeable_novolatile_compressed;
     *     int64_t ledger_purgeable_volatile;
     *     int64_t ledger_purgeable_volatile_compressed;
     *     int64_t ledger_tag_network_nonvolatile;
     *     int64_t ledger_tag_network_nonvolatile_compressed;
     *     int64_t ledger_tag_network_volatile;
     *     int64_t ledger_tag_network_volatile_compressed;
     *     int64_t ledger_tag_media_footprint;
     *     int64_t ledger_tag_media_footprint_compressed;
     *     int64_t ledger_tag_media_nofootprint;
     *     int64_t ledger_tag_media_nofootprint_compressed;
     *     int64_t ledger_tag_graphics_footprint;
     *     int64_t ledger_tag_graphics_footprint_compressed;
     *     int64_t ledger_tag_graphics_nofootprint;
     *     int64_t ledger_tag_graphics_nofootprint_compressed;
     *     int64_t ledger_tag_neural_footprint;
     *     int64_t ledger_tag_neural_footprint_compressed;
     *     int64_t ledger_tag_neural_nofootprint;
     *     int64_t ledger_tag_neural_nofootprint_compressed;
     *     uint64_t limit_bytes_remaining;
     *     integer_t decompressions;
     *     int64_t ledger_swapins;
     *     int64_t ledger_tag_neural_nofootprint_total;
     *     int64_t ledger_tag_neural_nofootprint_peak;
     * } *task_vm_info_t
     * }
     */
    public static final AddressLayout task_vm_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_trace_memory_info {
     *     uint64_t user_memory_address;
     *     uint64_t buffer_size;
     *     uint64_t mailbox_array_size;
     * } *task_trace_memory_info_t
     * }
     */
    public static final AddressLayout task_trace_memory_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_wait_state_info {
     *     uint64_t total_wait_state_time;
     *     uint64_t total_wait_sfi_state_time;
     *     uint32_t _reserved[4];
     * } *task_wait_state_info_t
     * }
     */
    public static final AddressLayout task_wait_state_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef gpu_energy_data *gpu_energy_data_t
     * }
     */
    public static final AddressLayout gpu_energy_data_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_power_info_v2 {
     *     task_power_info_data_t cpu_energy;
     *     gpu_energy_data gpu_energy;
     *     uint64_t task_energy;
     *     uint64_t task_ptime;
     *     uint64_t task_pset_switches;
     * } *task_power_info_v2_t
     * }
     */
    public static final AddressLayout task_power_info_v2_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct task_flags_info {
     *     uint32_t flags;
     * } *task_flags_info_t
     * }
     */
    public static final AddressLayout task_flags_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef uint32_t task_exc_guard_behavior_t
     * }
     */
    public static final OfInt task_exc_guard_behavior_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t task_corpse_forking_behavior_t
     * }
     */
    public static final OfInt task_corpse_forking_behavior_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t task_inspect_flavor_t
     * }
     */
    public static final OfInt task_inspect_flavor_t = ObjCRuntime.C_INT;
    private static final int TASK_INSPECT_BASIC_COUNTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum task_inspect_flavor.TASK_INSPECT_BASIC_COUNTS = 1
     * }
     */
    public static int TASK_INSPECT_BASIC_COUNTS() {
        return TASK_INSPECT_BASIC_COUNTS;
    }
    /**
     * {@snippet lang=c :
     * typedef struct task_inspect_basic_counts {
     *     uint64_t instructions;
     *     uint64_t cycles;
     * } *task_inspect_basic_counts_t
     * }
     */
    public static final AddressLayout task_inspect_basic_counts_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t *task_inspect_info_t
     * }
     */
    public static final AddressLayout task_inspect_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t task_policy_flavor_t
     * }
     */
    public static final OfInt task_policy_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *task_policy_t
     * }
     */
    public static final AddressLayout task_policy_t = ObjCRuntime.C_POINTER;
    private static final int TASK_RENICED = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_RENICED = -1
     * }
     */
    public static int TASK_RENICED() {
        return TASK_RENICED;
    }
    private static final int TASK_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_UNSPECIFIED = 0
     * }
     */
    public static int TASK_UNSPECIFIED() {
        return TASK_UNSPECIFIED;
    }
    private static final int TASK_FOREGROUND_APPLICATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_FOREGROUND_APPLICATION = 1
     * }
     */
    public static int TASK_FOREGROUND_APPLICATION() {
        return TASK_FOREGROUND_APPLICATION;
    }
    private static final int TASK_BACKGROUND_APPLICATION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_BACKGROUND_APPLICATION = 2
     * }
     */
    public static int TASK_BACKGROUND_APPLICATION() {
        return TASK_BACKGROUND_APPLICATION;
    }
    private static final int TASK_CONTROL_APPLICATION = (int)3L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_CONTROL_APPLICATION = 3
     * }
     */
    public static int TASK_CONTROL_APPLICATION() {
        return TASK_CONTROL_APPLICATION;
    }
    private static final int TASK_GRAPHICS_SERVER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_GRAPHICS_SERVER = 4
     * }
     */
    public static int TASK_GRAPHICS_SERVER() {
        return TASK_GRAPHICS_SERVER;
    }
    private static final int TASK_THROTTLE_APPLICATION = (int)5L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_THROTTLE_APPLICATION = 5
     * }
     */
    public static int TASK_THROTTLE_APPLICATION() {
        return TASK_THROTTLE_APPLICATION;
    }
    private static final int TASK_NONUI_APPLICATION = (int)6L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_NONUI_APPLICATION = 6
     * }
     */
    public static int TASK_NONUI_APPLICATION() {
        return TASK_NONUI_APPLICATION;
    }
    private static final int TASK_DEFAULT_APPLICATION = (int)7L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_DEFAULT_APPLICATION = 7
     * }
     */
    public static int TASK_DEFAULT_APPLICATION() {
        return TASK_DEFAULT_APPLICATION;
    }
    private static final int TASK_DARWINBG_APPLICATION = (int)8L;
    /**
     * {@snippet lang=c :
     * enum task_role.TASK_DARWINBG_APPLICATION = 8
     * }
     */
    public static int TASK_DARWINBG_APPLICATION() {
        return TASK_DARWINBG_APPLICATION;
    }
    /**
     * {@snippet lang=c :
     * typedef struct task_category_policy {
     *     task_role_t role;
     * } *task_category_policy_t
     * }
     */
    public static final AddressLayout task_category_policy_t = ObjCRuntime.C_POINTER;
    private static final int LATENCY_QOS_TIER_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_UNSPECIFIED = 0
     * }
     */
    public static int LATENCY_QOS_TIER_UNSPECIFIED() {
        return LATENCY_QOS_TIER_UNSPECIFIED;
    }
    private static final int LATENCY_QOS_TIER_0 = (int)16711681L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_0 = 16711681
     * }
     */
    public static int LATENCY_QOS_TIER_0() {
        return LATENCY_QOS_TIER_0;
    }
    private static final int LATENCY_QOS_TIER_1 = (int)16711682L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_1 = 16711682
     * }
     */
    public static int LATENCY_QOS_TIER_1() {
        return LATENCY_QOS_TIER_1;
    }
    private static final int LATENCY_QOS_TIER_2 = (int)16711683L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_2 = 16711683
     * }
     */
    public static int LATENCY_QOS_TIER_2() {
        return LATENCY_QOS_TIER_2;
    }
    private static final int LATENCY_QOS_TIER_3 = (int)16711684L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_3 = 16711684
     * }
     */
    public static int LATENCY_QOS_TIER_3() {
        return LATENCY_QOS_TIER_3;
    }
    private static final int LATENCY_QOS_TIER_4 = (int)16711685L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_4 = 16711685
     * }
     */
    public static int LATENCY_QOS_TIER_4() {
        return LATENCY_QOS_TIER_4;
    }
    private static final int LATENCY_QOS_TIER_5 = (int)16711686L;
    /**
     * {@snippet lang=c :
     * enum task_latency_qos.LATENCY_QOS_TIER_5 = 16711686
     * }
     */
    public static int LATENCY_QOS_TIER_5() {
        return LATENCY_QOS_TIER_5;
    }
    /**
     * {@snippet lang=c :
     * typedef integer_t task_latency_qos_t
     * }
     */
    public static final OfInt task_latency_qos_t = ObjCRuntime.C_INT;
    private static final int THROUGHPUT_QOS_TIER_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_UNSPECIFIED = 0
     * }
     */
    public static int THROUGHPUT_QOS_TIER_UNSPECIFIED() {
        return THROUGHPUT_QOS_TIER_UNSPECIFIED;
    }
    private static final int THROUGHPUT_QOS_TIER_0 = (int)16646145L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_0 = 16646145
     * }
     */
    public static int THROUGHPUT_QOS_TIER_0() {
        return THROUGHPUT_QOS_TIER_0;
    }
    private static final int THROUGHPUT_QOS_TIER_1 = (int)16646146L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_1 = 16646146
     * }
     */
    public static int THROUGHPUT_QOS_TIER_1() {
        return THROUGHPUT_QOS_TIER_1;
    }
    private static final int THROUGHPUT_QOS_TIER_2 = (int)16646147L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_2 = 16646147
     * }
     */
    public static int THROUGHPUT_QOS_TIER_2() {
        return THROUGHPUT_QOS_TIER_2;
    }
    private static final int THROUGHPUT_QOS_TIER_3 = (int)16646148L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_3 = 16646148
     * }
     */
    public static int THROUGHPUT_QOS_TIER_3() {
        return THROUGHPUT_QOS_TIER_3;
    }
    private static final int THROUGHPUT_QOS_TIER_4 = (int)16646149L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_4 = 16646149
     * }
     */
    public static int THROUGHPUT_QOS_TIER_4() {
        return THROUGHPUT_QOS_TIER_4;
    }
    private static final int THROUGHPUT_QOS_TIER_5 = (int)16646150L;
    /**
     * {@snippet lang=c :
     * enum task_throughput_qos.THROUGHPUT_QOS_TIER_5 = 16646150
     * }
     */
    public static int THROUGHPUT_QOS_TIER_5() {
        return THROUGHPUT_QOS_TIER_5;
    }
    /**
     * {@snippet lang=c :
     * typedef integer_t task_throughput_qos_t
     * }
     */
    public static final OfInt task_throughput_qos_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct task_qos_policy {
     *     task_latency_qos_t task_latency_qos_tier;
     *     task_throughput_qos_t task_throughput_qos_tier;
     * } *task_qos_policy_t
     * }
     */
    public static final AddressLayout task_qos_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int task_special_port_t
     * }
     */
    public static final OfInt task_special_port_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t thread_flavor_t
     * }
     */
    public static final OfInt thread_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *thread_info_t
     * }
     */
    public static final AddressLayout thread_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_basic_info {
     *     time_value_t user_time;
     *     time_value_t system_time;
     *     integer_t cpu_usage;
     *     policy_t policy;
     *     integer_t run_state;
     *     integer_t flags;
     *     integer_t suspend_count;
     *     integer_t sleep_time;
     * } *thread_basic_info_t
     * }
     */
    public static final AddressLayout thread_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_identifier_info {
     *     uint64_t thread_id;
     *     uint64_t thread_handle;
     *     uint64_t dispatch_qaddr;
     * } *thread_identifier_info_t
     * }
     */
    public static final AddressLayout thread_identifier_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_extended_info {
     *     uint64_t pth_user_time;
     *     uint64_t pth_system_time;
     *     int32_t pth_cpu_usage;
     *     int32_t pth_policy;
     *     int32_t pth_run_state;
     *     int32_t pth_flags;
     *     int32_t pth_sleep_time;
     *     int32_t pth_curpri;
     *     int32_t pth_priority;
     *     int32_t pth_maxpriority;
     *     char pth_name[64];
     * } *thread_extended_info_t
     * }
     */
    public static final AddressLayout thread_extended_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct io_stat_info {
     *     struct io_stat_entry disk_reads;
     *     struct io_stat_entry io_priority[4];
     *     struct io_stat_entry paging;
     *     struct io_stat_entry metadata;
     *     struct io_stat_entry total_io;
     * } *io_stat_info_t
     * }
     */
    public static final AddressLayout io_stat_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t thread_policy_flavor_t
     * }
     */
    public static final OfInt thread_policy_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *thread_policy_t
     * }
     */
    public static final AddressLayout thread_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_standard_policy {
     *     natural_t no_data;
     * } *thread_standard_policy_t
     * }
     */
    public static final AddressLayout thread_standard_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_extended_policy {
     *     boolean_t timeshare;
     * } *thread_extended_policy_t
     * }
     */
    public static final AddressLayout thread_extended_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_time_constraint_policy {
     *     uint32_t period;
     *     uint32_t computation;
     *     uint32_t constraint;
     *     boolean_t preemptible;
     * } *thread_time_constraint_policy_t
     * }
     */
    public static final AddressLayout thread_time_constraint_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_precedence_policy {
     *     integer_t importance;
     * } *thread_precedence_policy_t
     * }
     */
    public static final AddressLayout thread_precedence_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_affinity_policy {
     *     integer_t affinity_tag;
     * } *thread_affinity_policy_t
     * }
     */
    public static final AddressLayout thread_affinity_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct thread_background_policy {
     *     integer_t priority;
     * } *thread_background_policy_t
     * }
     */
    public static final AddressLayout thread_background_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t thread_latency_qos_t
     * }
     */
    public static final OfInt thread_latency_qos_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct thread_latency_qos_policy {
     *     thread_latency_qos_t thread_latency_qos_tier;
     * } *thread_latency_qos_policy_t
     * }
     */
    public static final AddressLayout thread_latency_qos_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef integer_t thread_throughput_qos_t
     * }
     */
    public static final OfInt thread_throughput_qos_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct thread_throughput_qos_policy {
     *     thread_throughput_qos_t thread_throughput_qos_tier;
     * } *thread_throughput_qos_policy_t
     * }
     */
    public static final AddressLayout thread_throughput_qos_policy_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned int vm_machine_attribute_t
     * }
     */
    public static final OfInt vm_machine_attribute_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int vm_machine_attribute_val_t
     * }
     */
    public static final OfInt vm_machine_attribute_val_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int vm_inherit_t
     * }
     */
    public static final OfInt vm_inherit_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int vm_purgable_t
     * }
     */
    public static final OfInt vm_purgable_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int vm_behavior_t
     * }
     */
    public static final OfInt vm_behavior_t = ObjCRuntime.C_INT;

    private static class vm_page_size$constants {
        public static final OfLong LAYOUT = ObjCRuntime.C_LONG;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_page_size").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_size
     * }
     */
    public static OfLong vm_page_size$layout() {
        return vm_page_size$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_size
     * }
     */
    public static MemorySegment vm_page_size$segment() {
        return vm_page_size$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_size
     * }
     */
    public static long vm_page_size() {
        return vm_page_size$constants.SEGMENT.get(vm_page_size$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_size
     * }
     */
    public static void vm_page_size(long varValue) {
        vm_page_size$constants.SEGMENT.set(vm_page_size$constants.LAYOUT, 0L, varValue);
    }

    private static class vm_page_mask$constants {
        public static final OfLong LAYOUT = ObjCRuntime.C_LONG;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_page_mask").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_mask
     * }
     */
    public static OfLong vm_page_mask$layout() {
        return vm_page_mask$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_mask
     * }
     */
    public static MemorySegment vm_page_mask$segment() {
        return vm_page_mask$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_mask
     * }
     */
    public static long vm_page_mask() {
        return vm_page_mask$constants.SEGMENT.get(vm_page_mask$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_page_mask
     * }
     */
    public static void vm_page_mask(long varValue) {
        vm_page_mask$constants.SEGMENT.set(vm_page_mask$constants.LAYOUT, 0L, varValue);
    }

    private static class vm_page_shift$constants {
        public static final OfInt LAYOUT = ObjCRuntime.C_INT;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_page_shift").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int vm_page_shift
     * }
     */
    public static OfInt vm_page_shift$layout() {
        return vm_page_shift$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int vm_page_shift
     * }
     */
    public static MemorySegment vm_page_shift$segment() {
        return vm_page_shift$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int vm_page_shift
     * }
     */
    public static int vm_page_shift() {
        return vm_page_shift$constants.SEGMENT.get(vm_page_shift$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int vm_page_shift
     * }
     */
    public static void vm_page_shift(int varValue) {
        vm_page_shift$constants.SEGMENT.set(vm_page_shift$constants.LAYOUT, 0L, varValue);
    }

    private static class vm_kernel_page_size$constants {
        public static final OfLong LAYOUT = ObjCRuntime.C_LONG;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_kernel_page_size").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_size
     * }
     */
    public static OfLong vm_kernel_page_size$layout() {
        return vm_kernel_page_size$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_size
     * }
     */
    public static MemorySegment vm_kernel_page_size$segment() {
        return vm_kernel_page_size$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_size
     * }
     */
    public static long vm_kernel_page_size() {
        return vm_kernel_page_size$constants.SEGMENT.get(vm_kernel_page_size$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_size
     * }
     */
    public static void vm_kernel_page_size(long varValue) {
        vm_kernel_page_size$constants.SEGMENT.set(vm_kernel_page_size$constants.LAYOUT, 0L, varValue);
    }

    private static class vm_kernel_page_mask$constants {
        public static final OfLong LAYOUT = ObjCRuntime.C_LONG;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_kernel_page_mask").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_mask
     * }
     */
    public static OfLong vm_kernel_page_mask$layout() {
        return vm_kernel_page_mask$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_mask
     * }
     */
    public static MemorySegment vm_kernel_page_mask$segment() {
        return vm_kernel_page_mask$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_mask
     * }
     */
    public static long vm_kernel_page_mask() {
        return vm_kernel_page_mask$constants.SEGMENT.get(vm_kernel_page_mask$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern vm_size_t vm_kernel_page_mask
     * }
     */
    public static void vm_kernel_page_mask(long varValue) {
        vm_kernel_page_mask$constants.SEGMENT.set(vm_kernel_page_mask$constants.LAYOUT, 0L, varValue);
    }

    private static class vm_kernel_page_shift$constants {
        public static final OfInt LAYOUT = ObjCRuntime.C_INT;
        public static final MemorySegment SEGMENT = ObjCRuntime.findOrThrow("vm_kernel_page_shift").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int vm_kernel_page_shift
     * }
     */
    public static OfInt vm_kernel_page_shift$layout() {
        return vm_kernel_page_shift$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int vm_kernel_page_shift
     * }
     */
    public static MemorySegment vm_kernel_page_shift$segment() {
        return vm_kernel_page_shift$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int vm_kernel_page_shift
     * }
     */
    public static int vm_kernel_page_shift() {
        return vm_kernel_page_shift$constants.SEGMENT.get(vm_kernel_page_shift$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int vm_kernel_page_shift
     * }
     */
    public static void vm_kernel_page_shift(int varValue) {
        vm_kernel_page_shift$constants.SEGMENT.set(vm_kernel_page_shift$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_object_id_t
     * }
     */
    public static final OfInt vm32_object_id_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int *vm_region_info_t
     * }
     */
    public static final AddressLayout vm_region_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int *vm_region_info_64_t
     * }
     */
    public static final AddressLayout vm_region_info_64_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int *vm_region_recurse_info_t
     * }
     */
    public static final AddressLayout vm_region_recurse_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int *vm_region_recurse_info_64_t
     * }
     */
    public static final AddressLayout vm_region_recurse_info_64_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int vm_region_flavor_t
     * }
     */
    public static final OfInt vm_region_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct vm_region_basic_info_64 {
     *     vm_prot_t protection;
     *     vm_prot_t max_protection;
     *     vm_inherit_t inheritance;
     *     boolean_t shared;
     *     boolean_t reserved;
     *     memory_object_offset_t offset;
     *     vm_behavior_t behavior;
     *     unsigned short user_wired_count;
     * } *vm_region_basic_info_64_t
     * }
     */
    public static final AddressLayout vm_region_basic_info_64_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vm_region_basic_info {
     *     vm_prot_t protection;
     *     vm_prot_t max_protection;
     *     vm_inherit_t inheritance;
     *     boolean_t shared;
     *     boolean_t reserved;
     *     uint32_t offset;
     *     vm_behavior_t behavior;
     *     unsigned short user_wired_count;
     * } *vm_region_basic_info_t
     * }
     */
    public static final AddressLayout vm_region_basic_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vm_region_extended_info {
     *     vm_prot_t protection;
     *     unsigned int user_tag;
     *     unsigned int pages_resident;
     *     unsigned int pages_shared_now_private;
     *     unsigned int pages_swapped_out;
     *     unsigned int pages_dirtied;
     *     unsigned int ref_count;
     *     unsigned short shadow_depth;
     *     unsigned char external_pager;
     *     unsigned char share_mode;
     *     unsigned int pages_reusable;
     * } *vm_region_extended_info_t
     * }
     */
    public static final AddressLayout vm_region_extended_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vm_region_top_info {
     *     unsigned int obj_id;
     *     unsigned int ref_count;
     *     unsigned int private_pages_resident;
     *     unsigned int shared_pages_resident;
     *     unsigned char share_mode;
     * } *vm_region_top_info_t
     * }
     */
    public static final AddressLayout vm_region_top_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vm_region_submap_info {
     *     vm_prot_t protection;
     *     vm_prot_t max_protection;
     *     vm_inherit_t inheritance;
     *     uint32_t offset;
     *     unsigned int user_tag;
     *     unsigned int pages_resident;
     *     unsigned int pages_shared_now_private;
     *     unsigned int pages_swapped_out;
     *     unsigned int pages_dirtied;
     *     unsigned int ref_count;
     *     unsigned short shadow_depth;
     *     unsigned char external_pager;
     *     unsigned char share_mode;
     *     boolean_t is_submap;
     *     vm_behavior_t behavior;
     *     vm32_object_id_t object_id;
     *     unsigned short user_wired_count;
     * } *vm_region_submap_info_t
     * }
     */
    public static final AddressLayout vm_region_submap_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vm_region_submap_info_64 {
     *     vm_prot_t protection;
     *     vm_prot_t max_protection;
     *     vm_inherit_t inheritance;
     *     memory_object_offset_t offset;
     *     unsigned int user_tag;
     *     unsigned int pages_resident;
     *     unsigned int pages_shared_now_private;
     *     unsigned int pages_swapped_out;
     *     unsigned int pages_dirtied;
     *     unsigned int ref_count;
     *     unsigned short shadow_depth;
     *     unsigned char external_pager;
     *     unsigned char share_mode;
     *     boolean_t is_submap;
     *     vm_behavior_t behavior;
     *     vm32_object_id_t object_id;
     *     unsigned short user_wired_count;
     *     unsigned int pages_reusable;
     *     vm_object_id_t object_id_full;
     * } *vm_region_submap_info_64_t
     * }
     */
    public static final AddressLayout vm_region_submap_info_64_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct vm_region_submap_short_info_64 {
     *     vm_prot_t protection;
     *     vm_prot_t max_protection;
     *     vm_inherit_t inheritance;
     *     memory_object_offset_t offset;
     *     unsigned int user_tag;
     *     unsigned int ref_count;
     *     unsigned short shadow_depth;
     *     unsigned char external_pager;
     *     unsigned char share_mode;
     *     boolean_t is_submap;
     *     vm_behavior_t behavior;
     *     vm32_object_id_t object_id;
     *     unsigned short user_wired_count;
     * } *vm_region_submap_short_info_64_t
     * }
     */
    public static final AddressLayout vm_region_submap_short_info_64_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int *vm_page_info_t
     * }
     */
    public static final AddressLayout vm_page_info_t = ObjCRuntime.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int vm_page_info_flavor_t
     * }
     */
    public static final OfInt vm_page_info_flavor_t = ObjCRuntime.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct vm_page_info_basic {
     *     int disposition;
     *     int ref_count;
     *     vm_object_id_t object_id;
     *     memory_object_offset_t offset;
     *     int depth;
     *     int __pad;
     * } *vm_page_info_basic_t
     * }
     */
    public static final AddressLayout vm_page_info_basic_t = ObjCRuntime.C_POINTER;
    private static final int MALLOC_TYPE_CALLSITE_FLAGS_V0_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MALLOC_TYPE_CALLSITE_FLAGS_V0_NONE = 0
     * }
     */
    public static int MALLOC_TYPE_CALLSITE_FLAGS_V0_NONE() {
        return MALLOC_TYPE_CALLSITE_FLAGS_V0_NONE;
    }
    private static final int MALLOC_TYPE_CALLSITE_FLAGS_V0_FIXED_SIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MALLOC_TYPE_CALLSITE_FLAGS_V0_FIXED_SIZE = 1
     * }
     */
    public static int MALLOC_TYPE_CALLSITE_FLAGS_V0_FIXED_SIZE() {
        return MALLOC_TYPE_CALLSITE_FLAGS_V0_FIXED_SIZE;
    }
    private static final int MALLOC_TYPE_CALLSITE_FLAGS_V0_ARRAY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MALLOC_TYPE_CALLSITE_FLAGS_V0_ARRAY = 2
     * }
     */
    public static int MALLOC_TYPE_CALLSITE_FLAGS_V0_ARRAY() {
        return MALLOC_TYPE_CALLSITE_FLAGS_V0_ARRAY;
    }
    private static final int MALLOC_TYPE_KIND_V0_OTHER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MALLOC_TYPE_KIND_V0_OTHER = 0
     * }
     */
    public static int MALLOC_TYPE_KIND_V0_OTHER() {
        return MALLOC_TYPE_KIND_V0_OTHER;
    }
    private static final int MALLOC_TYPE_KIND_V0_OBJC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MALLOC_TYPE_KIND_V0_OBJC = 1
     * }
     */
    public static int MALLOC_TYPE_KIND_V0_OBJC() {
        return MALLOC_TYPE_KIND_V0_OBJC;
    }
    private static final int MALLOC_TYPE_KIND_V0_SWIFT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MALLOC_TYPE_KIND_V0_SWIFT = 2
     * }
     */
    public static int MALLOC_TYPE_KIND_V0_SWIFT() {
        return MALLOC_TYPE_KIND_V0_SWIFT;
    }
    private static final int MALLOC_TYPE_KIND_V0_CXX = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MALLOC_TYPE_KIND_V0_CXX = 3
     * }
     */
    public static int MALLOC_TYPE_KIND_V0_CXX() {
        return MALLOC_TYPE_KIND_V0_CXX;
    }

    private static class malloc_default_zone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_default_zone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_default_zone()
     * }
     */
    public static FunctionDescriptor malloc_default_zone$descriptor() {
        return malloc_default_zone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_default_zone()
     * }
     */
    public static MethodHandle malloc_default_zone$handle() {
        return malloc_default_zone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_default_zone()
     * }
     */
    public static MemorySegment malloc_default_zone$address() {
        return malloc_default_zone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_default_zone()
     * }
     */
    public static MemorySegment malloc_default_zone() {
        var mh$ = malloc_default_zone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_default_zone");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_create_zone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_create_zone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_create_zone(vm_size_t start_size, unsigned int flags)
     * }
     */
    public static FunctionDescriptor malloc_create_zone$descriptor() {
        return malloc_create_zone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_create_zone(vm_size_t start_size, unsigned int flags)
     * }
     */
    public static MethodHandle malloc_create_zone$handle() {
        return malloc_create_zone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_create_zone(vm_size_t start_size, unsigned int flags)
     * }
     */
    public static MemorySegment malloc_create_zone$address() {
        return malloc_create_zone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_create_zone(vm_size_t start_size, unsigned int flags)
     * }
     */
    public static MemorySegment malloc_create_zone(long start_size, int flags) {
        var mh$ = malloc_create_zone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_create_zone", start_size, flags);
            }
            return (MemorySegment)mh$.invokeExact(start_size, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_destroy_zone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_destroy_zone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_destroy_zone(malloc_zone_t *zone)
     * }
     */
    public static FunctionDescriptor malloc_destroy_zone$descriptor() {
        return malloc_destroy_zone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_destroy_zone(malloc_zone_t *zone)
     * }
     */
    public static MethodHandle malloc_destroy_zone$handle() {
        return malloc_destroy_zone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_destroy_zone(malloc_zone_t *zone)
     * }
     */
    public static MemorySegment malloc_destroy_zone$address() {
        return malloc_destroy_zone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_destroy_zone(malloc_zone_t *zone)
     * }
     */
    public static void malloc_destroy_zone(MemorySegment zone) {
        var mh$ = malloc_destroy_zone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_destroy_zone", zone);
            }
            mh$.invokeExact(zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc_zone_malloc(malloc_zone_t *zone, size_t size)
     * }
     */
    public static FunctionDescriptor malloc_zone_malloc$descriptor() {
        return malloc_zone_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc_zone_malloc(malloc_zone_t *zone, size_t size)
     * }
     */
    public static MethodHandle malloc_zone_malloc$handle() {
        return malloc_zone_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc_zone_malloc(malloc_zone_t *zone, size_t size)
     * }
     */
    public static MemorySegment malloc_zone_malloc$address() {
        return malloc_zone_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc_zone_malloc(malloc_zone_t *zone, size_t size)
     * }
     */
    public static MemorySegment malloc_zone_malloc(MemorySegment zone, long size) {
        var mh$ = malloc_zone_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_malloc", zone, size);
            }
            return (MemorySegment)mh$.invokeExact(zone, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)
     * }
     */
    public static FunctionDescriptor malloc_zone_calloc$descriptor() {
        return malloc_zone_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)
     * }
     */
    public static MethodHandle malloc_zone_calloc$handle() {
        return malloc_zone_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)
     * }
     */
    public static MemorySegment malloc_zone_calloc$address() {
        return malloc_zone_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)
     * }
     */
    public static MemorySegment malloc_zone_calloc(MemorySegment zone, long num_items, long size) {
        var mh$ = malloc_zone_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_calloc", zone, num_items, size);
            }
            return (MemorySegment)mh$.invokeExact(zone, num_items, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc_zone_valloc(malloc_zone_t *zone, size_t size)
     * }
     */
    public static FunctionDescriptor malloc_zone_valloc$descriptor() {
        return malloc_zone_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc_zone_valloc(malloc_zone_t *zone, size_t size)
     * }
     */
    public static MethodHandle malloc_zone_valloc$handle() {
        return malloc_zone_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc_zone_valloc(malloc_zone_t *zone, size_t size)
     * }
     */
    public static MemorySegment malloc_zone_valloc$address() {
        return malloc_zone_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc_zone_valloc(malloc_zone_t *zone, size_t size)
     * }
     */
    public static MemorySegment malloc_zone_valloc(MemorySegment zone, long size) {
        var mh$ = malloc_zone_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_valloc", zone, size);
            }
            return (MemorySegment)mh$.invokeExact(zone, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_zone_free(malloc_zone_t *zone, void *ptr)
     * }
     */
    public static FunctionDescriptor malloc_zone_free$descriptor() {
        return malloc_zone_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_zone_free(malloc_zone_t *zone, void *ptr)
     * }
     */
    public static MethodHandle malloc_zone_free$handle() {
        return malloc_zone_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_zone_free(malloc_zone_t *zone, void *ptr)
     * }
     */
    public static MemorySegment malloc_zone_free$address() {
        return malloc_zone_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_zone_free(malloc_zone_t *zone, void *ptr)
     * }
     */
    public static void malloc_zone_free(MemorySegment zone, MemorySegment ptr) {
        var mh$ = malloc_zone_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_free", zone, ptr);
            }
            mh$.invokeExact(zone, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor malloc_zone_realloc$descriptor() {
        return malloc_zone_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size)
     * }
     */
    public static MethodHandle malloc_zone_realloc$handle() {
        return malloc_zone_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size)
     * }
     */
    public static MemorySegment malloc_zone_realloc$address() {
        return malloc_zone_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size)
     * }
     */
    public static MemorySegment malloc_zone_realloc(MemorySegment zone, MemorySegment ptr, long size) {
        var mh$ = malloc_zone_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_realloc", zone, ptr, size);
            }
            return (MemorySegment)mh$.invokeExact(zone, ptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_from_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_from_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_zone_from_ptr(const void *ptr)
     * }
     */
    public static FunctionDescriptor malloc_zone_from_ptr$descriptor() {
        return malloc_zone_from_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_zone_from_ptr(const void *ptr)
     * }
     */
    public static MethodHandle malloc_zone_from_ptr$handle() {
        return malloc_zone_from_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_zone_from_ptr(const void *ptr)
     * }
     */
    public static MemorySegment malloc_zone_from_ptr$address() {
        return malloc_zone_from_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_zone_from_ptr(const void *ptr)
     * }
     */
    public static MemorySegment malloc_zone_from_ptr(MemorySegment ptr) {
        var mh$ = malloc_zone_from_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_from_ptr", ptr);
            }
            return (MemorySegment)mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t malloc_size(const void *ptr)
     * }
     */
    public static FunctionDescriptor malloc_size$descriptor() {
        return malloc_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t malloc_size(const void *ptr)
     * }
     */
    public static MethodHandle malloc_size$handle() {
        return malloc_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t malloc_size(const void *ptr)
     * }
     */
    public static MemorySegment malloc_size$address() {
        return malloc_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t malloc_size(const void *ptr)
     * }
     */
    public static long malloc_size(MemorySegment ptr) {
        var mh$ = malloc_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_size", ptr);
            }
            return (long)mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_good_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_good_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t malloc_good_size(size_t size)
     * }
     */
    public static FunctionDescriptor malloc_good_size$descriptor() {
        return malloc_good_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t malloc_good_size(size_t size)
     * }
     */
    public static MethodHandle malloc_good_size$handle() {
        return malloc_good_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t malloc_good_size(size_t size)
     * }
     */
    public static MemorySegment malloc_good_size$address() {
        return malloc_good_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t malloc_good_size(size_t size)
     * }
     */
    public static long malloc_good_size(long size) {
        var mh$ = malloc_good_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_good_size", size);
            }
            return (long)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size)
     * }
     */
    public static FunctionDescriptor malloc_zone_memalign$descriptor() {
        return malloc_zone_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size)
     * }
     */
    public static MethodHandle malloc_zone_memalign$handle() {
        return malloc_zone_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size)
     * }
     */
    public static MemorySegment malloc_zone_memalign$address() {
        return malloc_zone_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size)
     * }
     */
    public static MemorySegment malloc_zone_memalign(MemorySegment zone, long alignment, long size) {
        var mh$ = malloc_zone_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_memalign", zone, alignment, size);
            }
            return (MemorySegment)mh$.invokeExact(zone, alignment, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_batch_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_batch_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int malloc_zone_batch_malloc(malloc_zone_t *zone, size_t size, void **results, unsigned int num_requested)
     * }
     */
    public static FunctionDescriptor malloc_zone_batch_malloc$descriptor() {
        return malloc_zone_batch_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int malloc_zone_batch_malloc(malloc_zone_t *zone, size_t size, void **results, unsigned int num_requested)
     * }
     */
    public static MethodHandle malloc_zone_batch_malloc$handle() {
        return malloc_zone_batch_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int malloc_zone_batch_malloc(malloc_zone_t *zone, size_t size, void **results, unsigned int num_requested)
     * }
     */
    public static MemorySegment malloc_zone_batch_malloc$address() {
        return malloc_zone_batch_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int malloc_zone_batch_malloc(malloc_zone_t *zone, size_t size, void **results, unsigned int num_requested)
     * }
     */
    public static int malloc_zone_batch_malloc(MemorySegment zone, long size, MemorySegment results, int num_requested) {
        var mh$ = malloc_zone_batch_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_batch_malloc", zone, size, results, num_requested);
            }
            return (int)mh$.invokeExact(zone, size, results, num_requested);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_batch_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_batch_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_zone_batch_free(malloc_zone_t *zone, void **to_be_freed, unsigned int num)
     * }
     */
    public static FunctionDescriptor malloc_zone_batch_free$descriptor() {
        return malloc_zone_batch_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_zone_batch_free(malloc_zone_t *zone, void **to_be_freed, unsigned int num)
     * }
     */
    public static MethodHandle malloc_zone_batch_free$handle() {
        return malloc_zone_batch_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_zone_batch_free(malloc_zone_t *zone, void **to_be_freed, unsigned int num)
     * }
     */
    public static MemorySegment malloc_zone_batch_free$address() {
        return malloc_zone_batch_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_zone_batch_free(malloc_zone_t *zone, void **to_be_freed, unsigned int num)
     * }
     */
    public static void malloc_zone_batch_free(MemorySegment zone, MemorySegment to_be_freed, int num) {
        var mh$ = malloc_zone_batch_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_batch_free", zone, to_be_freed, num);
            }
            mh$.invokeExact(zone, to_be_freed, num);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_default_purgeable_zone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER    );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_default_purgeable_zone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_default_purgeable_zone()
     * }
     */
    public static FunctionDescriptor malloc_default_purgeable_zone$descriptor() {
        return malloc_default_purgeable_zone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_default_purgeable_zone()
     * }
     */
    public static MethodHandle malloc_default_purgeable_zone$handle() {
        return malloc_default_purgeable_zone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_default_purgeable_zone()
     * }
     */
    public static MemorySegment malloc_default_purgeable_zone$address() {
        return malloc_default_purgeable_zone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern malloc_zone_t *malloc_default_purgeable_zone()
     * }
     */
    public static MemorySegment malloc_default_purgeable_zone() {
        var mh$ = malloc_default_purgeable_zone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_default_purgeable_zone");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_make_purgeable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_make_purgeable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_make_purgeable(void *ptr)
     * }
     */
    public static FunctionDescriptor malloc_make_purgeable$descriptor() {
        return malloc_make_purgeable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_make_purgeable(void *ptr)
     * }
     */
    public static MethodHandle malloc_make_purgeable$handle() {
        return malloc_make_purgeable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_make_purgeable(void *ptr)
     * }
     */
    public static MemorySegment malloc_make_purgeable$address() {
        return malloc_make_purgeable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_make_purgeable(void *ptr)
     * }
     */
    public static void malloc_make_purgeable(MemorySegment ptr) {
        var mh$ = malloc_make_purgeable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_make_purgeable", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_make_nonpurgeable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_make_nonpurgeable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int malloc_make_nonpurgeable(void *ptr)
     * }
     */
    public static FunctionDescriptor malloc_make_nonpurgeable$descriptor() {
        return malloc_make_nonpurgeable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int malloc_make_nonpurgeable(void *ptr)
     * }
     */
    public static MethodHandle malloc_make_nonpurgeable$handle() {
        return malloc_make_nonpurgeable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int malloc_make_nonpurgeable(void *ptr)
     * }
     */
    public static MemorySegment malloc_make_nonpurgeable$address() {
        return malloc_make_nonpurgeable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int malloc_make_nonpurgeable(void *ptr)
     * }
     */
    public static int malloc_make_nonpurgeable(MemorySegment ptr) {
        var mh$ = malloc_make_nonpurgeable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_make_nonpurgeable", ptr);
            }
            return (int)mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_register {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_register");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_zone_register(malloc_zone_t *zone)
     * }
     */
    public static FunctionDescriptor malloc_zone_register$descriptor() {
        return malloc_zone_register.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_zone_register(malloc_zone_t *zone)
     * }
     */
    public static MethodHandle malloc_zone_register$handle() {
        return malloc_zone_register.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_zone_register(malloc_zone_t *zone)
     * }
     */
    public static MemorySegment malloc_zone_register$address() {
        return malloc_zone_register.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_zone_register(malloc_zone_t *zone)
     * }
     */
    public static void malloc_zone_register(MemorySegment zone) {
        var mh$ = malloc_zone_register.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_register", zone);
            }
            mh$.invokeExact(zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_unregister {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_unregister");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_zone_unregister(malloc_zone_t *zone)
     * }
     */
    public static FunctionDescriptor malloc_zone_unregister$descriptor() {
        return malloc_zone_unregister.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_zone_unregister(malloc_zone_t *zone)
     * }
     */
    public static MethodHandle malloc_zone_unregister$handle() {
        return malloc_zone_unregister.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_zone_unregister(malloc_zone_t *zone)
     * }
     */
    public static MemorySegment malloc_zone_unregister$address() {
        return malloc_zone_unregister.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_zone_unregister(malloc_zone_t *zone)
     * }
     */
    public static void malloc_zone_unregister(MemorySegment zone) {
        var mh$ = malloc_zone_unregister.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_unregister", zone);
            }
            mh$.invokeExact(zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_set_zone_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_set_zone_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
     * }
     */
    public static FunctionDescriptor malloc_set_zone_name$descriptor() {
        return malloc_set_zone_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
     * }
     */
    public static MethodHandle malloc_set_zone_name$handle() {
        return malloc_set_zone_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
     * }
     */
    public static MemorySegment malloc_set_zone_name$address() {
        return malloc_set_zone_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
     * }
     */
    public static void malloc_set_zone_name(MemorySegment zone, MemorySegment name) {
        var mh$ = malloc_set_zone_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_set_zone_name", zone, name);
            }
            mh$.invokeExact(zone, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_get_zone_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_get_zone_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *malloc_get_zone_name(malloc_zone_t *zone)
     * }
     */
    public static FunctionDescriptor malloc_get_zone_name$descriptor() {
        return malloc_get_zone_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *malloc_get_zone_name(malloc_zone_t *zone)
     * }
     */
    public static MethodHandle malloc_get_zone_name$handle() {
        return malloc_get_zone_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *malloc_get_zone_name(malloc_zone_t *zone)
     * }
     */
    public static MemorySegment malloc_get_zone_name$address() {
        return malloc_get_zone_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *malloc_get_zone_name(malloc_zone_t *zone)
     * }
     */
    public static MemorySegment malloc_get_zone_name(MemorySegment zone) {
        var mh$ = malloc_get_zone_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_get_zone_name", zone);
            }
            return (MemorySegment)mh$.invokeExact(zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_pressure_relief {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_pressure_relief");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t malloc_zone_pressure_relief(malloc_zone_t *zone, size_t goal)
     * }
     */
    public static FunctionDescriptor malloc_zone_pressure_relief$descriptor() {
        return malloc_zone_pressure_relief.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t malloc_zone_pressure_relief(malloc_zone_t *zone, size_t goal)
     * }
     */
    public static MethodHandle malloc_zone_pressure_relief$handle() {
        return malloc_zone_pressure_relief.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t malloc_zone_pressure_relief(malloc_zone_t *zone, size_t goal)
     * }
     */
    public static MemorySegment malloc_zone_pressure_relief$address() {
        return malloc_zone_pressure_relief.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t malloc_zone_pressure_relief(malloc_zone_t *zone, size_t goal)
     * }
     */
    public static long malloc_zone_pressure_relief(MemorySegment zone, long goal) {
        var mh$ = malloc_zone_pressure_relief.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_pressure_relief", zone, goal);
            }
            return (long)mh$.invokeExact(zone, goal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void malloc_printf(const char *format, ...)
     * }
     */
    public static class malloc_printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                ObjCRuntime.C_POINTER
            );
        private static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private malloc_printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void malloc_printf(const char *format, ...)
         * }
         */
        public static malloc_printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new malloc_printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("malloc_printf", format, x1);
                }
                 spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class malloc_get_all_zones {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_get_all_zones");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern kern_return_t malloc_get_all_zones(task_t task, memory_reader_t reader, vm_address_t **addresses, unsigned int *count)
     * }
     */
    public static FunctionDescriptor malloc_get_all_zones$descriptor() {
        return malloc_get_all_zones.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern kern_return_t malloc_get_all_zones(task_t task, memory_reader_t reader, vm_address_t **addresses, unsigned int *count)
     * }
     */
    public static MethodHandle malloc_get_all_zones$handle() {
        return malloc_get_all_zones.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern kern_return_t malloc_get_all_zones(task_t task, memory_reader_t reader, vm_address_t **addresses, unsigned int *count)
     * }
     */
    public static MemorySegment malloc_get_all_zones$address() {
        return malloc_get_all_zones.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern kern_return_t malloc_get_all_zones(task_t task, memory_reader_t reader, vm_address_t **addresses, unsigned int *count)
     * }
     */
    public static int malloc_get_all_zones(int task, MemorySegment reader, MemorySegment addresses, MemorySegment count) {
        var mh$ = malloc_get_all_zones.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_get_all_zones", task, reader, addresses, count);
            }
            return (int)mh$.invokeExact(task, reader, addresses, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_print_ptr_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_print_ptr_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_zone_print_ptr_info(void *ptr)
     * }
     */
    public static FunctionDescriptor malloc_zone_print_ptr_info$descriptor() {
        return malloc_zone_print_ptr_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_zone_print_ptr_info(void *ptr)
     * }
     */
    public static MethodHandle malloc_zone_print_ptr_info$handle() {
        return malloc_zone_print_ptr_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_zone_print_ptr_info(void *ptr)
     * }
     */
    public static MemorySegment malloc_zone_print_ptr_info$address() {
        return malloc_zone_print_ptr_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_zone_print_ptr_info(void *ptr)
     * }
     */
    public static void malloc_zone_print_ptr_info(MemorySegment ptr) {
        var mh$ = malloc_zone_print_ptr_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_print_ptr_info", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern boolean_t malloc_zone_check(malloc_zone_t *zone)
     * }
     */
    public static FunctionDescriptor malloc_zone_check$descriptor() {
        return malloc_zone_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern boolean_t malloc_zone_check(malloc_zone_t *zone)
     * }
     */
    public static MethodHandle malloc_zone_check$handle() {
        return malloc_zone_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern boolean_t malloc_zone_check(malloc_zone_t *zone)
     * }
     */
    public static MemorySegment malloc_zone_check$address() {
        return malloc_zone_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern boolean_t malloc_zone_check(malloc_zone_t *zone)
     * }
     */
    public static int malloc_zone_check(MemorySegment zone) {
        var mh$ = malloc_zone_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_check", zone);
            }
            return (int)mh$.invokeExact(zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_zone_print(malloc_zone_t *zone, boolean_t verbose)
     * }
     */
    public static FunctionDescriptor malloc_zone_print$descriptor() {
        return malloc_zone_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_zone_print(malloc_zone_t *zone, boolean_t verbose)
     * }
     */
    public static MethodHandle malloc_zone_print$handle() {
        return malloc_zone_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_zone_print(malloc_zone_t *zone, boolean_t verbose)
     * }
     */
    public static MemorySegment malloc_zone_print$address() {
        return malloc_zone_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_zone_print(malloc_zone_t *zone, boolean_t verbose)
     * }
     */
    public static void malloc_zone_print(MemorySegment zone, int verbose) {
        var mh$ = malloc_zone_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_print", zone, verbose);
            }
            mh$.invokeExact(zone, verbose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_statistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_statistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_zone_statistics(malloc_zone_t *zone, malloc_statistics_t *stats)
     * }
     */
    public static FunctionDescriptor malloc_zone_statistics$descriptor() {
        return malloc_zone_statistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_zone_statistics(malloc_zone_t *zone, malloc_statistics_t *stats)
     * }
     */
    public static MethodHandle malloc_zone_statistics$handle() {
        return malloc_zone_statistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_zone_statistics(malloc_zone_t *zone, malloc_statistics_t *stats)
     * }
     */
    public static MemorySegment malloc_zone_statistics$address() {
        return malloc_zone_statistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_zone_statistics(malloc_zone_t *zone, malloc_statistics_t *stats)
     * }
     */
    public static void malloc_zone_statistics(MemorySegment zone, MemorySegment stats) {
        var mh$ = malloc_zone_statistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_statistics", zone, stats);
            }
            mh$.invokeExact(zone, stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_zone_log(malloc_zone_t *zone, void *address)
     * }
     */
    public static FunctionDescriptor malloc_zone_log$descriptor() {
        return malloc_zone_log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_zone_log(malloc_zone_t *zone, void *address)
     * }
     */
    public static MethodHandle malloc_zone_log$handle() {
        return malloc_zone_log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_zone_log(malloc_zone_t *zone, void *address)
     * }
     */
    public static MemorySegment malloc_zone_log$address() {
        return malloc_zone_log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_zone_log(malloc_zone_t *zone, void *address)
     * }
     */
    public static void malloc_zone_log(MemorySegment zone, MemorySegment address) {
        var mh$ = malloc_zone_log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_log", zone, address);
            }
            mh$.invokeExact(zone, address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_enable_discharge_checking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_enable_discharge_checking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern boolean_t malloc_zone_enable_discharge_checking(malloc_zone_t *zone)
     * }
     */
    public static FunctionDescriptor malloc_zone_enable_discharge_checking$descriptor() {
        return malloc_zone_enable_discharge_checking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern boolean_t malloc_zone_enable_discharge_checking(malloc_zone_t *zone)
     * }
     */
    public static MethodHandle malloc_zone_enable_discharge_checking$handle() {
        return malloc_zone_enable_discharge_checking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern boolean_t malloc_zone_enable_discharge_checking(malloc_zone_t *zone)
     * }
     */
    public static MemorySegment malloc_zone_enable_discharge_checking$address() {
        return malloc_zone_enable_discharge_checking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern boolean_t malloc_zone_enable_discharge_checking(malloc_zone_t *zone)
     * }
     */
    public static int malloc_zone_enable_discharge_checking(MemorySegment zone) {
        var mh$ = malloc_zone_enable_discharge_checking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_enable_discharge_checking", zone);
            }
            return (int)mh$.invokeExact(zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_disable_discharge_checking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_disable_discharge_checking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_zone_disable_discharge_checking(malloc_zone_t *zone)
     * }
     */
    public static FunctionDescriptor malloc_zone_disable_discharge_checking$descriptor() {
        return malloc_zone_disable_discharge_checking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_zone_disable_discharge_checking(malloc_zone_t *zone)
     * }
     */
    public static MethodHandle malloc_zone_disable_discharge_checking$handle() {
        return malloc_zone_disable_discharge_checking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_zone_disable_discharge_checking(malloc_zone_t *zone)
     * }
     */
    public static MemorySegment malloc_zone_disable_discharge_checking$address() {
        return malloc_zone_disable_discharge_checking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_zone_disable_discharge_checking(malloc_zone_t *zone)
     * }
     */
    public static void malloc_zone_disable_discharge_checking(MemorySegment zone) {
        var mh$ = malloc_zone_disable_discharge_checking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_disable_discharge_checking", zone);
            }
            mh$.invokeExact(zone);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_discharge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_discharge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_zone_discharge(malloc_zone_t *zone, void *memory)
     * }
     */
    public static FunctionDescriptor malloc_zone_discharge$descriptor() {
        return malloc_zone_discharge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_zone_discharge(malloc_zone_t *zone, void *memory)
     * }
     */
    public static MethodHandle malloc_zone_discharge$handle() {
        return malloc_zone_discharge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_zone_discharge(malloc_zone_t *zone, void *memory)
     * }
     */
    public static MemorySegment malloc_zone_discharge$address() {
        return malloc_zone_discharge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_zone_discharge(malloc_zone_t *zone, void *memory)
     * }
     */
    public static void malloc_zone_discharge(MemorySegment zone, MemorySegment memory) {
        var mh$ = malloc_zone_discharge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_discharge", zone, memory);
            }
            mh$.invokeExact(zone, memory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_zone_enumerate_discharged_pointers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("malloc_zone_enumerate_discharged_pointers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void malloc_zone_enumerate_discharged_pointers(malloc_zone_t *zone, void (^report_discharged)(void *, void *))
     * }
     */
    public static FunctionDescriptor malloc_zone_enumerate_discharged_pointers$descriptor() {
        return malloc_zone_enumerate_discharged_pointers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void malloc_zone_enumerate_discharged_pointers(malloc_zone_t *zone, void (^report_discharged)(void *, void *))
     * }
     */
    public static MethodHandle malloc_zone_enumerate_discharged_pointers$handle() {
        return malloc_zone_enumerate_discharged_pointers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void malloc_zone_enumerate_discharged_pointers(malloc_zone_t *zone, void (^report_discharged)(void *, void *))
     * }
     */
    public static MemorySegment malloc_zone_enumerate_discharged_pointers$address() {
        return malloc_zone_enumerate_discharged_pointers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void malloc_zone_enumerate_discharged_pointers(malloc_zone_t *zone, void (^report_discharged)(void *, void *))
     * }
     */
    public static void malloc_zone_enumerate_discharged_pointers(MemorySegment zone, MemorySegment report_discharged) {
        var mh$ = malloc_zone_enumerate_discharged_pointers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_zone_enumerate_discharged_pointers", zone, report_discharged);
            }
            mh$.invokeExact(zone, report_discharged);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int OBJC_RATIO_COLLECTION = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_RATIO_COLLECTION = 0
     * }
     */
    public static int OBJC_RATIO_COLLECTION() {
        return OBJC_RATIO_COLLECTION;
    }
    private static final int OBJC_GENERATIONAL_COLLECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_GENERATIONAL_COLLECTION = 1
     * }
     */
    public static int OBJC_GENERATIONAL_COLLECTION() {
        return OBJC_GENERATIONAL_COLLECTION;
    }
    private static final int OBJC_FULL_COLLECTION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_FULL_COLLECTION = 2
     * }
     */
    public static int OBJC_FULL_COLLECTION() {
        return OBJC_FULL_COLLECTION;
    }
    private static final int OBJC_EXHAUSTIVE_COLLECTION = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_EXHAUSTIVE_COLLECTION = 3
     * }
     */
    public static int OBJC_EXHAUSTIVE_COLLECTION() {
        return OBJC_EXHAUSTIVE_COLLECTION;
    }
    private static final int OBJC_COLLECT_IF_NEEDED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_COLLECT_IF_NEEDED = 8
     * }
     */
    public static int OBJC_COLLECT_IF_NEEDED() {
        return OBJC_COLLECT_IF_NEEDED;
    }
    private static final int OBJC_WAIT_UNTIL_DONE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_WAIT_UNTIL_DONE = 16
     * }
     */
    public static int OBJC_WAIT_UNTIL_DONE() {
        return OBJC_WAIT_UNTIL_DONE;
    }
    private static final int OBJC_CLEAR_RESIDENT_STACK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_CLEAR_RESIDENT_STACK = 1
     * }
     */
    public static int OBJC_CLEAR_RESIDENT_STACK() {
        return OBJC_CLEAR_RESIDENT_STACK;
    }

    private static class objc_sync_enter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_sync_enter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int objc_sync_enter(id  _Nonnull obj)
     * }
     */
    public static FunctionDescriptor objc_sync_enter$descriptor() {
        return objc_sync_enter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int objc_sync_enter(id  _Nonnull obj)
     * }
     */
    public static MethodHandle objc_sync_enter$handle() {
        return objc_sync_enter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int objc_sync_enter(id  _Nonnull obj)
     * }
     */
    public static MemorySegment objc_sync_enter$address() {
        return objc_sync_enter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int objc_sync_enter(id  _Nonnull obj)
     * }
     */
    public static int objc_sync_enter(MemorySegment obj) {
        var mh$ = objc_sync_enter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_sync_enter", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class objc_sync_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        public static final MemorySegment ADDR = ObjCRuntime.findOrThrow("objc_sync_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int objc_sync_exit(id  _Nonnull obj)
     * }
     */
    public static FunctionDescriptor objc_sync_exit$descriptor() {
        return objc_sync_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int objc_sync_exit(id  _Nonnull obj)
     * }
     */
    public static MethodHandle objc_sync_exit$handle() {
        return objc_sync_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int objc_sync_exit(id  _Nonnull obj)
     * }
     */
    public static MemorySegment objc_sync_exit$address() {
        return objc_sync_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int objc_sync_exit(id  _Nonnull obj)
     * }
     */
    public static int objc_sync_exit(MemorySegment obj) {
        var mh$ = objc_sync_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("objc_sync_exit", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int OBJC_SYNC_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_SYNC_SUCCESS = 0
     * }
     */
    public static int OBJC_SYNC_SUCCESS() {
        return OBJC_SYNC_SUCCESS;
    }
    private static final int OBJC_SYNC_NOT_OWNING_THREAD_ERROR = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OBJC_SYNC_NOT_OWNING_THREAD_ERROR = -1
     * }
     */
    public static int OBJC_SYNC_NOT_OWNING_THREAD_ERROR() {
        return OBJC_SYNC_NOT_OWNING_THREAD_ERROR;
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = ObjCRuntime.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final int NSIG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define NSIG 32
     * }
     */
    public static int NSIG() {
        return NSIG;
    }
    private static final int SIGIOT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGIOT 6
     * }
     */
    public static int SIGIOT() {
        return SIGIOT;
    }
    private static final MemorySegment SIG_DFL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define SIG_DFL (void*) 0
     * }
     */
    public static MemorySegment SIG_DFL() {
        return SIG_DFL;
    }
    private static final MemorySegment SIG_IGN = MemorySegment.ofAddress(1L);
    /**
     * {@snippet lang=c :
     * #define SIG_IGN (void*) 1
     * }
     */
    public static MemorySegment SIG_IGN() {
        return SIG_IGN;
    }
    private static final MemorySegment SIG_HOLD = MemorySegment.ofAddress(5L);
    /**
     * {@snippet lang=c :
     * #define SIG_HOLD (void*) 5
     * }
     */
    public static MemorySegment SIG_HOLD() {
        return SIG_HOLD;
    }
    private static final MemorySegment SIG_ERR = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define SIG_ERR (void*) -1
     * }
     */
    public static MemorySegment SIG_ERR() {
        return SIG_ERR;
    }
    private static final int SA_USERSPACE_MASK = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SA_USERSPACE_MASK 127
     * }
     */
    public static int SA_USERSPACE_MASK() {
        return SA_USERSPACE_MASK;
    }
    private static final int SV_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SV_ONSTACK 1
     * }
     */
    public static int SV_ONSTACK() {
        return SV_ONSTACK;
    }
    private static final int SV_INTERRUPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SV_INTERRUPT 2
     * }
     */
    public static int SV_INTERRUPT() {
        return SV_INTERRUPT;
    }
    private static final int SV_RESETHAND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SV_RESETHAND 4
     * }
     */
    public static int SV_RESETHAND() {
        return SV_RESETHAND;
    }
    private static final int SV_NODEFER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SV_NODEFER 16
     * }
     */
    public static int SV_NODEFER() {
        return SV_NODEFER;
    }
    private static final int SV_NOCLDSTOP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SV_NOCLDSTOP 8
     * }
     */
    public static int SV_NOCLDSTOP() {
        return SV_NOCLDSTOP;
    }
    private static final int SV_SIGINFO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SV_SIGINFO 64
     * }
     */
    public static int SV_SIGINFO() {
        return SV_SIGINFO;
    }
    private static final MemorySegment BADSIG = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define BADSIG (void*) -1
     * }
     */
    public static MemorySegment BADSIG() {
        return BADSIG;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final int PRIO_MIN = (int)-20L;
    /**
     * {@snippet lang=c :
     * #define PRIO_MIN -20
     * }
     */
    public static int PRIO_MIN() {
        return PRIO_MIN;
    }
    private static final int RUSAGE_CHILDREN = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_CHILDREN -1
     * }
     */
    public static int RUSAGE_CHILDREN() {
        return RUSAGE_CHILDREN;
    }
    private static final int RUSAGE_INFO_CURRENT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_CURRENT 6
     * }
     */
    public static int RUSAGE_INFO_CURRENT() {
        return RUSAGE_INFO_CURRENT;
    }
    private static final long RLIM_INFINITY = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_INFINITY 9223372036854775807
     * }
     */
    public static long RLIM_INFINITY() {
        return RLIM_INFINITY;
    }
    private static final long RLIM_SAVED_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_SAVED_MAX 9223372036854775807
     * }
     */
    public static long RLIM_SAVED_MAX() {
        return RLIM_SAVED_MAX;
    }
    private static final long RLIM_SAVED_CUR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_SAVED_CUR 9223372036854775807
     * }
     */
    public static long RLIM_SAVED_CUR() {
        return RLIM_SAVED_CUR;
    }
    private static final int RLIMIT_RSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_RSS 5
     * }
     */
    public static int RLIMIT_RSS() {
        return RLIMIT_RSS;
    }
    private static final int IOPOL_APPLICATION = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_APPLICATION 5
     * }
     */
    public static int IOPOL_APPLICATION() {
        return IOPOL_APPLICATION;
    }
    private static final int IOPOL_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_NORMAL 1
     * }
     */
    public static int IOPOL_NORMAL() {
        return IOPOL_NORMAL;
    }
    private static final int WAIT_ANY = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define WAIT_ANY -1
     * }
     */
    public static int WAIT_ANY() {
        return WAIT_ANY;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int __DARWIN_BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BYTE_ORDER 1234
     * }
     */
    public static int __DARWIN_BYTE_ORDER() {
        return __DARWIN_BYTE_ORDER;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final long __DARWIN_NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NFDBITS 32
     * }
     */
    public static long __DARWIN_NFDBITS() {
        return __DARWIN_NFDBITS;
    }
    private static final int NBBY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define NBBY 8
     * }
     */
    public static int NBBY() {
        return NBBY;
    }
    private static final long NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 32
     * }
     */
    public static long NFDBITS() {
        return NFDBITS;
    }
    private static final int FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }
    private static final boolean YES = true;
    /**
     * {@snippet lang=c :
     * #define YES 1
     * }
     */
    public static boolean YES() {
        return YES;
    }
    private static final boolean NO = false;
    /**
     * {@snippet lang=c :
     * #define NO 0
     * }
     */
    public static boolean NO() {
        return NO;
    }
    private static final MemorySegment Nil = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define Nil (void*) 0
     * }
     */
    public static MemorySegment Nil() {
        return Nil;
    }
    private static final MemorySegment nil = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define nil (void*) 0
     * }
     */
    public static MemorySegment nil() {
        return nil;
    }
    private static final MemorySegment OBJC_DYNAMIC_CLASSES = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define OBJC_DYNAMIC_CLASSES (void*) -1
     * }
     */
    public static MemorySegment OBJC_DYNAMIC_CLASSES() {
        return OBJC_DYNAMIC_CLASSES;
    }
    private static final int _C_ID = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _C_ID 64
     * }
     */
    public static int _C_ID() {
        return _C_ID;
    }
    private static final int _C_CLASS = (int)35L;
    /**
     * {@snippet lang=c :
     * #define _C_CLASS 35
     * }
     */
    public static int _C_CLASS() {
        return _C_CLASS;
    }
    private static final int _C_SEL = (int)58L;
    /**
     * {@snippet lang=c :
     * #define _C_SEL 58
     * }
     */
    public static int _C_SEL() {
        return _C_SEL;
    }
    private static final int _C_CHR = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _C_CHR 99
     * }
     */
    public static int _C_CHR() {
        return _C_CHR;
    }
    private static final int _C_UCHR = (int)67L;
    /**
     * {@snippet lang=c :
     * #define _C_UCHR 67
     * }
     */
    public static int _C_UCHR() {
        return _C_UCHR;
    }
    private static final int _C_SHT = (int)115L;
    /**
     * {@snippet lang=c :
     * #define _C_SHT 115
     * }
     */
    public static int _C_SHT() {
        return _C_SHT;
    }
    private static final int _C_USHT = (int)83L;
    /**
     * {@snippet lang=c :
     * #define _C_USHT 83
     * }
     */
    public static int _C_USHT() {
        return _C_USHT;
    }
    private static final int _C_INT = (int)105L;
    /**
     * {@snippet lang=c :
     * #define _C_INT 105
     * }
     */
    public static int _C_INT() {
        return _C_INT;
    }
    private static final int _C_UINT = (int)73L;
    /**
     * {@snippet lang=c :
     * #define _C_UINT 73
     * }
     */
    public static int _C_UINT() {
        return _C_UINT;
    }
    private static final int _C_LNG = (int)108L;
    /**
     * {@snippet lang=c :
     * #define _C_LNG 108
     * }
     */
    public static int _C_LNG() {
        return _C_LNG;
    }
    private static final int _C_ULNG = (int)76L;
    /**
     * {@snippet lang=c :
     * #define _C_ULNG 76
     * }
     */
    public static int _C_ULNG() {
        return _C_ULNG;
    }
    private static final int _C_LNG_LNG = (int)113L;
    /**
     * {@snippet lang=c :
     * #define _C_LNG_LNG 113
     * }
     */
    public static int _C_LNG_LNG() {
        return _C_LNG_LNG;
    }
    private static final int _C_ULNG_LNG = (int)81L;
    /**
     * {@snippet lang=c :
     * #define _C_ULNG_LNG 81
     * }
     */
    public static int _C_ULNG_LNG() {
        return _C_ULNG_LNG;
    }
    private static final int _C_INT128 = (int)116L;
    /**
     * {@snippet lang=c :
     * #define _C_INT128 116
     * }
     */
    public static int _C_INT128() {
        return _C_INT128;
    }
    private static final int _C_UINT128 = (int)84L;
    /**
     * {@snippet lang=c :
     * #define _C_UINT128 84
     * }
     */
    public static int _C_UINT128() {
        return _C_UINT128;
    }
    private static final int _C_FLT = (int)102L;
    /**
     * {@snippet lang=c :
     * #define _C_FLT 102
     * }
     */
    public static int _C_FLT() {
        return _C_FLT;
    }
    private static final int _C_DBL = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _C_DBL 100
     * }
     */
    public static int _C_DBL() {
        return _C_DBL;
    }
    private static final int _C_LNG_DBL = (int)68L;
    /**
     * {@snippet lang=c :
     * #define _C_LNG_DBL 68
     * }
     */
    public static int _C_LNG_DBL() {
        return _C_LNG_DBL;
    }
    private static final int _C_BFLD = (int)98L;
    /**
     * {@snippet lang=c :
     * #define _C_BFLD 98
     * }
     */
    public static int _C_BFLD() {
        return _C_BFLD;
    }
    private static final int _C_BOOL = (int)66L;
    /**
     * {@snippet lang=c :
     * #define _C_BOOL 66
     * }
     */
    public static int _C_BOOL() {
        return _C_BOOL;
    }
    private static final int _C_VOID = (int)118L;
    /**
     * {@snippet lang=c :
     * #define _C_VOID 118
     * }
     */
    public static int _C_VOID() {
        return _C_VOID;
    }
    private static final int _C_UNDEF = (int)63L;
    /**
     * {@snippet lang=c :
     * #define _C_UNDEF 63
     * }
     */
    public static int _C_UNDEF() {
        return _C_UNDEF;
    }
    private static final int _C_PTR = (int)94L;
    /**
     * {@snippet lang=c :
     * #define _C_PTR 94
     * }
     */
    public static int _C_PTR() {
        return _C_PTR;
    }
    private static final int _C_CHARPTR = (int)42L;
    /**
     * {@snippet lang=c :
     * #define _C_CHARPTR 42
     * }
     */
    public static int _C_CHARPTR() {
        return _C_CHARPTR;
    }
    private static final int _C_ATOM = (int)37L;
    /**
     * {@snippet lang=c :
     * #define _C_ATOM 37
     * }
     */
    public static int _C_ATOM() {
        return _C_ATOM;
    }
    private static final int _C_ARY_B = (int)91L;
    /**
     * {@snippet lang=c :
     * #define _C_ARY_B 91
     * }
     */
    public static int _C_ARY_B() {
        return _C_ARY_B;
    }
    private static final int _C_ARY_E = (int)93L;
    /**
     * {@snippet lang=c :
     * #define _C_ARY_E 93
     * }
     */
    public static int _C_ARY_E() {
        return _C_ARY_E;
    }
    private static final int _C_UNION_B = (int)40L;
    /**
     * {@snippet lang=c :
     * #define _C_UNION_B 40
     * }
     */
    public static int _C_UNION_B() {
        return _C_UNION_B;
    }
    private static final int _C_UNION_E = (int)41L;
    /**
     * {@snippet lang=c :
     * #define _C_UNION_E 41
     * }
     */
    public static int _C_UNION_E() {
        return _C_UNION_E;
    }
    private static final int _C_STRUCT_B = (int)123L;
    /**
     * {@snippet lang=c :
     * #define _C_STRUCT_B 123
     * }
     */
    public static int _C_STRUCT_B() {
        return _C_STRUCT_B;
    }
    private static final int _C_STRUCT_E = (int)125L;
    /**
     * {@snippet lang=c :
     * #define _C_STRUCT_E 125
     * }
     */
    public static int _C_STRUCT_E() {
        return _C_STRUCT_E;
    }
    private static final int _C_VECTOR = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _C_VECTOR 33
     * }
     */
    public static int _C_VECTOR() {
        return _C_VECTOR;
    }
    private static final int _C_COMPLEX = (int)106L;
    /**
     * {@snippet lang=c :
     * #define _C_COMPLEX 106
     * }
     */
    public static int _C_COMPLEX() {
        return _C_COMPLEX;
    }
    private static final int _C_ATOMIC = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _C_ATOMIC 65
     * }
     */
    public static int _C_ATOMIC() {
        return _C_ATOMIC;
    }
    private static final int _C_CONST = (int)114L;
    /**
     * {@snippet lang=c :
     * #define _C_CONST 114
     * }
     */
    public static int _C_CONST() {
        return _C_CONST;
    }
    private static final int _C_IN = (int)110L;
    /**
     * {@snippet lang=c :
     * #define _C_IN 110
     * }
     */
    public static int _C_IN() {
        return _C_IN;
    }
    private static final int _C_INOUT = (int)78L;
    /**
     * {@snippet lang=c :
     * #define _C_INOUT 78
     * }
     */
    public static int _C_INOUT() {
        return _C_INOUT;
    }
    private static final int _C_OUT = (int)111L;
    /**
     * {@snippet lang=c :
     * #define _C_OUT 111
     * }
     */
    public static int _C_OUT() {
        return _C_OUT;
    }
    private static final int _C_BYCOPY = (int)79L;
    /**
     * {@snippet lang=c :
     * #define _C_BYCOPY 79
     * }
     */
    public static int _C_BYCOPY() {
        return _C_BYCOPY;
    }
    private static final int _C_BYREF = (int)82L;
    /**
     * {@snippet lang=c :
     * #define _C_BYREF 82
     * }
     */
    public static int _C_BYREF() {
        return _C_BYREF;
    }
    private static final int _C_ONEWAY = (int)86L;
    /**
     * {@snippet lang=c :
     * #define _C_ONEWAY 86
     * }
     */
    public static int _C_ONEWAY() {
        return _C_ONEWAY;
    }
    private static final int _C_GNUREGISTER = (int)43L;
    /**
     * {@snippet lang=c :
     * #define _C_GNUREGISTER 43
     * }
     */
    public static int _C_GNUREGISTER() {
        return _C_GNUREGISTER;
    }
    private static final int MACH_PORT_DEAD = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_DEAD 4294967295
     * }
     */
    public static int MACH_PORT_DEAD() {
        return MACH_PORT_DEAD;
    }
    private static final int MACH_PORT_RIGHT_SEND = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_SEND 0
     * }
     */
    public static int MACH_PORT_RIGHT_SEND() {
        return MACH_PORT_RIGHT_SEND;
    }
    private static final int MACH_PORT_RIGHT_RECEIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_RECEIVE 1
     * }
     */
    public static int MACH_PORT_RIGHT_RECEIVE() {
        return MACH_PORT_RIGHT_RECEIVE;
    }
    private static final int MACH_PORT_RIGHT_SEND_ONCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_SEND_ONCE 2
     * }
     */
    public static int MACH_PORT_RIGHT_SEND_ONCE() {
        return MACH_PORT_RIGHT_SEND_ONCE;
    }
    private static final int MACH_PORT_RIGHT_PORT_SET = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_PORT_SET 3
     * }
     */
    public static int MACH_PORT_RIGHT_PORT_SET() {
        return MACH_PORT_RIGHT_PORT_SET;
    }
    private static final int MACH_PORT_RIGHT_DEAD_NAME = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_DEAD_NAME 4
     * }
     */
    public static int MACH_PORT_RIGHT_DEAD_NAME() {
        return MACH_PORT_RIGHT_DEAD_NAME;
    }
    private static final int MACH_PORT_RIGHT_LABELH = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_LABELH 5
     * }
     */
    public static int MACH_PORT_RIGHT_LABELH() {
        return MACH_PORT_RIGHT_LABELH;
    }
    private static final int MACH_PORT_RIGHT_NUMBER = (int)6L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RIGHT_NUMBER 6
     * }
     */
    public static int MACH_PORT_RIGHT_NUMBER() {
        return MACH_PORT_RIGHT_NUMBER;
    }
    private static final int MACH_PORT_TYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_NONE 0
     * }
     */
    public static int MACH_PORT_TYPE_NONE() {
        return MACH_PORT_TYPE_NONE;
    }
    private static final int MACH_PORT_TYPE_SEND = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND 65536
     * }
     */
    public static int MACH_PORT_TYPE_SEND() {
        return MACH_PORT_TYPE_SEND;
    }
    private static final int MACH_PORT_TYPE_RECEIVE = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_RECEIVE 131072
     * }
     */
    public static int MACH_PORT_TYPE_RECEIVE() {
        return MACH_PORT_TYPE_RECEIVE;
    }
    private static final int MACH_PORT_TYPE_SEND_ONCE = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_ONCE 262144
     * }
     */
    public static int MACH_PORT_TYPE_SEND_ONCE() {
        return MACH_PORT_TYPE_SEND_ONCE;
    }
    private static final int MACH_PORT_TYPE_PORT_SET = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_SET 524288
     * }
     */
    public static int MACH_PORT_TYPE_PORT_SET() {
        return MACH_PORT_TYPE_PORT_SET;
    }
    private static final int MACH_PORT_TYPE_DEAD_NAME = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_DEAD_NAME 1048576
     * }
     */
    public static int MACH_PORT_TYPE_DEAD_NAME() {
        return MACH_PORT_TYPE_DEAD_NAME;
    }
    private static final int MACH_PORT_TYPE_LABELH = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_LABELH 2097152
     * }
     */
    public static int MACH_PORT_TYPE_LABELH() {
        return MACH_PORT_TYPE_LABELH;
    }
    private static final int MACH_PORT_TYPE_DNREQUEST = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_DNREQUEST 2147483648
     * }
     */
    public static int MACH_PORT_TYPE_DNREQUEST() {
        return MACH_PORT_TYPE_DNREQUEST;
    }
    private static final int MACH_PORT_TYPE_SEND_RECEIVE = (int)196608L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_RECEIVE 196608
     * }
     */
    public static int MACH_PORT_TYPE_SEND_RECEIVE() {
        return MACH_PORT_TYPE_SEND_RECEIVE;
    }
    private static final int MACH_PORT_TYPE_SEND_RIGHTS = (int)327680L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SEND_RIGHTS 327680
     * }
     */
    public static int MACH_PORT_TYPE_SEND_RIGHTS() {
        return MACH_PORT_TYPE_SEND_RIGHTS;
    }
    private static final int MACH_PORT_TYPE_PORT_RIGHTS = (int)458752L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_RIGHTS 458752
     * }
     */
    public static int MACH_PORT_TYPE_PORT_RIGHTS() {
        return MACH_PORT_TYPE_PORT_RIGHTS;
    }
    private static final int MACH_PORT_TYPE_PORT_OR_DEAD = (int)1507328L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_PORT_OR_DEAD 1507328
     * }
     */
    public static int MACH_PORT_TYPE_PORT_OR_DEAD() {
        return MACH_PORT_TYPE_PORT_OR_DEAD;
    }
    private static final int MACH_PORT_TYPE_ALL_RIGHTS = (int)2031616L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_ALL_RIGHTS 2031616
     * }
     */
    public static int MACH_PORT_TYPE_ALL_RIGHTS() {
        return MACH_PORT_TYPE_ALL_RIGHTS;
    }
    private static final int MACH_PORT_QLIMIT_ZERO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_ZERO 0
     * }
     */
    public static int MACH_PORT_QLIMIT_ZERO() {
        return MACH_PORT_QLIMIT_ZERO;
    }
    private static final int MACH_PORT_QLIMIT_BASIC = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_BASIC 5
     * }
     */
    public static int MACH_PORT_QLIMIT_BASIC() {
        return MACH_PORT_QLIMIT_BASIC;
    }
    private static final int MACH_PORT_QLIMIT_SMALL = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_SMALL 16
     * }
     */
    public static int MACH_PORT_QLIMIT_SMALL() {
        return MACH_PORT_QLIMIT_SMALL;
    }
    private static final int MACH_PORT_QLIMIT_LARGE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_LARGE 1024
     * }
     */
    public static int MACH_PORT_QLIMIT_LARGE() {
        return MACH_PORT_QLIMIT_LARGE;
    }
    private static final int MACH_PORT_QLIMIT_KERNEL = (int)65534L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_KERNEL 65534
     * }
     */
    public static int MACH_PORT_QLIMIT_KERNEL() {
        return MACH_PORT_QLIMIT_KERNEL;
    }
    private static final int MACH_PORT_QLIMIT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_MIN 0
     * }
     */
    public static int MACH_PORT_QLIMIT_MIN() {
        return MACH_PORT_QLIMIT_MIN;
    }
    private static final int MACH_PORT_QLIMIT_DEFAULT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_DEFAULT 5
     * }
     */
    public static int MACH_PORT_QLIMIT_DEFAULT() {
        return MACH_PORT_QLIMIT_DEFAULT;
    }
    private static final int MACH_PORT_QLIMIT_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_QLIMIT_MAX 1024
     * }
     */
    public static int MACH_PORT_QLIMIT_MAX() {
        return MACH_PORT_QLIMIT_MAX;
    }
    private static final int MACH_PORT_LIMITS_INFO_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_LIMITS_INFO_COUNT 1
     * }
     */
    public static int MACH_PORT_LIMITS_INFO_COUNT() {
        return MACH_PORT_LIMITS_INFO_COUNT;
    }
    private static final int MACH_PORT_RECEIVE_STATUS_COUNT = (int)10L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RECEIVE_STATUS_COUNT 10
     * }
     */
    public static int MACH_PORT_RECEIVE_STATUS_COUNT() {
        return MACH_PORT_RECEIVE_STATUS_COUNT;
    }
    private static final int MACH_PORT_INFO_EXT_COUNT = (int)17L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_INFO_EXT_COUNT 17
     * }
     */
    public static int MACH_PORT_INFO_EXT_COUNT() {
        return MACH_PORT_INFO_EXT_COUNT;
    }
    private static final int MACH_PORT_GUARD_INFO_COUNT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_GUARD_INFO_COUNT 2
     * }
     */
    public static int MACH_PORT_GUARD_INFO_COUNT() {
        return MACH_PORT_GUARD_INFO_COUNT;
    }
    private static final byte MACH_SERVICE_PORT_INFO_COUNT = (byte)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_SERVICE_PORT_INFO_COUNT 0
     * }
     */
    public static byte MACH_SERVICE_PORT_INFO_COUNT() {
        return MACH_SERVICE_PORT_INFO_COUNT;
    }
    private static final int MAX_FATAL_kGUARD_EXC_CODE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define MAX_FATAL_kGUARD_EXC_CODE 128
     * }
     */
    public static int MAX_FATAL_kGUARD_EXC_CODE() {
        return MAX_FATAL_kGUARD_EXC_CODE;
    }
    private static final long MPG_FLAGS_NONE = 0L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_NONE 0
     * }
     */
    public static long MPG_FLAGS_NONE() {
        return MPG_FLAGS_NONE;
    }
    private static final int MAX_OPTIONAL_kGUARD_EXC_CODE = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define MAX_OPTIONAL_kGUARD_EXC_CODE 524288
     * }
     */
    public static int MAX_OPTIONAL_kGUARD_EXC_CODE() {
        return MAX_OPTIONAL_kGUARD_EXC_CODE;
    }
    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP 72057594037927936
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP;
    }
    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT = 144115188075855872L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT 144115188075855872
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT;
    }
    private static final long MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER = 288230376151711744L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER 288230376151711744
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER() {
        return MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER;
    }
    private static final long MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR = 576460752303423488L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR 576460752303423488
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR() {
        return MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR;
    }
    private static final long MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA = 1152921504606846976L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA 1152921504606846976
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA() {
        return MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA;
    }
    private static final long MPG_FLAGS_STRICT_REPLY_MASK = -72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_STRICT_REPLY_MASK -72057594037927936
     * }
     */
    public static long MPG_FLAGS_STRICT_REPLY_MASK() {
        return MPG_FLAGS_STRICT_REPLY_MASK;
    }
    private static final long MPG_FLAGS_MOD_REFS_PINNED_DEALLOC = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_DEALLOC 72057594037927936
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_DEALLOC() {
        return MPG_FLAGS_MOD_REFS_PINNED_DEALLOC;
    }
    private static final long MPG_FLAGS_MOD_REFS_PINNED_DESTROY = 144115188075855872L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_DESTROY 144115188075855872
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_DESTROY() {
        return MPG_FLAGS_MOD_REFS_PINNED_DESTROY;
    }
    private static final long MPG_FLAGS_MOD_REFS_PINNED_COPYIN = 288230376151711744L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_MOD_REFS_PINNED_COPYIN 288230376151711744
     * }
     */
    public static long MPG_FLAGS_MOD_REFS_PINNED_COPYIN() {
        return MPG_FLAGS_MOD_REFS_PINNED_COPYIN;
    }
    private static final long MPG_FLAGS_IMMOVABLE_PINNED = 72057594037927936L;
    /**
     * {@snippet lang=c :
     * #define MPG_FLAGS_IMMOVABLE_PINNED 72057594037927936
     * }
     */
    public static long MPG_FLAGS_IMMOVABLE_PINNED() {
        return MPG_FLAGS_IMMOVABLE_PINNED;
    }
    private static final int MACH_MSG_TIMEOUT_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TIMEOUT_NONE 0
     * }
     */
    public static int MACH_MSG_TIMEOUT_NONE() {
        return MACH_MSG_TIMEOUT_NONE;
    }
    private static final int MACH_MSGH_BITS_PORTS_MASK = (int)2039583L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_PORTS_MASK 2039583
     * }
     */
    public static int MACH_MSGH_BITS_PORTS_MASK() {
        return MACH_MSGH_BITS_PORTS_MASK;
    }
    private static final int MACH_MSGH_BITS_COMPLEX = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_COMPLEX 2147483648
     * }
     */
    public static int MACH_MSGH_BITS_COMPLEX() {
        return MACH_MSGH_BITS_COMPLEX;
    }
    private static final int MACH_MSGH_BITS_USER = (int)2149523231L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_USER 2149523231
     * }
     */
    public static int MACH_MSGH_BITS_USER() {
        return MACH_MSGH_BITS_USER;
    }
    private static final int MACH_MSGH_BITS_RAISEIMP = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_RAISEIMP 536870912
     * }
     */
    public static int MACH_MSGH_BITS_RAISEIMP() {
        return MACH_MSGH_BITS_RAISEIMP;
    }
    private static final int MACH_MSGH_BITS_DENAP = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_DENAP 536870912
     * }
     */
    public static int MACH_MSGH_BITS_DENAP() {
        return MACH_MSGH_BITS_DENAP;
    }
    private static final int MACH_MSGH_BITS_IMPHOLDASRT = (int)268435456L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_IMPHOLDASRT 268435456
     * }
     */
    public static int MACH_MSGH_BITS_IMPHOLDASRT() {
        return MACH_MSGH_BITS_IMPHOLDASRT;
    }
    private static final int MACH_MSGH_BITS_DENAPHOLDASRT = (int)268435456L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_DENAPHOLDASRT 268435456
     * }
     */
    public static int MACH_MSGH_BITS_DENAPHOLDASRT() {
        return MACH_MSGH_BITS_DENAPHOLDASRT;
    }
    private static final int MACH_MSGH_BITS_CIRCULAR = (int)268435456L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_CIRCULAR 268435456
     * }
     */
    public static int MACH_MSGH_BITS_CIRCULAR() {
        return MACH_MSGH_BITS_CIRCULAR;
    }
    private static final int MACH_MSGH_BITS_USED = (int)2954829599L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_USED 2954829599
     * }
     */
    public static int MACH_MSGH_BITS_USED() {
        return MACH_MSGH_BITS_USED;
    }
    private static final MemorySegment MACH_MSG_SIZE_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_SIZE_NULL (void*) 0
     * }
     */
    public static MemorySegment MACH_MSG_SIZE_NULL() {
        return MACH_MSG_SIZE_NULL;
    }
    private static final int MACH_MSG_PRIORITY_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_PRIORITY_UNSPECIFIED 0
     * }
     */
    public static int MACH_MSG_PRIORITY_UNSPECIFIED() {
        return MACH_MSG_PRIORITY_UNSPECIFIED;
    }
    private static final int MACH_MSG_DESCRIPTOR_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_DESCRIPTOR_MAX 4
     * }
     */
    public static int MACH_MSG_DESCRIPTOR_MAX() {
        return MACH_MSG_DESCRIPTOR_MAX;
    }
    private static final MemorySegment MACH_MSG_BODY_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_BODY_NULL (void*) 0
     * }
     */
    public static MemorySegment MACH_MSG_BODY_NULL() {
        return MACH_MSG_BODY_NULL;
    }
    private static final MemorySegment MACH_MSG_DESCRIPTOR_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_DESCRIPTOR_NULL (void*) 0
     * }
     */
    public static MemorySegment MACH_MSG_DESCRIPTOR_NULL() {
        return MACH_MSG_DESCRIPTOR_NULL;
    }
    private static final MemorySegment MACH_MSG_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_NULL (void*) 0
     * }
     */
    public static MemorySegment MACH_MSG_NULL() {
        return MACH_MSG_NULL;
    }
    private static final int MACH_MSG_FILTER_POLICY_ALLOW = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_FILTER_POLICY_ALLOW 0
     * }
     */
    public static int MACH_MSG_FILTER_POLICY_ALLOW() {
        return MACH_MSG_FILTER_POLICY_ALLOW;
    }
    private static final long MACH_MSG_TRAILER_MINIMUM_SIZE = 8L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TRAILER_MINIMUM_SIZE 8
     * }
     */
    public static long MACH_MSG_TRAILER_MINIMUM_SIZE() {
        return MACH_MSG_TRAILER_MINIMUM_SIZE;
    }
    private static final int MAX_TRAILER_SIZE = (int)68L;
    /**
     * {@snippet lang=c :
     * #define MAX_TRAILER_SIZE 68
     * }
     */
    public static int MAX_TRAILER_SIZE() {
        return MAX_TRAILER_SIZE;
    }
    private static final long MACH_MSG_TRAILER_FORMAT_0_SIZE = 20L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TRAILER_FORMAT_0_SIZE 20
     * }
     */
    public static long MACH_MSG_TRAILER_FORMAT_0_SIZE() {
        return MACH_MSG_TRAILER_FORMAT_0_SIZE;
    }
    private static final int MACH_MSG_SIZE_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_SIZE_MAX 4294967295
     * }
     */
    public static int MACH_MSG_SIZE_MAX() {
        return MACH_MSG_SIZE_MAX;
    }
    private static final int MACH_MSG_SIZE_RELIABLE = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_SIZE_RELIABLE 262144
     * }
     */
    public static int MACH_MSG_SIZE_RELIABLE() {
        return MACH_MSG_SIZE_RELIABLE;
    }
    private static final int MACH_MSG_TYPE_PORT_RECEIVE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_PORT_RECEIVE 16
     * }
     */
    public static int MACH_MSG_TYPE_PORT_RECEIVE() {
        return MACH_MSG_TYPE_PORT_RECEIVE;
    }
    private static final int MACH_MSG_TYPE_PORT_SEND = (int)17L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_PORT_SEND 17
     * }
     */
    public static int MACH_MSG_TYPE_PORT_SEND() {
        return MACH_MSG_TYPE_PORT_SEND;
    }
    private static final int MACH_MSG_TYPE_PORT_SEND_ONCE = (int)18L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_PORT_SEND_ONCE 18
     * }
     */
    public static int MACH_MSG_TYPE_PORT_SEND_ONCE() {
        return MACH_MSG_TYPE_PORT_SEND_ONCE;
    }
    private static final int MACH_MSG_TYPE_POLYMORPHIC = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_POLYMORPHIC 4294967295
     * }
     */
    public static int MACH_MSG_TYPE_POLYMORPHIC() {
        return MACH_MSG_TYPE_POLYMORPHIC;
    }
    private static final int MACH_SEND_NODENAP = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_NODENAP 262144
     * }
     */
    public static int MACH_SEND_NODENAP() {
        return MACH_SEND_NODENAP;
    }
    private static final int MACH_SEND_SYNC_USE_THRPRI = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_SYNC_USE_THRPRI 2097152
     * }
     */
    public static int MACH_SEND_SYNC_USE_THRPRI() {
        return MACH_SEND_SYNC_USE_THRPRI;
    }
    private static final int MACH_RCV_TRAILER_MASK = (int)251658240L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_MASK 251658240
     * }
     */
    public static int MACH_RCV_TRAILER_MASK() {
        return MACH_RCV_TRAILER_MASK;
    }
    private static final int VM_FLAGS_ALIAS_MASK = (int)4278190080L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_ALIAS_MASK 4278190080
     * }
     */
    public static int VM_FLAGS_ALIAS_MASK() {
        return VM_FLAGS_ALIAS_MASK;
    }
    private static final int VM_FLAGS_HW = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_HW 4096
     * }
     */
    public static int VM_FLAGS_HW() {
        return VM_FLAGS_HW;
    }
    private static final int VM_FLAGS_USER_ALLOCATE = (int)4278669471L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_USER_ALLOCATE 4278669471
     * }
     */
    public static int VM_FLAGS_USER_ALLOCATE() {
        return VM_FLAGS_USER_ALLOCATE;
    }
    private static final int VM_FLAGS_USER_MAP = (int)4288106655L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_USER_MAP 4288106655
     * }
     */
    public static int VM_FLAGS_USER_MAP() {
        return VM_FLAGS_USER_MAP;
    }
    private static final int VM_FLAGS_USER_REMAP = (int)1065065L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_USER_REMAP 1065065
     * }
     */
    public static int VM_FLAGS_USER_REMAP() {
        return VM_FLAGS_USER_REMAP;
    }
    private static final int VM_FLAGS_SUPERPAGE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_SUPERPAGE_NONE 0
     * }
     */
    public static int VM_FLAGS_SUPERPAGE_NONE() {
        return VM_FLAGS_SUPERPAGE_NONE;
    }
    private static final int VM_FLAGS_SUPERPAGE_SIZE_ANY = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_SUPERPAGE_SIZE_ANY 65536
     * }
     */
    public static int VM_FLAGS_SUPERPAGE_SIZE_ANY() {
        return VM_FLAGS_SUPERPAGE_SIZE_ANY;
    }
    private static final int VM_FLAGS_SUPERPAGE_SIZE_2MB = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define VM_FLAGS_SUPERPAGE_SIZE_2MB 131072
     * }
     */
    public static int VM_FLAGS_SUPERPAGE_SIZE_2MB() {
        return VM_FLAGS_SUPERPAGE_SIZE_2MB;
    }
    private static final int VM_LEDGER_TAG_UNCHANGED = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_TAG_UNCHANGED -1
     * }
     */
    public static int VM_LEDGER_TAG_UNCHANGED() {
        return VM_LEDGER_TAG_UNCHANGED;
    }
    private static final int VM_LEDGER_FLAG_NO_FOOTPRINT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_FLAG_NO_FOOTPRINT 1
     * }
     */
    public static int VM_LEDGER_FLAG_NO_FOOTPRINT() {
        return VM_LEDGER_FLAG_NO_FOOTPRINT;
    }
    private static final int VM_LEDGER_FLAG_NO_FOOTPRINT_FOR_DEBUG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_FLAG_NO_FOOTPRINT_FOR_DEBUG 2
     * }
     */
    public static int VM_LEDGER_FLAG_NO_FOOTPRINT_FOR_DEBUG() {
        return VM_LEDGER_FLAG_NO_FOOTPRINT_FOR_DEBUG;
    }
    private static final int VM_LEDGER_FLAG_FROM_KERNEL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_FLAG_FROM_KERNEL 4
     * }
     */
    public static int VM_LEDGER_FLAG_FROM_KERNEL() {
        return VM_LEDGER_FLAG_FROM_KERNEL;
    }
    private static final int VM_LEDGER_FLAGS_USER = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_FLAGS_USER 3
     * }
     */
    public static int VM_LEDGER_FLAGS_USER() {
        return VM_LEDGER_FLAGS_USER;
    }
    private static final int VM_LEDGER_FLAGS_ALL = (int)7L;
    /**
     * {@snippet lang=c :
     * #define VM_LEDGER_FLAGS_ALL 7
     * }
     */
    public static int VM_LEDGER_FLAGS_ALL() {
        return VM_LEDGER_FLAGS_ALL;
    }
    private static final int VM_MEMORY_CARBON = (int)43L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_CARBON 43
     * }
     */
    public static int VM_MEMORY_CARBON() {
        return VM_MEMORY_CARBON;
    }
    private static final int VM_MEMORY_COREGRAPHICS_MISC = (int)42L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_COREGRAPHICS_MISC 42
     * }
     */
    public static int VM_MEMORY_COREGRAPHICS_MISC() {
        return VM_MEMORY_COREGRAPHICS_MISC;
    }
    private static final int VM_MEMORY_WEBASSEMBLY = (int)63L;
    /**
     * {@snippet lang=c :
     * #define VM_MEMORY_WEBASSEMBLY 63
     * }
     */
    public static int VM_MEMORY_WEBASSEMBLY() {
        return VM_MEMORY_WEBASSEMBLY;
    }
    private static final int TIME_MICROS_MAX = (int)1000000L;
    /**
     * {@snippet lang=c :
     * #define TIME_MICROS_MAX 1000000
     * }
     */
    public static int TIME_MICROS_MAX() {
        return TIME_MICROS_MAX;
    }
    private static final int VM_PROT_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_NONE 0
     * }
     */
    public static int VM_PROT_NONE() {
        return VM_PROT_NONE;
    }
    private static final int VM_PROT_READ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_READ 1
     * }
     */
    public static int VM_PROT_READ() {
        return VM_PROT_READ;
    }
    private static final int VM_PROT_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_WRITE 2
     * }
     */
    public static int VM_PROT_WRITE() {
        return VM_PROT_WRITE;
    }
    private static final int VM_PROT_EXECUTE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_EXECUTE 4
     * }
     */
    public static int VM_PROT_EXECUTE() {
        return VM_PROT_EXECUTE;
    }
    private static final int VM_PROT_DEFAULT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_DEFAULT 3
     * }
     */
    public static int VM_PROT_DEFAULT() {
        return VM_PROT_DEFAULT;
    }
    private static final int VM_PROT_ALL = (int)7L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_ALL 7
     * }
     */
    public static int VM_PROT_ALL() {
        return VM_PROT_ALL;
    }
    private static final int VM_PROT_RORW_TP = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_RORW_TP 4
     * }
     */
    public static int VM_PROT_RORW_TP() {
        return VM_PROT_RORW_TP;
    }
    private static final int VM_PROT_NO_CHANGE_LEGACY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_NO_CHANGE_LEGACY 8
     * }
     */
    public static int VM_PROT_NO_CHANGE_LEGACY() {
        return VM_PROT_NO_CHANGE_LEGACY;
    }
    private static final int VM_PROT_NO_CHANGE = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_NO_CHANGE 16777216
     * }
     */
    public static int VM_PROT_NO_CHANGE() {
        return VM_PROT_NO_CHANGE;
    }
    private static final int VM_PROT_COPY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_COPY 16
     * }
     */
    public static int VM_PROT_COPY() {
        return VM_PROT_COPY;
    }
    private static final int VM_PROT_WANTS_COPY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_WANTS_COPY 16
     * }
     */
    public static int VM_PROT_WANTS_COPY() {
        return VM_PROT_WANTS_COPY;
    }
    private static final int VM_PROT_IS_MASK = (int)64L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_IS_MASK 64
     * }
     */
    public static int VM_PROT_IS_MASK() {
        return VM_PROT_IS_MASK;
    }
    private static final int VM_PROT_STRIP_READ = (int)128L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_STRIP_READ 128
     * }
     */
    public static int VM_PROT_STRIP_READ() {
        return VM_PROT_STRIP_READ;
    }
    private static final int VM_PROT_EXECUTE_ONLY = (int)132L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_EXECUTE_ONLY 132
     * }
     */
    public static int VM_PROT_EXECUTE_ONLY() {
        return VM_PROT_EXECUTE_ONLY;
    }
    private static final int VM_PROT_TPRO = (int)512L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_TPRO 512
     * }
     */
    public static int VM_PROT_TPRO() {
        return VM_PROT_TPRO;
    }
    private static final int VM_PROT_ALLEXEC = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_PROT_ALLEXEC 4
     * }
     */
    public static int VM_PROT_ALLEXEC() {
        return VM_PROT_ALLEXEC;
    }
    private static final int VM_SYNC_ASYNCHRONOUS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_SYNC_ASYNCHRONOUS 1
     * }
     */
    public static int VM_SYNC_ASYNCHRONOUS() {
        return VM_SYNC_ASYNCHRONOUS;
    }
    private static final int VM_SYNC_SYNCHRONOUS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_SYNC_SYNCHRONOUS 2
     * }
     */
    public static int VM_SYNC_SYNCHRONOUS() {
        return VM_SYNC_SYNCHRONOUS;
    }
    private static final int VM_SYNC_INVALIDATE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_SYNC_INVALIDATE 4
     * }
     */
    public static int VM_SYNC_INVALIDATE() {
        return VM_SYNC_INVALIDATE;
    }
    private static final int VM_SYNC_KILLPAGES = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VM_SYNC_KILLPAGES 8
     * }
     */
    public static int VM_SYNC_KILLPAGES() {
        return VM_SYNC_KILLPAGES;
    }
    private static final int VM_SYNC_DEACTIVATE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VM_SYNC_DEACTIVATE 16
     * }
     */
    public static int VM_SYNC_DEACTIVATE() {
        return VM_SYNC_DEACTIVATE;
    }
    private static final int VM_SYNC_CONTIGUOUS = (int)32L;
    /**
     * {@snippet lang=c :
     * #define VM_SYNC_CONTIGUOUS 32
     * }
     */
    public static int VM_SYNC_CONTIGUOUS() {
        return VM_SYNC_CONTIGUOUS;
    }
    private static final int VM_SYNC_REUSABLEPAGES = (int)64L;
    /**
     * {@snippet lang=c :
     * #define VM_SYNC_REUSABLEPAGES 64
     * }
     */
    public static int VM_SYNC_REUSABLEPAGES() {
        return VM_SYNC_REUSABLEPAGES;
    }
    private static final int PPNUM_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define PPNUM_MAX 4294967295
     * }
     */
    public static int PPNUM_MAX() {
        return PPNUM_MAX;
    }
    private static final int VM_MAP_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_MAP_NULL 0
     * }
     */
    public static int VM_MAP_NULL() {
        return VM_MAP_NULL;
    }
    private static final int VM_MAP_INSPECT_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_MAP_INSPECT_NULL 0
     * }
     */
    public static int VM_MAP_INSPECT_NULL() {
        return VM_MAP_INSPECT_NULL;
    }
    private static final int VM_MAP_READ_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_MAP_READ_NULL 0
     * }
     */
    public static int VM_MAP_READ_NULL() {
        return VM_MAP_READ_NULL;
    }
    private static final int UPL_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define UPL_NULL 0
     * }
     */
    public static int UPL_NULL() {
        return UPL_NULL;
    }
    private static final int VM_NAMED_ENTRY_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_NAMED_ENTRY_NULL 0
     * }
     */
    public static int VM_NAMED_ENTRY_NULL() {
        return VM_NAMED_ENTRY_NULL;
    }
    private static final int MACH_VM_RANGE_FLAVOR_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_VM_RANGE_FLAVOR_DEFAULT 1
     * }
     */
    public static int MACH_VM_RANGE_FLAVOR_DEFAULT() {
        return MACH_VM_RANGE_FLAVOR_DEFAULT;
    }
    private static final int MEMORY_OBJECT_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_NULL 0
     * }
     */
    public static int MEMORY_OBJECT_NULL() {
        return MEMORY_OBJECT_NULL;
    }
    private static final int MEMORY_OBJECT_CONTROL_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_CONTROL_NULL 0
     * }
     */
    public static int MEMORY_OBJECT_CONTROL_NULL() {
        return MEMORY_OBJECT_CONTROL_NULL;
    }
    private static final int MEMORY_OBJECT_NAME_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_NAME_NULL 0
     * }
     */
    public static int MEMORY_OBJECT_NAME_NULL() {
        return MEMORY_OBJECT_NAME_NULL;
    }
    private static final int MEMORY_OBJECT_DEFAULT_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_DEFAULT_NULL 0
     * }
     */
    public static int MEMORY_OBJECT_DEFAULT_NULL() {
        return MEMORY_OBJECT_DEFAULT_NULL;
    }
    private static final int MEMORY_OBJECT_INFO_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_INFO_MAX 1024
     * }
     */
    public static int MEMORY_OBJECT_INFO_MAX() {
        return MEMORY_OBJECT_INFO_MAX;
    }
    private static final int MEMORY_OBJECT_BEHAVE_INFO_COUNT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_BEHAVE_INFO_COUNT 5
     * }
     */
    public static int MEMORY_OBJECT_BEHAVE_INFO_COUNT() {
        return MEMORY_OBJECT_BEHAVE_INFO_COUNT;
    }
    private static final int MEMORY_OBJECT_PERF_INFO_COUNT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_PERF_INFO_COUNT 2
     * }
     */
    public static int MEMORY_OBJECT_PERF_INFO_COUNT() {
        return MEMORY_OBJECT_PERF_INFO_COUNT;
    }
    private static final int MEMORY_OBJECT_ATTR_INFO_COUNT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MEMORY_OBJECT_ATTR_INFO_COUNT 4
     * }
     */
    public static int MEMORY_OBJECT_ATTR_INFO_COUNT() {
        return MEMORY_OBJECT_ATTR_INFO_COUNT;
    }
    private static final int MAP_MEM_FLAGS_USER = (int)16769024L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_FLAGS_USER 16769024
     * }
     */
    public static int MAP_MEM_FLAGS_USER() {
        return MAP_MEM_FLAGS_USER;
    }
    private static final int MAP_MEM_FLAGS_ALL = (int)16769024L;
    /**
     * {@snippet lang=c :
     * #define MAP_MEM_FLAGS_ALL 16769024
     * }
     */
    public static int MAP_MEM_FLAGS_ALL() {
        return MAP_MEM_FLAGS_ALL;
    }
    private static final int MACH_EXCEPTION_CODES = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define MACH_EXCEPTION_CODES 2147483648
     * }
     */
    public static int MACH_EXCEPTION_CODES() {
        return MACH_EXCEPTION_CODES;
    }
    private static final int MACH_EXCEPTION_MASK = (int)3758096384L;
    /**
     * {@snippet lang=c :
     * #define MACH_EXCEPTION_MASK 3758096384
     * }
     */
    public static int MACH_EXCEPTION_MASK() {
        return MACH_EXCEPTION_MASK;
    }
    private static final int EXC_MASK_BAD_ACCESS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_BAD_ACCESS 2
     * }
     */
    public static int EXC_MASK_BAD_ACCESS() {
        return EXC_MASK_BAD_ACCESS;
    }
    private static final int EXC_MASK_BAD_INSTRUCTION = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_BAD_INSTRUCTION 4
     * }
     */
    public static int EXC_MASK_BAD_INSTRUCTION() {
        return EXC_MASK_BAD_INSTRUCTION;
    }
    private static final int EXC_MASK_ARITHMETIC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_ARITHMETIC 8
     * }
     */
    public static int EXC_MASK_ARITHMETIC() {
        return EXC_MASK_ARITHMETIC;
    }
    private static final int EXC_MASK_EMULATION = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_EMULATION 16
     * }
     */
    public static int EXC_MASK_EMULATION() {
        return EXC_MASK_EMULATION;
    }
    private static final int EXC_MASK_SOFTWARE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_SOFTWARE 32
     * }
     */
    public static int EXC_MASK_SOFTWARE() {
        return EXC_MASK_SOFTWARE;
    }
    private static final int EXC_MASK_BREAKPOINT = (int)64L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_BREAKPOINT 64
     * }
     */
    public static int EXC_MASK_BREAKPOINT() {
        return EXC_MASK_BREAKPOINT;
    }
    private static final int EXC_MASK_SYSCALL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_SYSCALL 128
     * }
     */
    public static int EXC_MASK_SYSCALL() {
        return EXC_MASK_SYSCALL;
    }
    private static final int EXC_MASK_MACH_SYSCALL = (int)256L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_MACH_SYSCALL 256
     * }
     */
    public static int EXC_MASK_MACH_SYSCALL() {
        return EXC_MASK_MACH_SYSCALL;
    }
    private static final int EXC_MASK_RPC_ALERT = (int)512L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_RPC_ALERT 512
     * }
     */
    public static int EXC_MASK_RPC_ALERT() {
        return EXC_MASK_RPC_ALERT;
    }
    private static final int EXC_MASK_CRASH = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_CRASH 1024
     * }
     */
    public static int EXC_MASK_CRASH() {
        return EXC_MASK_CRASH;
    }
    private static final int EXC_MASK_RESOURCE = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_RESOURCE 2048
     * }
     */
    public static int EXC_MASK_RESOURCE() {
        return EXC_MASK_RESOURCE;
    }
    private static final int EXC_MASK_GUARD = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_GUARD 4096
     * }
     */
    public static int EXC_MASK_GUARD() {
        return EXC_MASK_GUARD;
    }
    private static final int EXC_MASK_CORPSE_NOTIFY = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_CORPSE_NOTIFY 8192
     * }
     */
    public static int EXC_MASK_CORPSE_NOTIFY() {
        return EXC_MASK_CORPSE_NOTIFY;
    }
    private static final int EXC_MASK_ALL = (int)7166L;
    /**
     * {@snippet lang=c :
     * #define EXC_MASK_ALL 7166
     * }
     */
    public static int EXC_MASK_ALL() {
        return EXC_MASK_ALL;
    }
    private static final int PROCESSOR_CPU_STAT_COUNT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_CPU_STAT_COUNT 9
     * }
     */
    public static int PROCESSOR_CPU_STAT_COUNT() {
        return PROCESSOR_CPU_STAT_COUNT;
    }
    private static final int PROCESSOR_CPU_STAT64_COUNT = (int)20L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_CPU_STAT64_COUNT 20
     * }
     */
    public static int PROCESSOR_CPU_STAT64_COUNT() {
        return PROCESSOR_CPU_STAT64_COUNT;
    }
    private static final int PROCESSOR_INFO_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_INFO_MAX 1024
     * }
     */
    public static int PROCESSOR_INFO_MAX() {
        return PROCESSOR_INFO_MAX;
    }
    private static final int PROCESSOR_SET_INFO_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_SET_INFO_MAX 1024
     * }
     */
    public static int PROCESSOR_SET_INFO_MAX() {
        return PROCESSOR_SET_INFO_MAX;
    }
    private static final int PROCESSOR_BASIC_INFO_COUNT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_BASIC_INFO_COUNT 5
     * }
     */
    public static int PROCESSOR_BASIC_INFO_COUNT() {
        return PROCESSOR_BASIC_INFO_COUNT;
    }
    private static final int PROCESSOR_CPU_LOAD_INFO_COUNT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_CPU_LOAD_INFO_COUNT 4
     * }
     */
    public static int PROCESSOR_CPU_LOAD_INFO_COUNT() {
        return PROCESSOR_CPU_LOAD_INFO_COUNT;
    }
    private static final int PROCESSOR_SET_BASIC_INFO_COUNT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_SET_BASIC_INFO_COUNT 2
     * }
     */
    public static int PROCESSOR_SET_BASIC_INFO_COUNT() {
        return PROCESSOR_SET_BASIC_INFO_COUNT;
    }
    private static final int PROCESSOR_SET_LOAD_INFO_COUNT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PROCESSOR_SET_LOAD_INFO_COUNT 4
     * }
     */
    public static int PROCESSOR_SET_LOAD_INFO_COUNT() {
        return PROCESSOR_SET_LOAD_INFO_COUNT;
    }
    private static final int POLICYCLASS_FIXEDPRI = (int)6L;
    /**
     * {@snippet lang=c :
     * #define POLICYCLASS_FIXEDPRI 6
     * }
     */
    public static int POLICYCLASS_FIXEDPRI() {
        return POLICYCLASS_FIXEDPRI;
    }
    private static final int POLICY_TIMESHARE_BASE_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLICY_TIMESHARE_BASE_COUNT 1
     * }
     */
    public static int POLICY_TIMESHARE_BASE_COUNT() {
        return POLICY_TIMESHARE_BASE_COUNT;
    }
    private static final int POLICY_TIMESHARE_LIMIT_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLICY_TIMESHARE_LIMIT_COUNT 1
     * }
     */
    public static int POLICY_TIMESHARE_LIMIT_COUNT() {
        return POLICY_TIMESHARE_LIMIT_COUNT;
    }
    private static final int POLICY_TIMESHARE_INFO_COUNT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define POLICY_TIMESHARE_INFO_COUNT 5
     * }
     */
    public static int POLICY_TIMESHARE_INFO_COUNT() {
        return POLICY_TIMESHARE_INFO_COUNT;
    }
    private static final int POLICY_RR_BASE_COUNT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define POLICY_RR_BASE_COUNT 2
     * }
     */
    public static int POLICY_RR_BASE_COUNT() {
        return POLICY_RR_BASE_COUNT;
    }
    private static final int POLICY_RR_LIMIT_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLICY_RR_LIMIT_COUNT 1
     * }
     */
    public static int POLICY_RR_LIMIT_COUNT() {
        return POLICY_RR_LIMIT_COUNT;
    }
    private static final int POLICY_RR_INFO_COUNT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define POLICY_RR_INFO_COUNT 5
     * }
     */
    public static int POLICY_RR_INFO_COUNT() {
        return POLICY_RR_INFO_COUNT;
    }
    private static final int POLICY_FIFO_BASE_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLICY_FIFO_BASE_COUNT 1
     * }
     */
    public static int POLICY_FIFO_BASE_COUNT() {
        return POLICY_FIFO_BASE_COUNT;
    }
    private static final int POLICY_FIFO_LIMIT_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLICY_FIFO_LIMIT_COUNT 1
     * }
     */
    public static int POLICY_FIFO_LIMIT_COUNT() {
        return POLICY_FIFO_LIMIT_COUNT;
    }
    private static final int POLICY_FIFO_INFO_COUNT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define POLICY_FIFO_INFO_COUNT 4
     * }
     */
    public static int POLICY_FIFO_INFO_COUNT() {
        return POLICY_FIFO_INFO_COUNT;
    }
    private static final int TASK_INFO_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define TASK_INFO_MAX 1024
     * }
     */
    public static int TASK_INFO_MAX() {
        return TASK_INFO_MAX;
    }
    private static final long TASK_BASIC_INFO_32_COUNT = 8L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC_INFO_32_COUNT 8
     * }
     */
    public static long TASK_BASIC_INFO_32_COUNT() {
        return TASK_BASIC_INFO_32_COUNT;
    }
    private static final int TASK_BASIC_INFO_64 = (int)18L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC_INFO_64 18
     * }
     */
    public static int TASK_BASIC_INFO_64() {
        return TASK_BASIC_INFO_64;
    }
    private static final long TASK_BASIC_INFO_64_COUNT = 10L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC_INFO_64_COUNT 10
     * }
     */
    public static long TASK_BASIC_INFO_64_COUNT() {
        return TASK_BASIC_INFO_64_COUNT;
    }
    private static final long TASK_BASIC_INFO_COUNT = 10L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC_INFO_COUNT 10
     * }
     */
    public static long TASK_BASIC_INFO_COUNT() {
        return TASK_BASIC_INFO_COUNT;
    }
    private static final int TASK_BASIC_INFO = (int)18L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC_INFO 18
     * }
     */
    public static int TASK_BASIC_INFO() {
        return TASK_BASIC_INFO;
    }
    private static final int TASK_EVENTS_INFO_COUNT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define TASK_EVENTS_INFO_COUNT 8
     * }
     */
    public static int TASK_EVENTS_INFO_COUNT() {
        return TASK_EVENTS_INFO_COUNT;
    }
    private static final int TASK_THREAD_TIMES_INFO_COUNT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TASK_THREAD_TIMES_INFO_COUNT 4
     * }
     */
    public static int TASK_THREAD_TIMES_INFO_COUNT() {
        return TASK_THREAD_TIMES_INFO_COUNT;
    }
    private static final int TASK_ABSOLUTETIME_INFO_COUNT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define TASK_ABSOLUTETIME_INFO_COUNT 8
     * }
     */
    public static int TASK_ABSOLUTETIME_INFO_COUNT() {
        return TASK_ABSOLUTETIME_INFO_COUNT;
    }
    private static final int TASK_KERNELMEMORY_INFO_COUNT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define TASK_KERNELMEMORY_INFO_COUNT 8
     * }
     */
    public static int TASK_KERNELMEMORY_INFO_COUNT() {
        return TASK_KERNELMEMORY_INFO_COUNT;
    }
    private static final int TASK_SECURITY_TOKEN_COUNT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TASK_SECURITY_TOKEN_COUNT 2
     * }
     */
    public static int TASK_SECURITY_TOKEN_COUNT() {
        return TASK_SECURITY_TOKEN_COUNT;
    }
    private static final long TASK_AUDIT_TOKEN_COUNT = 8L;
    /**
     * {@snippet lang=c :
     * #define TASK_AUDIT_TOKEN_COUNT 8
     * }
     */
    public static long TASK_AUDIT_TOKEN_COUNT() {
        return TASK_AUDIT_TOKEN_COUNT;
    }
    private static final long TASK_AFFINITY_TAG_INFO_COUNT = 4L;
    /**
     * {@snippet lang=c :
     * #define TASK_AFFINITY_TAG_INFO_COUNT 4
     * }
     */
    public static long TASK_AFFINITY_TAG_INFO_COUNT() {
        return TASK_AFFINITY_TAG_INFO_COUNT;
    }
    private static final long TASK_DYLD_INFO_COUNT = 5L;
    /**
     * {@snippet lang=c :
     * #define TASK_DYLD_INFO_COUNT 5
     * }
     */
    public static long TASK_DYLD_INFO_COUNT() {
        return TASK_DYLD_INFO_COUNT;
    }
    private static final long TASK_BASIC_INFO_64_2_COUNT = 10L;
    /**
     * {@snippet lang=c :
     * #define TASK_BASIC_INFO_64_2_COUNT 10
     * }
     */
    public static long TASK_BASIC_INFO_64_2_COUNT() {
        return TASK_BASIC_INFO_64_2_COUNT;
    }
    private static final long TASK_EXTMOD_INFO_COUNT = 16L;
    /**
     * {@snippet lang=c :
     * #define TASK_EXTMOD_INFO_COUNT 16
     * }
     */
    public static long TASK_EXTMOD_INFO_COUNT() {
        return TASK_EXTMOD_INFO_COUNT;
    }
    private static final long MACH_TASK_BASIC_INFO_COUNT = 12L;
    /**
     * {@snippet lang=c :
     * #define MACH_TASK_BASIC_INFO_COUNT 12
     * }
     */
    public static long MACH_TASK_BASIC_INFO_COUNT() {
        return MACH_TASK_BASIC_INFO_COUNT;
    }
    private static final int TASK_POWER_INFO_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define TASK_POWER_INFO_COUNT 12
     * }
     */
    public static int TASK_POWER_INFO_COUNT() {
        return TASK_POWER_INFO_COUNT;
    }
    private static final int TASK_VM_INFO_COUNT = (int)93L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_COUNT 93
     * }
     */
    public static int TASK_VM_INFO_COUNT() {
        return TASK_VM_INFO_COUNT;
    }
    private static final int TASK_VM_INFO_REV7_COUNT = (int)93L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_REV7_COUNT 93
     * }
     */
    public static int TASK_VM_INFO_REV7_COUNT() {
        return TASK_VM_INFO_REV7_COUNT;
    }
    private static final int TASK_VM_INFO_REV6_COUNT = (int)89L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_REV6_COUNT 89
     * }
     */
    public static int TASK_VM_INFO_REV6_COUNT() {
        return TASK_VM_INFO_REV6_COUNT;
    }
    private static final int TASK_VM_INFO_REV5_COUNT = (int)87L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_REV5_COUNT 87
     * }
     */
    public static int TASK_VM_INFO_REV5_COUNT() {
        return TASK_VM_INFO_REV5_COUNT;
    }
    private static final int TASK_VM_INFO_REV4_COUNT = (int)86L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_REV4_COUNT 86
     * }
     */
    public static int TASK_VM_INFO_REV4_COUNT() {
        return TASK_VM_INFO_REV4_COUNT;
    }
    private static final int TASK_VM_INFO_REV3_COUNT = (int)84L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_REV3_COUNT 84
     * }
     */
    public static int TASK_VM_INFO_REV3_COUNT() {
        return TASK_VM_INFO_REV3_COUNT;
    }
    private static final int TASK_VM_INFO_REV2_COUNT = (int)42L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_REV2_COUNT 42
     * }
     */
    public static int TASK_VM_INFO_REV2_COUNT() {
        return TASK_VM_INFO_REV2_COUNT;
    }
    private static final int TASK_VM_INFO_REV1_COUNT = (int)38L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_REV1_COUNT 38
     * }
     */
    public static int TASK_VM_INFO_REV1_COUNT() {
        return TASK_VM_INFO_REV1_COUNT;
    }
    private static final int TASK_VM_INFO_REV0_COUNT = (int)36L;
    /**
     * {@snippet lang=c :
     * #define TASK_VM_INFO_REV0_COUNT 36
     * }
     */
    public static int TASK_VM_INFO_REV0_COUNT() {
        return TASK_VM_INFO_REV0_COUNT;
    }
    private static final int TASK_TRACE_MEMORY_INFO_COUNT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define TASK_TRACE_MEMORY_INFO_COUNT 6
     * }
     */
    public static int TASK_TRACE_MEMORY_INFO_COUNT() {
        return TASK_TRACE_MEMORY_INFO_COUNT;
    }
    private static final int TASK_WAIT_STATE_INFO_COUNT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define TASK_WAIT_STATE_INFO_COUNT 8
     * }
     */
    public static int TASK_WAIT_STATE_INFO_COUNT() {
        return TASK_WAIT_STATE_INFO_COUNT;
    }
    private static final long TASK_POWER_INFO_V2_COUNT_OLD = 22L;
    /**
     * {@snippet lang=c :
     * #define TASK_POWER_INFO_V2_COUNT_OLD 22
     * }
     */
    public static long TASK_POWER_INFO_V2_COUNT_OLD() {
        return TASK_POWER_INFO_V2_COUNT_OLD;
    }
    private static final int TASK_POWER_INFO_V2_COUNT = (int)26L;
    /**
     * {@snippet lang=c :
     * #define TASK_POWER_INFO_V2_COUNT 26
     * }
     */
    public static int TASK_POWER_INFO_V2_COUNT() {
        return TASK_POWER_INFO_V2_COUNT;
    }
    private static final int TASK_FLAGS_INFO_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_FLAGS_INFO_COUNT 1
     * }
     */
    public static int TASK_FLAGS_INFO_COUNT() {
        return TASK_FLAGS_INFO_COUNT;
    }
    private static final long TASK_INSPECT_BASIC_COUNTS_COUNT = 4L;
    /**
     * {@snippet lang=c :
     * #define TASK_INSPECT_BASIC_COUNTS_COUNT 4
     * }
     */
    public static long TASK_INSPECT_BASIC_COUNTS_COUNT() {
        return TASK_INSPECT_BASIC_COUNTS_COUNT;
    }
    private static final int TASK_CATEGORY_POLICY_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TASK_CATEGORY_POLICY_COUNT 1
     * }
     */
    public static int TASK_CATEGORY_POLICY_COUNT() {
        return TASK_CATEGORY_POLICY_COUNT;
    }
    private static final int LATENCY_QOS_LAUNCH_DEFAULT_TIER = (int)16711684L;
    /**
     * {@snippet lang=c :
     * #define LATENCY_QOS_LAUNCH_DEFAULT_TIER 16711684
     * }
     */
    public static int LATENCY_QOS_LAUNCH_DEFAULT_TIER() {
        return LATENCY_QOS_LAUNCH_DEFAULT_TIER;
    }
    private static final int THROUGHPUT_QOS_LAUNCH_DEFAULT_TIER = (int)16646148L;
    /**
     * {@snippet lang=c :
     * #define THROUGHPUT_QOS_LAUNCH_DEFAULT_TIER 16646148
     * }
     */
    public static int THROUGHPUT_QOS_LAUNCH_DEFAULT_TIER() {
        return THROUGHPUT_QOS_LAUNCH_DEFAULT_TIER;
    }
    private static final int TASK_QOS_POLICY_COUNT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TASK_QOS_POLICY_COUNT 2
     * }
     */
    public static int TASK_QOS_POLICY_COUNT() {
        return TASK_QOS_POLICY_COUNT;
    }
    private static final int PROC_FLAG_IOS_APPLICATION = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define PROC_FLAG_IOS_APPLICATION 16777216
     * }
     */
    public static int PROC_FLAG_IOS_APPLICATION() {
        return PROC_FLAG_IOS_APPLICATION;
    }
    private static final int TASK_MAX_SPECIAL_PORT = (int)11L;
    /**
     * {@snippet lang=c :
     * #define TASK_MAX_SPECIAL_PORT 11
     * }
     */
    public static int TASK_MAX_SPECIAL_PORT() {
        return TASK_MAX_SPECIAL_PORT;
    }
    private static final int THREAD_INFO_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define THREAD_INFO_MAX 32
     * }
     */
    public static int THREAD_INFO_MAX() {
        return THREAD_INFO_MAX;
    }
    private static final int THREAD_BASIC_INFO_COUNT = (int)10L;
    /**
     * {@snippet lang=c :
     * #define THREAD_BASIC_INFO_COUNT 10
     * }
     */
    public static int THREAD_BASIC_INFO_COUNT() {
        return THREAD_BASIC_INFO_COUNT;
    }
    private static final int THREAD_IDENTIFIER_INFO_COUNT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define THREAD_IDENTIFIER_INFO_COUNT 6
     * }
     */
    public static int THREAD_IDENTIFIER_INFO_COUNT() {
        return THREAD_IDENTIFIER_INFO_COUNT;
    }
    private static final int THREAD_EXTENDED_INFO_COUNT = (int)28L;
    /**
     * {@snippet lang=c :
     * #define THREAD_EXTENDED_INFO_COUNT 28
     * }
     */
    public static int THREAD_EXTENDED_INFO_COUNT() {
        return THREAD_EXTENDED_INFO_COUNT;
    }
    private static final int THREAD_EXTENDED_POLICY_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_EXTENDED_POLICY_COUNT 1
     * }
     */
    public static int THREAD_EXTENDED_POLICY_COUNT() {
        return THREAD_EXTENDED_POLICY_COUNT;
    }
    private static final int THREAD_TIME_CONSTRAINT_POLICY_COUNT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define THREAD_TIME_CONSTRAINT_POLICY_COUNT 4
     * }
     */
    public static int THREAD_TIME_CONSTRAINT_POLICY_COUNT() {
        return THREAD_TIME_CONSTRAINT_POLICY_COUNT;
    }
    private static final int THREAD_PRECEDENCE_POLICY_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_PRECEDENCE_POLICY_COUNT 1
     * }
     */
    public static int THREAD_PRECEDENCE_POLICY_COUNT() {
        return THREAD_PRECEDENCE_POLICY_COUNT;
    }
    private static final int THREAD_AFFINITY_POLICY_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_AFFINITY_POLICY_COUNT 1
     * }
     */
    public static int THREAD_AFFINITY_POLICY_COUNT() {
        return THREAD_AFFINITY_POLICY_COUNT;
    }
    private static final int THREAD_BACKGROUND_POLICY_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_BACKGROUND_POLICY_COUNT 1
     * }
     */
    public static int THREAD_BACKGROUND_POLICY_COUNT() {
        return THREAD_BACKGROUND_POLICY_COUNT;
    }
    private static final int THREAD_LATENCY_QOS_POLICY_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_LATENCY_QOS_POLICY_COUNT 1
     * }
     */
    public static int THREAD_LATENCY_QOS_POLICY_COUNT() {
        return THREAD_LATENCY_QOS_POLICY_COUNT;
    }
    private static final int THREAD_THROUGHPUT_QOS_POLICY_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define THREAD_THROUGHPUT_QOS_POLICY_COUNT 1
     * }
     */
    public static int THREAD_THROUGHPUT_QOS_POLICY_COUNT() {
        return THREAD_THROUGHPUT_QOS_POLICY_COUNT;
    }
    private static final int THREAD_MAX_SPECIAL_PORT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define THREAD_MAX_SPECIAL_PORT 3
     * }
     */
    public static int THREAD_MAX_SPECIAL_PORT() {
        return THREAD_MAX_SPECIAL_PORT;
    }
    private static final int VM_INHERIT_SHARE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_INHERIT_SHARE 0
     * }
     */
    public static int VM_INHERIT_SHARE() {
        return VM_INHERIT_SHARE;
    }
    private static final int VM_INHERIT_COPY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_INHERIT_COPY 1
     * }
     */
    public static int VM_INHERIT_COPY() {
        return VM_INHERIT_COPY;
    }
    private static final int VM_INHERIT_NONE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_INHERIT_NONE 2
     * }
     */
    public static int VM_INHERIT_NONE() {
        return VM_INHERIT_NONE;
    }
    private static final int VM_INHERIT_DONATE_COPY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_INHERIT_DONATE_COPY 3
     * }
     */
    public static int VM_INHERIT_DONATE_COPY() {
        return VM_INHERIT_DONATE_COPY;
    }
    private static final int VM_INHERIT_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_INHERIT_DEFAULT 1
     * }
     */
    public static int VM_INHERIT_DEFAULT() {
        return VM_INHERIT_DEFAULT;
    }
    private static final int VM_INHERIT_LAST_VALID = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_INHERIT_LAST_VALID 2
     * }
     */
    public static int VM_INHERIT_LAST_VALID() {
        return VM_INHERIT_LAST_VALID;
    }
    private static final int VM_PURGABLE_SET_STATE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_SET_STATE 0
     * }
     */
    public static int VM_PURGABLE_SET_STATE() {
        return VM_PURGABLE_SET_STATE;
    }
    private static final int VM_PURGABLE_GET_STATE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_GET_STATE 1
     * }
     */
    public static int VM_PURGABLE_GET_STATE() {
        return VM_PURGABLE_GET_STATE;
    }
    private static final int VM_PURGABLE_PURGE_ALL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_PURGE_ALL 2
     * }
     */
    public static int VM_PURGABLE_PURGE_ALL() {
        return VM_PURGABLE_PURGE_ALL;
    }
    private static final int VM_PURGABLE_SET_STATE_FROM_KERNEL = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_SET_STATE_FROM_KERNEL 3
     * }
     */
    public static int VM_PURGABLE_SET_STATE_FROM_KERNEL() {
        return VM_PURGABLE_SET_STATE_FROM_KERNEL;
    }
    private static final int VM_PURGABLE_NO_AGING_MASK = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_NO_AGING_MASK 65536
     * }
     */
    public static int VM_PURGABLE_NO_AGING_MASK() {
        return VM_PURGABLE_NO_AGING_MASK;
    }
    private static final int VM_PURGABLE_NO_AGING = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_NO_AGING 65536
     * }
     */
    public static int VM_PURGABLE_NO_AGING() {
        return VM_PURGABLE_NO_AGING;
    }
    private static final int VM_PURGABLE_DEBUG_MASK = (int)12288L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_DEBUG_MASK 12288
     * }
     */
    public static int VM_PURGABLE_DEBUG_MASK() {
        return VM_PURGABLE_DEBUG_MASK;
    }
    private static final int VM_PURGABLE_DEBUG_EMPTY = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_DEBUG_EMPTY 4096
     * }
     */
    public static int VM_PURGABLE_DEBUG_EMPTY() {
        return VM_PURGABLE_DEBUG_EMPTY;
    }
    private static final int VM_PURGABLE_DEBUG_FAULT = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_DEBUG_FAULT 8192
     * }
     */
    public static int VM_PURGABLE_DEBUG_FAULT() {
        return VM_PURGABLE_DEBUG_FAULT;
    }
    private static final int VM_VOLATILE_GROUP_MASK = (int)1792L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_MASK 1792
     * }
     */
    public static int VM_VOLATILE_GROUP_MASK() {
        return VM_VOLATILE_GROUP_MASK;
    }
    private static final int VM_VOLATILE_GROUP_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_DEFAULT 0
     * }
     */
    public static int VM_VOLATILE_GROUP_DEFAULT() {
        return VM_VOLATILE_GROUP_DEFAULT;
    }
    private static final int VM_VOLATILE_GROUP_0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_0 0
     * }
     */
    public static int VM_VOLATILE_GROUP_0() {
        return VM_VOLATILE_GROUP_0;
    }
    private static final int VM_VOLATILE_GROUP_1 = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_1 256
     * }
     */
    public static int VM_VOLATILE_GROUP_1() {
        return VM_VOLATILE_GROUP_1;
    }
    private static final int VM_VOLATILE_GROUP_2 = (int)512L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_2 512
     * }
     */
    public static int VM_VOLATILE_GROUP_2() {
        return VM_VOLATILE_GROUP_2;
    }
    private static final int VM_VOLATILE_GROUP_3 = (int)768L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_3 768
     * }
     */
    public static int VM_VOLATILE_GROUP_3() {
        return VM_VOLATILE_GROUP_3;
    }
    private static final int VM_VOLATILE_GROUP_4 = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_4 1024
     * }
     */
    public static int VM_VOLATILE_GROUP_4() {
        return VM_VOLATILE_GROUP_4;
    }
    private static final int VM_VOLATILE_GROUP_5 = (int)1280L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_5 1280
     * }
     */
    public static int VM_VOLATILE_GROUP_5() {
        return VM_VOLATILE_GROUP_5;
    }
    private static final int VM_VOLATILE_GROUP_6 = (int)1536L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_6 1536
     * }
     */
    public static int VM_VOLATILE_GROUP_6() {
        return VM_VOLATILE_GROUP_6;
    }
    private static final int VM_VOLATILE_GROUP_7 = (int)1792L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_GROUP_7 1792
     * }
     */
    public static int VM_VOLATILE_GROUP_7() {
        return VM_VOLATILE_GROUP_7;
    }
    private static final int VM_PURGABLE_BEHAVIOR_MASK = (int)64L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_BEHAVIOR_MASK 64
     * }
     */
    public static int VM_PURGABLE_BEHAVIOR_MASK() {
        return VM_PURGABLE_BEHAVIOR_MASK;
    }
    private static final int VM_PURGABLE_BEHAVIOR_FIFO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_BEHAVIOR_FIFO 0
     * }
     */
    public static int VM_PURGABLE_BEHAVIOR_FIFO() {
        return VM_PURGABLE_BEHAVIOR_FIFO;
    }
    private static final int VM_PURGABLE_BEHAVIOR_LIFO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_BEHAVIOR_LIFO 64
     * }
     */
    public static int VM_PURGABLE_BEHAVIOR_LIFO() {
        return VM_PURGABLE_BEHAVIOR_LIFO;
    }
    private static final int VM_PURGABLE_ORDERING_MASK = (int)32L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_ORDERING_MASK 32
     * }
     */
    public static int VM_PURGABLE_ORDERING_MASK() {
        return VM_PURGABLE_ORDERING_MASK;
    }
    private static final int VM_PURGABLE_ORDERING_OBSOLETE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_ORDERING_OBSOLETE 32
     * }
     */
    public static int VM_PURGABLE_ORDERING_OBSOLETE() {
        return VM_PURGABLE_ORDERING_OBSOLETE;
    }
    private static final int VM_PURGABLE_ORDERING_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_ORDERING_NORMAL 0
     * }
     */
    public static int VM_PURGABLE_ORDERING_NORMAL() {
        return VM_PURGABLE_ORDERING_NORMAL;
    }
    private static final int VM_VOLATILE_ORDER_MASK = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_ORDER_MASK 16
     * }
     */
    public static int VM_VOLATILE_ORDER_MASK() {
        return VM_VOLATILE_ORDER_MASK;
    }
    private static final int VM_VOLATILE_MAKE_FIRST_IN_GROUP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_MAKE_FIRST_IN_GROUP 16
     * }
     */
    public static int VM_VOLATILE_MAKE_FIRST_IN_GROUP() {
        return VM_VOLATILE_MAKE_FIRST_IN_GROUP;
    }
    private static final int VM_VOLATILE_MAKE_LAST_IN_GROUP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_VOLATILE_MAKE_LAST_IN_GROUP 0
     * }
     */
    public static int VM_VOLATILE_MAKE_LAST_IN_GROUP() {
        return VM_VOLATILE_MAKE_LAST_IN_GROUP;
    }
    private static final int VM_PURGABLE_ALL_MASKS = (int)79731L;
    /**
     * {@snippet lang=c :
     * #define VM_PURGABLE_ALL_MASKS 79731
     * }
     */
    public static int VM_PURGABLE_ALL_MASKS() {
        return VM_PURGABLE_ALL_MASKS;
    }
    private static final int VM_BEHAVIOR_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_DEFAULT 0
     * }
     */
    public static int VM_BEHAVIOR_DEFAULT() {
        return VM_BEHAVIOR_DEFAULT;
    }
    private static final int VM_BEHAVIOR_RANDOM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_RANDOM 1
     * }
     */
    public static int VM_BEHAVIOR_RANDOM() {
        return VM_BEHAVIOR_RANDOM;
    }
    private static final int VM_BEHAVIOR_SEQUENTIAL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_SEQUENTIAL 2
     * }
     */
    public static int VM_BEHAVIOR_SEQUENTIAL() {
        return VM_BEHAVIOR_SEQUENTIAL;
    }
    private static final int VM_BEHAVIOR_RSEQNTL = (int)3L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_RSEQNTL 3
     * }
     */
    public static int VM_BEHAVIOR_RSEQNTL() {
        return VM_BEHAVIOR_RSEQNTL;
    }
    private static final int VM_BEHAVIOR_WILLNEED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_WILLNEED 4
     * }
     */
    public static int VM_BEHAVIOR_WILLNEED() {
        return VM_BEHAVIOR_WILLNEED;
    }
    private static final int VM_BEHAVIOR_DONTNEED = (int)5L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_DONTNEED 5
     * }
     */
    public static int VM_BEHAVIOR_DONTNEED() {
        return VM_BEHAVIOR_DONTNEED;
    }
    private static final int VM_BEHAVIOR_FREE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_FREE 6
     * }
     */
    public static int VM_BEHAVIOR_FREE() {
        return VM_BEHAVIOR_FREE;
    }
    private static final int VM_BEHAVIOR_ZERO_WIRED_PAGES = (int)7L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_ZERO_WIRED_PAGES 7
     * }
     */
    public static int VM_BEHAVIOR_ZERO_WIRED_PAGES() {
        return VM_BEHAVIOR_ZERO_WIRED_PAGES;
    }
    private static final int VM_BEHAVIOR_REUSABLE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_REUSABLE 8
     * }
     */
    public static int VM_BEHAVIOR_REUSABLE() {
        return VM_BEHAVIOR_REUSABLE;
    }
    private static final int VM_BEHAVIOR_REUSE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_REUSE 9
     * }
     */
    public static int VM_BEHAVIOR_REUSE() {
        return VM_BEHAVIOR_REUSE;
    }
    private static final int VM_BEHAVIOR_CAN_REUSE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_CAN_REUSE 10
     * }
     */
    public static int VM_BEHAVIOR_CAN_REUSE() {
        return VM_BEHAVIOR_CAN_REUSE;
    }
    private static final int VM_BEHAVIOR_PAGEOUT = (int)11L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_PAGEOUT 11
     * }
     */
    public static int VM_BEHAVIOR_PAGEOUT() {
        return VM_BEHAVIOR_PAGEOUT;
    }
    private static final int VM_BEHAVIOR_ZERO = (int)12L;
    /**
     * {@snippet lang=c :
     * #define VM_BEHAVIOR_ZERO 12
     * }
     */
    public static int VM_BEHAVIOR_ZERO() {
        return VM_BEHAVIOR_ZERO;
    }
    private static final int VM_REGION_INFO_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_INFO_MAX 1024
     * }
     */
    public static int VM_REGION_INFO_MAX() {
        return VM_REGION_INFO_MAX;
    }
    private static final int VM_REGION_BASIC_INFO_COUNT_64 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_BASIC_INFO_COUNT_64 9
     * }
     */
    public static int VM_REGION_BASIC_INFO_COUNT_64() {
        return VM_REGION_BASIC_INFO_COUNT_64;
    }
    private static final int VM_REGION_BASIC_INFO_COUNT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_BASIC_INFO_COUNT 8
     * }
     */
    public static int VM_REGION_BASIC_INFO_COUNT() {
        return VM_REGION_BASIC_INFO_COUNT;
    }
    private static final int VM_REGION_EXTENDED_INFO_COUNT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_EXTENDED_INFO_COUNT 9
     * }
     */
    public static int VM_REGION_EXTENDED_INFO_COUNT() {
        return VM_REGION_EXTENDED_INFO_COUNT;
    }
    private static final int VM_REGION_TOP_INFO_COUNT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_TOP_INFO_COUNT 5
     * }
     */
    public static int VM_REGION_TOP_INFO_COUNT() {
        return VM_REGION_TOP_INFO_COUNT;
    }
    private static final int VM_REGION_SUBMAP_INFO_COUNT = (int)15L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_SUBMAP_INFO_COUNT 15
     * }
     */
    public static int VM_REGION_SUBMAP_INFO_COUNT() {
        return VM_REGION_SUBMAP_INFO_COUNT;
    }
    private static final long VM_REGION_SUBMAP_INFO_V2_SIZE = 76L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_SUBMAP_INFO_V2_SIZE 76
     * }
     */
    public static long VM_REGION_SUBMAP_INFO_V2_SIZE() {
        return VM_REGION_SUBMAP_INFO_V2_SIZE;
    }
    private static final long VM_REGION_SUBMAP_INFO_V1_SIZE = 68L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_SUBMAP_INFO_V1_SIZE 68
     * }
     */
    public static long VM_REGION_SUBMAP_INFO_V1_SIZE() {
        return VM_REGION_SUBMAP_INFO_V1_SIZE;
    }
    private static final long VM_REGION_SUBMAP_INFO_V0_SIZE = 64L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_SUBMAP_INFO_V0_SIZE 64
     * }
     */
    public static long VM_REGION_SUBMAP_INFO_V0_SIZE() {
        return VM_REGION_SUBMAP_INFO_V0_SIZE;
    }
    private static final int VM_REGION_SUBMAP_INFO_V2_COUNT_64 = (int)19L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_SUBMAP_INFO_V2_COUNT_64 19
     * }
     */
    public static int VM_REGION_SUBMAP_INFO_V2_COUNT_64() {
        return VM_REGION_SUBMAP_INFO_V2_COUNT_64;
    }
    private static final int VM_REGION_SUBMAP_INFO_V1_COUNT_64 = (int)17L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_SUBMAP_INFO_V1_COUNT_64 17
     * }
     */
    public static int VM_REGION_SUBMAP_INFO_V1_COUNT_64() {
        return VM_REGION_SUBMAP_INFO_V1_COUNT_64;
    }
    private static final int VM_REGION_SUBMAP_INFO_V0_COUNT_64 = (int)16L;
    /**
     * {@snippet lang=c :
     * #define VM_REGION_SUBMAP_INFO_V0_COUNT_64 16
     * }
     */
    public static int VM_REGION_SUBMAP_INFO_V0_COUNT_64() {
        return VM_REGION_SUBMAP_INFO_V0_COUNT_64;
    }
}

