// Generated by jextract

package com.github.marschall.objectivej.header;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct malloc_introspection_t {
 *     kern_return_t (*enumerator)(task_t, void *, unsigned int, vm_address_t, memory_reader_t *, vm_range_recorder_t *);
 *     size_t (*good_size)(malloc_zone_t *, size_t);
 *     boolean_t (*check)(malloc_zone_t *);
 *     void (*print)(malloc_zone_t *, boolean_t);
 *     void (*log)(malloc_zone_t *, void *);
 *     void (*force_lock)(malloc_zone_t *);
 *     void (*force_unlock)(malloc_zone_t *);
 *     void (*statistics)(malloc_zone_t *, malloc_statistics_t *);
 *     boolean_t (*zone_locked)(malloc_zone_t *);
 *     boolean_t (*enable_discharge_checking)(malloc_zone_t *);
 *     void (*disable_discharge_checking)(malloc_zone_t *);
 *     void (*discharge)(malloc_zone_t *, void *);
 *     void (*enumerate_discharged_pointers)(malloc_zone_t *, void (^)(void *, void *));
 *     void (*reinit_lock)(malloc_zone_t *);
 *     void (*print_task)(task_t, unsigned int, vm_address_t, memory_reader_t *, print_task_printer_t *);
 *     void (*task_statistics)(task_t, vm_address_t, memory_reader_t *, malloc_statistics_t *);
 *     unsigned int zone_type;
 * }
 * }
 */
public class malloc_introspection_t {

    malloc_introspection_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        ObjCRuntime.C_POINTER.withName("enumerator"),
        ObjCRuntime.C_POINTER.withName("good_size"),
        ObjCRuntime.C_POINTER.withName("check"),
        ObjCRuntime.C_POINTER.withName("print"),
        ObjCRuntime.C_POINTER.withName("log"),
        ObjCRuntime.C_POINTER.withName("force_lock"),
        ObjCRuntime.C_POINTER.withName("force_unlock"),
        ObjCRuntime.C_POINTER.withName("statistics"),
        ObjCRuntime.C_POINTER.withName("zone_locked"),
        ObjCRuntime.C_POINTER.withName("enable_discharge_checking"),
        ObjCRuntime.C_POINTER.withName("disable_discharge_checking"),
        ObjCRuntime.C_POINTER.withName("discharge"),
        ObjCRuntime.C_POINTER.withName("enumerate_discharged_pointers"),
        ObjCRuntime.C_POINTER.withName("reinit_lock"),
        ObjCRuntime.C_POINTER.withName("print_task"),
        ObjCRuntime.C_POINTER.withName("task_statistics"),
        ObjCRuntime.C_INT.withName("zone_type"),
        MemoryLayout.paddingLayout(4)
    ).withName("malloc_introspection_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * kern_return_t (*enumerator)(task_t, void *, unsigned int, vm_address_t, memory_reader_t *, vm_range_recorder_t *)
     * }
     */
    public static class enumerator {

        enumerator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(int _x0, MemorySegment _x1, int _x2, long _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(enumerator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(enumerator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,int _x0, MemorySegment _x1, int _x2, long _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout enumerator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("enumerator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * kern_return_t (*enumerator)(task_t, void *, unsigned int, vm_address_t, memory_reader_t *, vm_range_recorder_t *)
     * }
     */
    public static final AddressLayout enumerator$layout() {
        return enumerator$LAYOUT;
    }

    private static final long enumerator$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * kern_return_t (*enumerator)(task_t, void *, unsigned int, vm_address_t, memory_reader_t *, vm_range_recorder_t *)
     * }
     */
    public static final long enumerator$offset() {
        return enumerator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * kern_return_t (*enumerator)(task_t, void *, unsigned int, vm_address_t, memory_reader_t *, vm_range_recorder_t *)
     * }
     */
    public static MemorySegment enumerator(MemorySegment struct) {
        return struct.get(enumerator$LAYOUT, enumerator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * kern_return_t (*enumerator)(task_t, void *, unsigned int, vm_address_t, memory_reader_t *, vm_range_recorder_t *)
     * }
     */
    public static void enumerator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(enumerator$LAYOUT, enumerator$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * size_t (*good_size)(malloc_zone_t *, size_t)
     * }
     */
    public static class good_size {

        good_size() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, long _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(good_size.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(good_size.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout good_size$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("good_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t (*good_size)(malloc_zone_t *, size_t)
     * }
     */
    public static final AddressLayout good_size$layout() {
        return good_size$LAYOUT;
    }

    private static final long good_size$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t (*good_size)(malloc_zone_t *, size_t)
     * }
     */
    public static final long good_size$offset() {
        return good_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t (*good_size)(malloc_zone_t *, size_t)
     * }
     */
    public static MemorySegment good_size(MemorySegment struct) {
        return struct.get(good_size$LAYOUT, good_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t (*good_size)(malloc_zone_t *, size_t)
     * }
     */
    public static void good_size(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(good_size$LAYOUT, good_size$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * boolean_t (*check)(malloc_zone_t *)
     * }
     */
    public static class check {

        check() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(check.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(check.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout check$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("check"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean_t (*check)(malloc_zone_t *)
     * }
     */
    public static final AddressLayout check$layout() {
        return check$LAYOUT;
    }

    private static final long check$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean_t (*check)(malloc_zone_t *)
     * }
     */
    public static final long check$offset() {
        return check$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean_t (*check)(malloc_zone_t *)
     * }
     */
    public static MemorySegment check(MemorySegment struct) {
        return struct.get(check$LAYOUT, check$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean_t (*check)(malloc_zone_t *)
     * }
     */
    public static void check(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(check$LAYOUT, check$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*print)(malloc_zone_t *, boolean_t)
     * }
     */
    public static class print {

        print() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(print.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(print.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout print$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("print"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*print)(malloc_zone_t *, boolean_t)
     * }
     */
    public static final AddressLayout print$layout() {
        return print$LAYOUT;
    }

    private static final long print$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*print)(malloc_zone_t *, boolean_t)
     * }
     */
    public static final long print$offset() {
        return print$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*print)(malloc_zone_t *, boolean_t)
     * }
     */
    public static MemorySegment print(MemorySegment struct) {
        return struct.get(print$LAYOUT, print$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*print)(malloc_zone_t *, boolean_t)
     * }
     */
    public static void print(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(print$LAYOUT, print$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*log)(malloc_zone_t *, void *)
     * }
     */
    public static class log {

        log() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(log.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(log.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout log$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("log"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*log)(malloc_zone_t *, void *)
     * }
     */
    public static final AddressLayout log$layout() {
        return log$LAYOUT;
    }

    private static final long log$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*log)(malloc_zone_t *, void *)
     * }
     */
    public static final long log$offset() {
        return log$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*log)(malloc_zone_t *, void *)
     * }
     */
    public static MemorySegment log(MemorySegment struct) {
        return struct.get(log$LAYOUT, log$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*log)(malloc_zone_t *, void *)
     * }
     */
    public static void log(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(log$LAYOUT, log$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*force_lock)(malloc_zone_t *)
     * }
     */
    public static class force_lock {

        force_lock() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(force_lock.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(force_lock.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout force_lock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("force_lock"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*force_lock)(malloc_zone_t *)
     * }
     */
    public static final AddressLayout force_lock$layout() {
        return force_lock$LAYOUT;
    }

    private static final long force_lock$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*force_lock)(malloc_zone_t *)
     * }
     */
    public static final long force_lock$offset() {
        return force_lock$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*force_lock)(malloc_zone_t *)
     * }
     */
    public static MemorySegment force_lock(MemorySegment struct) {
        return struct.get(force_lock$LAYOUT, force_lock$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*force_lock)(malloc_zone_t *)
     * }
     */
    public static void force_lock(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(force_lock$LAYOUT, force_lock$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*force_unlock)(malloc_zone_t *)
     * }
     */
    public static class force_unlock {

        force_unlock() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(force_unlock.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(force_unlock.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout force_unlock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("force_unlock"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*force_unlock)(malloc_zone_t *)
     * }
     */
    public static final AddressLayout force_unlock$layout() {
        return force_unlock$LAYOUT;
    }

    private static final long force_unlock$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*force_unlock)(malloc_zone_t *)
     * }
     */
    public static final long force_unlock$offset() {
        return force_unlock$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*force_unlock)(malloc_zone_t *)
     * }
     */
    public static MemorySegment force_unlock(MemorySegment struct) {
        return struct.get(force_unlock$LAYOUT, force_unlock$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*force_unlock)(malloc_zone_t *)
     * }
     */
    public static void force_unlock(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(force_unlock$LAYOUT, force_unlock$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*statistics)(malloc_zone_t *, malloc_statistics_t *)
     * }
     */
    public static class statistics {

        statistics() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(statistics.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(statistics.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout statistics$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("statistics"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*statistics)(malloc_zone_t *, malloc_statistics_t *)
     * }
     */
    public static final AddressLayout statistics$layout() {
        return statistics$LAYOUT;
    }

    private static final long statistics$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*statistics)(malloc_zone_t *, malloc_statistics_t *)
     * }
     */
    public static final long statistics$offset() {
        return statistics$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*statistics)(malloc_zone_t *, malloc_statistics_t *)
     * }
     */
    public static MemorySegment statistics(MemorySegment struct) {
        return struct.get(statistics$LAYOUT, statistics$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*statistics)(malloc_zone_t *, malloc_statistics_t *)
     * }
     */
    public static void statistics(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(statistics$LAYOUT, statistics$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * boolean_t (*zone_locked)(malloc_zone_t *)
     * }
     */
    public static class zone_locked {

        zone_locked() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(zone_locked.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(zone_locked.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout zone_locked$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("zone_locked"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean_t (*zone_locked)(malloc_zone_t *)
     * }
     */
    public static final AddressLayout zone_locked$layout() {
        return zone_locked$LAYOUT;
    }

    private static final long zone_locked$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean_t (*zone_locked)(malloc_zone_t *)
     * }
     */
    public static final long zone_locked$offset() {
        return zone_locked$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean_t (*zone_locked)(malloc_zone_t *)
     * }
     */
    public static MemorySegment zone_locked(MemorySegment struct) {
        return struct.get(zone_locked$LAYOUT, zone_locked$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean_t (*zone_locked)(malloc_zone_t *)
     * }
     */
    public static void zone_locked(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(zone_locked$LAYOUT, zone_locked$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * boolean_t (*enable_discharge_checking)(malloc_zone_t *)
     * }
     */
    public static class enable_discharge_checking {

        enable_discharge_checking() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(enable_discharge_checking.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(enable_discharge_checking.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout enable_discharge_checking$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("enable_discharge_checking"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * boolean_t (*enable_discharge_checking)(malloc_zone_t *)
     * }
     */
    public static final AddressLayout enable_discharge_checking$layout() {
        return enable_discharge_checking$LAYOUT;
    }

    private static final long enable_discharge_checking$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * boolean_t (*enable_discharge_checking)(malloc_zone_t *)
     * }
     */
    public static final long enable_discharge_checking$offset() {
        return enable_discharge_checking$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * boolean_t (*enable_discharge_checking)(malloc_zone_t *)
     * }
     */
    public static MemorySegment enable_discharge_checking(MemorySegment struct) {
        return struct.get(enable_discharge_checking$LAYOUT, enable_discharge_checking$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * boolean_t (*enable_discharge_checking)(malloc_zone_t *)
     * }
     */
    public static void enable_discharge_checking(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(enable_discharge_checking$LAYOUT, enable_discharge_checking$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*disable_discharge_checking)(malloc_zone_t *)
     * }
     */
    public static class disable_discharge_checking {

        disable_discharge_checking() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(disable_discharge_checking.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(disable_discharge_checking.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout disable_discharge_checking$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("disable_discharge_checking"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*disable_discharge_checking)(malloc_zone_t *)
     * }
     */
    public static final AddressLayout disable_discharge_checking$layout() {
        return disable_discharge_checking$LAYOUT;
    }

    private static final long disable_discharge_checking$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*disable_discharge_checking)(malloc_zone_t *)
     * }
     */
    public static final long disable_discharge_checking$offset() {
        return disable_discharge_checking$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*disable_discharge_checking)(malloc_zone_t *)
     * }
     */
    public static MemorySegment disable_discharge_checking(MemorySegment struct) {
        return struct.get(disable_discharge_checking$LAYOUT, disable_discharge_checking$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*disable_discharge_checking)(malloc_zone_t *)
     * }
     */
    public static void disable_discharge_checking(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(disable_discharge_checking$LAYOUT, disable_discharge_checking$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*discharge)(malloc_zone_t *, void *)
     * }
     */
    public static class discharge {

        discharge() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(discharge.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(discharge.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout discharge$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("discharge"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*discharge)(malloc_zone_t *, void *)
     * }
     */
    public static final AddressLayout discharge$layout() {
        return discharge$LAYOUT;
    }

    private static final long discharge$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*discharge)(malloc_zone_t *, void *)
     * }
     */
    public static final long discharge$offset() {
        return discharge$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*discharge)(malloc_zone_t *, void *)
     * }
     */
    public static MemorySegment discharge(MemorySegment struct) {
        return struct.get(discharge$LAYOUT, discharge$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*discharge)(malloc_zone_t *, void *)
     * }
     */
    public static void discharge(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(discharge$LAYOUT, discharge$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*enumerate_discharged_pointers)(malloc_zone_t *, void (^)(void *, void *))
     * }
     */
    public static class enumerate_discharged_pointers {

        enumerate_discharged_pointers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(enumerate_discharged_pointers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(enumerate_discharged_pointers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout enumerate_discharged_pointers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("enumerate_discharged_pointers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*enumerate_discharged_pointers)(malloc_zone_t *, void (^)(void *, void *))
     * }
     */
    public static final AddressLayout enumerate_discharged_pointers$layout() {
        return enumerate_discharged_pointers$LAYOUT;
    }

    private static final long enumerate_discharged_pointers$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*enumerate_discharged_pointers)(malloc_zone_t *, void (^)(void *, void *))
     * }
     */
    public static final long enumerate_discharged_pointers$offset() {
        return enumerate_discharged_pointers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*enumerate_discharged_pointers)(malloc_zone_t *, void (^)(void *, void *))
     * }
     */
    public static MemorySegment enumerate_discharged_pointers(MemorySegment struct) {
        return struct.get(enumerate_discharged_pointers$LAYOUT, enumerate_discharged_pointers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*enumerate_discharged_pointers)(malloc_zone_t *, void (^)(void *, void *))
     * }
     */
    public static void enumerate_discharged_pointers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(enumerate_discharged_pointers$LAYOUT, enumerate_discharged_pointers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*reinit_lock)(malloc_zone_t *)
     * }
     */
    public static class reinit_lock {

        reinit_lock() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(reinit_lock.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(reinit_lock.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout reinit_lock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reinit_lock"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*reinit_lock)(malloc_zone_t *)
     * }
     */
    public static final AddressLayout reinit_lock$layout() {
        return reinit_lock$LAYOUT;
    }

    private static final long reinit_lock$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*reinit_lock)(malloc_zone_t *)
     * }
     */
    public static final long reinit_lock$offset() {
        return reinit_lock$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*reinit_lock)(malloc_zone_t *)
     * }
     */
    public static MemorySegment reinit_lock(MemorySegment struct) {
        return struct.get(reinit_lock$LAYOUT, reinit_lock$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*reinit_lock)(malloc_zone_t *)
     * }
     */
    public static void reinit_lock(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reinit_lock$LAYOUT, reinit_lock$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*print_task)(task_t, unsigned int, vm_address_t, memory_reader_t *, print_task_printer_t *)
     * }
     */
    public static class print_task {

        print_task() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(int _x0, int _x1, long _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(print_task.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(print_task.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,int _x0, int _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout print_task$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("print_task"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*print_task)(task_t, unsigned int, vm_address_t, memory_reader_t *, print_task_printer_t *)
     * }
     */
    public static final AddressLayout print_task$layout() {
        return print_task$LAYOUT;
    }

    private static final long print_task$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*print_task)(task_t, unsigned int, vm_address_t, memory_reader_t *, print_task_printer_t *)
     * }
     */
    public static final long print_task$offset() {
        return print_task$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*print_task)(task_t, unsigned int, vm_address_t, memory_reader_t *, print_task_printer_t *)
     * }
     */
    public static MemorySegment print_task(MemorySegment struct) {
        return struct.get(print_task$LAYOUT, print_task$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*print_task)(task_t, unsigned int, vm_address_t, memory_reader_t *, print_task_printer_t *)
     * }
     */
    public static void print_task(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(print_task$LAYOUT, print_task$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*task_statistics)(task_t, vm_address_t, memory_reader_t *, malloc_statistics_t *)
     * }
     */
    public static class task_statistics {

        task_statistics() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(int _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            ObjCRuntime.C_INT,
            ObjCRuntime.C_LONG,
            ObjCRuntime.C_POINTER,
            ObjCRuntime.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = ObjCRuntime.upcallHandle(task_statistics.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(task_statistics.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,int _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout task_statistics$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("task_statistics"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*task_statistics)(task_t, vm_address_t, memory_reader_t *, malloc_statistics_t *)
     * }
     */
    public static final AddressLayout task_statistics$layout() {
        return task_statistics$LAYOUT;
    }

    private static final long task_statistics$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*task_statistics)(task_t, vm_address_t, memory_reader_t *, malloc_statistics_t *)
     * }
     */
    public static final long task_statistics$offset() {
        return task_statistics$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*task_statistics)(task_t, vm_address_t, memory_reader_t *, malloc_statistics_t *)
     * }
     */
    public static MemorySegment task_statistics(MemorySegment struct) {
        return struct.get(task_statistics$LAYOUT, task_statistics$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*task_statistics)(task_t, vm_address_t, memory_reader_t *, malloc_statistics_t *)
     * }
     */
    public static void task_statistics(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(task_statistics$LAYOUT, task_statistics$OFFSET, fieldValue);
    }

    private static final OfInt zone_type$LAYOUT = (OfInt)$LAYOUT.select(groupElement("zone_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int zone_type
     * }
     */
    public static final OfInt zone_type$layout() {
        return zone_type$LAYOUT;
    }

    private static final long zone_type$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int zone_type
     * }
     */
    public static final long zone_type$offset() {
        return zone_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int zone_type
     * }
     */
    public static int zone_type(MemorySegment struct) {
        return struct.get(zone_type$LAYOUT, zone_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int zone_type
     * }
     */
    public static void zone_type(MemorySegment struct, int fieldValue) {
        struct.set(zone_type$LAYOUT, zone_type$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

